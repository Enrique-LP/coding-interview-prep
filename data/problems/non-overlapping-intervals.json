{
    "id": "non-overlapping-intervals",
    "title": "Non-overlapping Intervals",
    "description": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",
    "examples": [
        {
            "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
            "output": "1",
            "explanation": "[1,3] can be removed and the rest of the intervals are non-overlapping."
        },
        {
            "input": "intervals = [[1,2],[1,2],[1,2]]",
            "output": "2",
            "explanation": "You need to remove two [1,2] to make the rest of the intervals non-overlapping."
        }
    ],
    "constraints": [
        "1 <= intervals.length <= 10^5",
        "intervals[i].length == 2",
        "-5 * 10^4 <= starti < endi <= 5 * 10^4"
    ],
    "difficulty": "Medium",
    "topic": "Intervals",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Sorting + Greedy",
            "description": "Sort and remove intervals that end late.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function erase_overlap_intervals that takes intervals.",
                    "placeholderCode": "def erase_overlap_intervals(intervals):",
                    "validationRegex": "^def\\s+erase_overlap_intervals\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def erase_overlap_intervals(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals by start time.",
                    "placeholderCode": "    intervals.sort()",
                    "validationRegex": "^\\s+intervals\\.sort\\(\\)$",
                    "hint": "Sort intervals by start time.",
                    "solutionCode": "    intervals.sort()"
                },
                {
                    "id": 3,
                    "instruction": "Iterate and count removals.",
                    "placeholderCode": "    res = 0\n    prevEnd = intervals[0][1]\n    for start, end in intervals[1:]:\n        if start >= prevEnd:\n            prevEnd = end\n        else:\n            res += 1\n            prevEnd = min(prevEnd, end)",
                    "validationRegex": "^\\s+res\\s*=\\s*0\\s*prevEnd\\s*=\\s*intervals\\[0\\]\\[1\\]\\s*for\\s+start,\\s*end\\s+in\\s+intervals\\[1:\\]:\\s*if\\s+start\\s*>=\\s+prevEnd:\\s*prevEnd\\s*=\\s*end\\s*else:\\s*res\\s*\\+=\\s*1\\s*prevEnd\\s*=\\s*min\\(prevEnd,\\s*end\\)$",
                    "hint": "Iterate. If current interval starts after previous ends, no overlap (update prevEnd). If overlap, remove the one that ends later (increment res, update prevEnd to min of ends) to minimize chance of future overlaps.",
                    "solutionCode": "    res = 0\n    prevEnd = intervals[0][1]\n    for start, end in intervals[1:]:\n        if start >= prevEnd:\n            prevEnd = end\n        else:\n            res += 1\n            prevEnd = min(prevEnd, end)"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the count of removed intervals.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Sorting + Greedy",
            "description": "Same as brute force, O(n log n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function erase_overlap_intervals that takes intervals.",
                    "placeholderCode": "def erase_overlap_intervals(intervals):",
                    "validationRegex": "^def\\s+erase_overlap_intervals\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def erase_overlap_intervals(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals by start time.",
                    "placeholderCode": "    intervals.sort()",
                    "validationRegex": "^\\s+intervals\\.sort\\(\\)$",
                    "hint": "Sort intervals.",
                    "solutionCode": "    intervals.sort()"
                },
                {
                    "id": 3,
                    "instruction": "Iterate and count removals.",
                    "placeholderCode": "    res = 0\n    prevEnd = intervals[0][1]\n    for start, end in intervals[1:]:\n        if start >= prevEnd:\n            prevEnd = end\n        else:\n            res += 1\n            prevEnd = min(prevEnd, end)",
                    "validationRegex": "^\\s+res\\s*=\\s*0\\s*prevEnd\\s*=\\s*intervals\\[0\\]\\[1\\]\\s*for\\s+start,\\s*end\\s+in\\s+intervals\\[1:\\]:\\s*if\\s+start\\s*>=\\s+prevEnd:\\s*prevEnd\\s*=\\s*end\\s*else:\\s*res\\s*\\+=\\s*1\\s*prevEnd\\s*=\\s*min\\(prevEnd,\\s*end\\)$",
                    "hint": "Greedily remove overlapping intervals.",
                    "solutionCode": "    res = 0\n    prevEnd = intervals[0][1]\n    for start, end in intervals[1:]:\n        if start >= prevEnd:\n            prevEnd = end\n        else:\n            res += 1\n            prevEnd = min(prevEnd, end)"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return result.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}