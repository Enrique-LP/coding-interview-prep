{
    "id": "min-stack",
    "title": "Min Stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    "examples": [
        {
            "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]",
            "output": "[null,null,null,null,-3,null,0,-2]"
        }
    ],
    "constraints": [
        "-2^31 <= val <= 2^31 - 1",
        "Methods pop, top and getMin operations will always be called on non-empty stacks.",
        "At most 3 * 10^4 calls will be made to push, pop, top, and getMin."
    ],
    "difficulty": "Medium",
    "topic": "Stack",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Two Stacks",
            "description": "Use a second stack to keep track of minimums.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the class MinStack.",
                    "placeholderCode": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []",
                    "validationRegex": "^class\\s+MinStack:\\s*def\\s+__init__\\(self\\):\\s*self\\.stack\\s*=\\s*\\[\\]\\s*self\\.minStack\\s*=\\s*\\[\\]$",
                    "hint": "Initialize `stack` and `minStack`.",
                    "solutionCode": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []"
                },
                {
                    "id": 2,
                    "instruction": "Implement push.",
                    "placeholderCode": "    def push(self, val):\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)",
                    "validationRegex": "^\\s+def\\s+push\\(self,\\s*val\\):\\s*self\\.stack\\.append\\(val\\)\\s*val\\s*=\\s*min\\(val,\\s*self\\.minStack\\[-1\\]\\s+if\\s+self\\.minStack\\s+else\\s+val\\)\\s*self\\.minStack\\.append\\(val\\)$",
                    "hint": "Append to `stack`. Append min of `val` and current min to `minStack`.\\n\\nExample:\\nPush -2. Stack=[-2], MinStack=[-2].\\nPush 0. Stack=[-2, 0], MinStack=[-2, -2] (min of 0 and -2).",
                    "solutionCode": "    def push(self, val):\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)"
                },
                {
                    "id": 3,
                    "instruction": "Implement pop.",
                    "placeholderCode": "    def pop(self):\n        self.stack.pop()\n        self.minStack.pop()",
                    "validationRegex": "^\\s+def\\s+pop\\(self\\):\\s*self\\.stack\\.pop\\(\\)\\s*self\\.minStack\\.pop\\(\\)$",
                    "hint": "Pop from both stacks.",
                    "solutionCode": "    def pop(self):\n        self.stack.pop()\n        self.minStack.pop()"
                },
                {
                    "id": 4,
                    "instruction": "Implement top.",
                    "placeholderCode": "    def top(self):\n        return self.stack[-1]",
                    "validationRegex": "^\\s+def\\s+top\\(self\\):\\s*return\\s+self\\.stack\\[-1\\]$",
                    "hint": "Return top of `stack`.",
                    "solutionCode": "    def top(self):\n        return self.stack[-1]"
                },
                {
                    "id": 5,
                    "instruction": "Implement getMin.",
                    "placeholderCode": "    def getMin(self):\n        return self.minStack[-1]",
                    "validationRegex": "^\\s+def\\s+getMin\\(self\\):\\s*return\\s+self\\.minStack\\[-1\\]$",
                    "hint": "Return top of `minStack`.",
                    "solutionCode": "    def getMin(self):\n        return self.minStack[-1]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Two Stacks",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the class MinStack.",
                    "placeholderCode": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []",
                    "validationRegex": "^class\\s+MinStack:\\s*def\\s+__init__\\(self\\):\\s*self\\.stack\\s*=\\s*\\[\\]\\s*self\\.minStack\\s*=\\s*\\[\\]$",
                    "hint": "Initialize `stack` and `minStack`.",
                    "solutionCode": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []"
                },
                {
                    "id": 2,
                    "instruction": "Implement push.",
                    "placeholderCode": "    def push(self, val):\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)",
                    "validationRegex": "^\\s+def\\s+push\\(self,\\s*val\\):\\s*self\\.stack\\.append\\(val\\)\\s*val\\s*=\\s*min\\(val,\\s*self\\.minStack\\[-1\\]\\s+if\\s+self\\.minStack\\s+else\\s+val\\)\\s*self\\.minStack\\.append\\(val\\)$",
                    "hint": "Append to `stack`. Append min of `val` and current min to `minStack`.",
                    "solutionCode": "    def push(self, val):\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)"
                },
                {
                    "id": 3,
                    "instruction": "Implement pop.",
                    "placeholderCode": "    def pop(self):\n        self.stack.pop()\n        self.minStack.pop()",
                    "validationRegex": "^\\s+def\\s+pop\\(self\\):\\s*self\\.stack\\.pop\\(\\)\\s*self\\.minStack\\.pop\\(\\)$",
                    "hint": "Pop from both stacks.",
                    "solutionCode": "    def pop(self):\n        self.stack.pop()\n        self.minStack.pop()"
                },
                {
                    "id": 4,
                    "instruction": "Implement top.",
                    "placeholderCode": "    def top(self):\n        return self.stack[-1]",
                    "validationRegex": "^\\s+def\\s+top\\(self\\):\\s*return\\s+self\\.stack\\[-1\\]$",
                    "hint": "Return top of `stack`.",
                    "solutionCode": "    def top(self):\n        return self.stack[-1]"
                },
                {
                    "id": 5,
                    "instruction": "Implement getMin.",
                    "placeholderCode": "    def getMin(self):\n        return self.minStack[-1]",
                    "validationRegex": "^\\s+def\\s+getMin\\(self\\):\\s*return\\s+self\\.minStack\\[-1\\]$",
                    "hint": "Return top of `minStack`.",
                    "solutionCode": "    def getMin(self):\n        return self.minStack[-1]"
                }
            ]
        }
    }
}