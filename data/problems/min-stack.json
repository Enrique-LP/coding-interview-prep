{
    "id": "min-stack",
    "title": "Min Stack",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    "examples": [
        {
            "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]",
            "output": "[null,null,null,null,-3,null,0,-2]"
        }
    ],
    "constraints": [
        "-2^31 <= val <= 2^31 - 1",
        "Methods pop, top and getMin operations will always be called on non-empty stacks.",
        "At most 3 * 10^4 calls will be made to push, pop, top, and getMin."
    ],
    "difficulty": "Medium",
    "topic": "Stack",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Two Stacks",
            "description": "Use a second stack to keep track of minimums.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the class MinStack.",
                    "placeholderCode": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []",
                    "validationRegex": "^class\\s+MinStack:\\s*def\\s+__init__\\(self\\):\\s*self\\.stack\\s*=\\s*\\[\\]\\s*self\\.minStack\\s*=\\s*\\[\\]$",
                    "hint": "Initialize `stack` and `minStack`.",
                    "solutionCode": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []"
                },
                {
                    "id": 2,
                    "instruction": "Implement push.",
                    "placeholderCode": "    def push(self, val):\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)",
                    "validationRegex": "^\\s+def\\s+push\\(self,\\s*val\\):\\s*self\\.stack\\.append\\(val\\)\\s*val\\s*=\\s*min\\(val,\\s*self\\.minStack\\[-1\\]\\s+if\\s+self\\.minStack\\s+else\\s+val\\)\\s*self\\.minStack\\.append\\(val\\)$",
                    "hint": "Append to `stack`. Append min of `val` and current min to `minStack`.\\n\\nExample:\\nPush -2. Stack=[-2], MinStack=[-2].\\nPush 0. Stack=[-2, 0], MinStack=[-2, -2] (min of 0 and -2).",
                    "solutionCode": "    def push(self, val):\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)"
                },
                {
                    "id": 3,
                    "instruction": "Implement pop.",
                    "placeholderCode": "    def pop(self):\n        self.stack.pop()\n        self.minStack.pop()",
                    "validationRegex": "^\\s+def\\s+pop\\(self\\):\\s*self\\.stack\\.pop\\(\\)\\s*self\\.minStack\\.pop\\(\\)$",
                    "hint": "Pop from both stacks.",
                    "solutionCode": "    def pop(self):\n        self.stack.pop()\n        self.minStack.pop()"
                },
                {
                    "id": 4,
                    "instruction": "Implement top.",
                    "placeholderCode": "    def top(self):\n        return self.stack[-1]",
                    "validationRegex": "^\\s+def\\s+top\\(self\\):\\s*return\\s+self\\.stack\\[-1\\]$",
                    "hint": "Return top of `stack`.",
                    "solutionCode": "    def top(self):\n        return self.stack[-1]"
                },
                {
                    "id": 5,
                    "instruction": "Implement getMin.",
                    "placeholderCode": "    def getMin(self):\n        return self.minStack[-1]",
                    "validationRegex": "^\\s+def\\s+getMin\\(self\\):\\s*return\\s+self\\.minStack\\[-1\\]$",
                    "hint": "Return top of `minStack`.",
                    "solutionCode": "    def getMin(self):\n        return self.minStack[-1]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Two Stacks",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the MinStack class.",
                    "placeholderCode": "class MinStack:",
                    "validationRegex": "^class\\s+MinStack:$",
                    "hint": "Start by defining the class `MinStack`.",
                    "solutionCode": "class MinStack:"
                },
                {
                    "id": 2,
                    "instruction": "Define the constructor.",
                    "placeholderCode": "    def __init__(self):",
                    "validationRegex": "^\\s+def\\s+__init__\\(self\\):$",
                    "hint": "Define the `__init__` method to initialize the object.",
                    "solutionCode": "    def __init__(self):"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the main stack.",
                    "placeholderCode": "        self.stack = []",
                    "validationRegex": "^\\s+self\\.stack\\s*=\\s*\\[\\]$",
                    "hint": "Create an empty list `self.stack` to store incoming values.",
                    "solutionCode": "        self.stack = []"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the min-stack.",
                    "placeholderCode": "        self.minStack = []",
                    "validationRegex": "^\\s+self\\.minStack\\s*=\\s*\\[\\]$",
                    "hint": "Create a second empty list `self.minStack` to keep track of the minimum values found so far.",
                    "solutionCode": "        self.minStack = []"
                },
                {
                    "id": 5,
                    "instruction": "Define the push method.",
                    "placeholderCode": "    def push(self, val):",
                    "validationRegex": "^\\s+def\\s+push\\(self,\\s*val\\):$",
                    "hint": "Define a method named `push` that takes `val` as an argument.",
                    "solutionCode": "    def push(self, val):"
                },
                {
                    "id": 6,
                    "instruction": "Add the value to the main stack.",
                    "placeholderCode": "        self.stack.append(val)",
                    "validationRegex": "^\\s+self\\.stack\\.append\\(val\\)$",
                    "hint": "Standard stack behavior: just append the new value.",
                    "solutionCode": "        self.stack.append(val)"
                },
                {
                    "id": 7,
                    "instruction": "Calculate the current minimum.",
                    "placeholderCode": "        val = min(val, self.minStack[-1] if self.minStack else val)",
                    "validationRegex": "^\\s+val\\s*=\\s*min\\(val,\\s*self\\.minStack\\[-1\\]\\s+if\\s+self\\.minStack\\s+else\\s+val\\)$",
                    "hint": "Key Logic: The new min is the smaller of the *new value* vs *the previous min* (top of minStack). If minStack is empty, the new val is the min.",
                    "solutionCode": "        val = min(val, self.minStack[-1] if self.minStack else val)"
                },
                {
                    "id": 8,
                    "instruction": "Push the calculated minimum to the min-stack.",
                    "placeholderCode": "        self.minStack.append(val)",
                    "validationRegex": "^\\s+self\\.minStack\\.append\\(val\\)$",
                    "hint": "Store the current minimum at this level so we can retrieve it in O(1).",
                    "solutionCode": "        self.minStack.append(val)"
                },
                {
                    "id": 9,
                    "instruction": "Define the pop method.",
                    "placeholderCode": "    def pop(self):",
                    "validationRegex": "^\\s+def\\s+pop\\(self\\):$",
                    "hint": "Define the method `pop`. It takes no arguments (besides `self`).",
                    "solutionCode": "    def pop(self):"
                },
                {
                    "id": 10,
                    "instruction": "Remove the top element from the main stack.",
                    "placeholderCode": "        self.stack.pop()",
                    "validationRegex": "^\\s+self\\.stack\\.pop\\(\\)$",
                    "hint": "Use the standard list `.pop()` method.",
                    "solutionCode": "        self.stack.pop()"
                },
                {
                    "id": 11,
                    "instruction": "Remove the top element from the min-stack.",
                    "placeholderCode": "        self.minStack.pop()",
                    "validationRegex": "^\\s+self\\.minStack\\.pop\\(\\)$",
                    "hint": "CRITICAL: You must also pop from `minStack` to keep them in sync.",
                    "solutionCode": "        self.minStack.pop()"
                },
                {
                    "id": 12,
                    "instruction": "Define the top method.",
                    "placeholderCode": "    def top(self):",
                    "validationRegex": "^\\s+def\\s+top\\(self\\):$",
                    "hint": "Define a method named `top`. It takes no arguments (besides `self`).",
                    "solutionCode": "    def top(self):"
                },
                {
                    "id": 13,
                    "instruction": "Return the top of the main stack.",
                    "placeholderCode": "        return self.stack[-1]",
                    "validationRegex": "^\\s+return\\s+self\\.stack\\[-1\\]$",
                    "hint": "Access the last element `[-1]` of `self.stack`.",
                    "solutionCode": "        return self.stack[-1]"
                },
                {
                    "id": 14,
                    "instruction": "Define the getMin method.",
                    "placeholderCode": "    def getMin(self):",
                    "validationRegex": "^\\s+def\\s+getMin\\(self\\):$",
                    "hint": "Define a method named `getMin`.",
                    "solutionCode": "    def getMin(self):"
                },
                {
                    "id": 15,
                    "instruction": "Return the minimum value.",
                    "placeholderCode": "        return self.minStack[-1]",
                    "validationRegex": "^\\s+return\\s+self\\.minStack\\[-1\\]$",
                    "hint": "Since `minStack` always tracks the minimum at the top, just return `self.minStack[-1]`.",
                    "solutionCode": "        return self.minStack[-1]"
                }
            ]
        }
    }
}