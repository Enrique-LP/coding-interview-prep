{
    "id": "reorder-list",
    "title": "Reorder List",
    "description": "You are given the head of a singly linked-list. The list can be represented as: L0 -> L1 -> ... -> Ln - 1 -> Ln. Reorder the list to be on the following form: L0 -> Ln -> L1 -> Ln - 1 -> L2 -> Ln - 2 -> ... You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "examples": [
        {
            "input": "head = [1,2,3,4]",
            "output": "[1,4,2,3]"
        },
        {
            "input": "head = [1,2,3,4,5]",
            "output": "[1,5,2,4,3]"
        }
    ],
    "constraints": [
        "The number of nodes in the list is in the range [1, 5 * 10^4].",
        "1 <= Node.val <= 1000"
    ],
    "difficulty": "Medium",
    "topic": "Linked List",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "List Conversion",
            "description": "Convert linked list to array, reorder, and rebuild.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function reorder_list that takes head.",
                    "placeholderCode": "def reorder_list(head):",
                    "validationRegex": "^def\\s+reorder_list\\(head\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def reorder_list(head):"
                },
                {
                    "id": 2,
                    "instruction": "Convert linked list to a list of nodes.",
                    "placeholderCode": "    if not head: return\n    nodes = []\n    curr = head\n    while curr:\n        nodes.append(curr)\n        curr = curr.next",
                    "validationRegex": "^\\s+if\\s+not\\s+head:\\s*return\\s*nodes\\s*=\\s*\\[\\]\\s*curr\\s*=\\s*head\\s*while\\s+curr:\\s*nodes\\.append\\(curr\\)\\s*curr\\s*=\\s*curr\\.next$",
                    "hint": "Traverse the list and store nodes in an array.",
                    "solutionCode": "    if not head: return\n    nodes = []\n    curr = head\n    while curr:\n        nodes.append(curr)\n        curr = curr.next"
                },
                {
                    "id": 3,
                    "instruction": "Use two pointers to reorder the list.",
                    "placeholderCode": "    l, r = 0, len(nodes) - 1\n    while l < r:\n        nodes[l].next = nodes[r]\n        l += 1\n        if l == r: break\n        nodes[r].next = nodes[l]\n        r -= 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(nodes\\)\\s*-\\s*1\\s*while\\s+l\\s*<\\s*r:\\s*nodes\\[l\\]\\.next\\s*=\\s*nodes\\[r\\]\\s*l\\s*\\+=\\s*1\\s*if\\s+l\\s*==\\s*r:\\s*break\\s*nodes\\[r\\]\\.next\\s*=\\s*nodes\\[l\\]\\s*r\\s*-=\\s*1$",
                    "hint": "Use `l` and `r` pointers to link nodes from start and end.",
                    "solutionCode": "    l, r = 0, len(nodes) - 1\n    while l < r:\n        nodes[l].next = nodes[r]\n        l += 1\n        if l == r: break\n        nodes[r].next = nodes[l]\n        r -= 1"
                },
                {
                    "id": 4,
                    "instruction": "Set the next of the last node to None.",
                    "placeholderCode": "    nodes[l].next = None",
                    "validationRegex": "^\\s+nodes\\[l\\]\\.next\\s*=\\s*None$",
                    "hint": "Terminate the list to avoid cycles.",
                    "solutionCode": "    nodes[l].next = None"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Reverse Second Half",
            "description": "Find middle, reverse second half, and merge.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function reorder_list that takes head.",
                    "placeholderCode": "def reorder_list(head):",
                    "validationRegex": "^def\\s+reorder_list\\(head\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def reorder_list(head):"
                },
                {
                    "id": 2,
                    "instruction": "Find the middle of the list using slow and fast pointers.",
                    "placeholderCode": "    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next",
                    "validationRegex": "^\\s+slow,\\s*fast\\s*=\\s*head,\\s*head\\.next\\s*while\\s+fast\\s+and\\s+fast\\.next:\\s*slow\\s*=\\s*slow\\.next\\s*fast\\s*=\\s*fast\\.next\\.next$",
                    "hint": "Use slow/fast pointers to find the middle.",
                    "solutionCode": "    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next"
                },
                {
                    "id": 3,
                    "instruction": "Reverse the second half of the list.",
                    "placeholderCode": "    second = slow.next\n    prev = slow.next = None\n    while second:\n        tmp = second.next\n        second.next = prev\n        prev = second\n        second = tmp",
                    "validationRegex": "^\\s+second\\s*=\\s*slow\\.next\\s*prev\\s*=\\s*slow\\.next\\s*=\\s*None\\s*while\\s+second:\\s*tmp\\s*=\\s*second\\.next\\s*second\\.next\\s*=\\s*prev\\s*prev\\s*=\\s*second\\s*second\\s*=\\s*tmp$",
                    "hint": "Reverse the list starting from `slow.next`.",
                    "solutionCode": "    second = slow.next\n    prev = slow.next = None\n    while second:\n        tmp = second.next\n        second.next = prev\n        prev = second\n        second = tmp"
                },
                {
                    "id": 4,
                    "instruction": "Merge the two halves.",
                    "placeholderCode": "    first, second = head, prev\n    while second:\n        tmp1, tmp2 = first.next, second.next\n        first.next = second\n        second.next = tmp1\n        first, second = tmp1, tmp2",
                    "validationRegex": "^\\s+first,\\s*second\\s*=\\s*head,\\s*prev\\s*while\\s+second:\\s*tmp1,\\s*tmp2\\s*=\\s*first\\.next,\\s*second\\.next\\s*first\\.next\\s*=\\s*second\\s*second\\.next\\s*=\\s*tmp1\\s*first,\\s*second\\s*=\\s*tmp1,\\s*tmp2$",
                    "hint": "Merge `first` and `second` lists node by node.\\n\\nExample:\\nFirst: 1->2, Second: 4->3.\\nLink 1->4. Link 4->2. Link 2->3.\\nResult: 1->4->2->3.",
                    "solutionCode": "    first, second = head, prev\n    while second:\n        tmp1, tmp2 = first.next, second.next\n        first.next = second\n        second.next = tmp1\n        first, second = tmp1, tmp2"
                }
            ]
        }
    }
}