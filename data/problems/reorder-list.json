{
    "id": "reorder-list",
    "title": "Reorder List",
    "description": "You are given the head of a singly linked-list. The list can be represented as: L0 -> L1 -> ... -> Ln - 1 -> Ln. Reorder the list to be on the following form: L0 -> Ln -> L1 -> Ln - 1 -> L2 -> Ln - 2 -> ... You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "examples": [
        {
            "input": "head = [1,2,3,4]",
            "output": "[1,4,2,3]"
        },
        {
            "input": "head = [1,2,3,4,5]",
            "output": "[1,5,2,4,3]"
        }
    ],
    "constraints": [
        "The number of nodes in the list is in the range [1, 5 * 10^4].",
        "1 <= Node.val <= 1000"
    ],
    "difficulty": "Medium",
    "topic": "Linked List",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "List Conversion",
            "description": "Convert linked list to array, reorder, and rebuild.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'reorder_list' that takes 'head' as an argument.",
                    "placeholderCode": "def reorder_list(head):",
                    "validationRegex": "^def\\s+reorder_list\\(head\\):$",
                    "hint": "Use `def` to define the function named `reorder_list`.",
                    "solutionCode": "def reorder_list(head):"
                },
                {
                    "id": 2,
                    "instruction": "Convert linked list to a list of nodes.",
                    "placeholderCode": "    if not head: return\n    nodes = []\n    curr = head\n    while curr:\n        nodes.append(curr)\n        curr = curr.next",
                    "validationRegex": "^\\s+if\\s+not\\s+head:\\s*return\\s*nodes\\s*=\\s*\\[\\]\\s*curr\\s*=\\s*head\\s*while\\s+curr:\\s*nodes\\.append\\(curr\\)\\s*curr\\s*=\\s*curr\\.next$",
                    "hint": "Traverse the list and store nodes in an array.",
                    "solutionCode": "    if not head: return\n    nodes = []\n    curr = head\n    while curr:\n        nodes.append(curr)\n        curr = curr.next"
                },
                {
                    "id": 3,
                    "instruction": "Use two pointers to reorder the list.",
                    "placeholderCode": "    l, r = 0, len(nodes) - 1\n    while l < r:\n        nodes[l].next = nodes[r]\n        l += 1\n        if l == r: break\n        nodes[r].next = nodes[l]\n        r -= 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(nodes\\)\\s*-\\s*1\\s*while\\s+l\\s*<\\s*r:\\s*nodes\\[l\\]\\.next\\s*=\\s*nodes\\[r\\]\\s*l\\s*\\+=\\s*1\\s*if\\s+l\\s*==\\s*r:\\s*break\\s*nodes\\[r\\]\\.next\\s*=\\s*nodes\\[l\\]\\s*r\\s*-=\\s*1$",
                    "hint": "Use `l` and `r` pointers to link nodes from start and end.",
                    "solutionCode": "    l, r = 0, len(nodes) - 1\n    while l < r:\n        nodes[l].next = nodes[r]\n        l += 1\n        if l == r: break\n        nodes[r].next = nodes[l]\n        r -= 1"
                },
                {
                    "id": 4,
                    "instruction": "Set the next of the last node to None.",
                    "placeholderCode": "    nodes[l].next = None",
                    "validationRegex": "^\\s+nodes\\[l\\]\\.next\\s*=\\s*None$",
                    "hint": "Terminate the list to avoid cycles.",
                    "solutionCode": "    nodes[l].next = None"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Reverse Second Half",
            "description": "Find middle, reverse second half, and merge.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'reorder_list' that takes 'head' as an argument.",
                    "placeholderCode": "def reorder_list(head):",
                    "validationRegex": "^def\\s+reorder_list\\(head\\):$",
                    "hint": "Use `def` to define the function named `reorder_list`.",
                    "solutionCode": "def reorder_list(head):"
                },
                {
                    "id": 2,
                    "instruction": "Check if the list is empty (base case).",
                    "placeholderCode": "    if not head: return",
                    "validationRegex": "^\\s+if\\s+not\\s+head:\\s*return$",
                    "hint": "If the list is empty, there's nothing to reorder.",
                    "solutionCode": "    if not head: return"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the 'slow' pointer.",
                    "placeholderCode": "    slow = head",
                    "validationRegex": "^\\s+slow\\s*=\\s*head$",
                    "hint": "Start the `slow` pointer at the head.",
                    "solutionCode": "    slow = head"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the 'fast' pointer.",
                    "placeholderCode": "    fast = head.next",
                    "validationRegex": "^\\s+fast\\s*=\\s*head\\.next$",
                    "hint": "Start the `fast` pointer one node ahead of `slow`.",
                    "solutionCode": "    fast = head.next"
                },
                {
                    "id": 5,
                    "instruction": "Move the pointers to find the middle of the list.",
                    "placeholderCode": "    while fast and fast.next:",
                    "validationRegex": "^\\s+while\\s+fast\\s+and\\s+fast\\.next:$",
                    "hint": "Loop while `fast` can still move two nodes forward.",
                    "solutionCode": "    while fast and fast.next:"
                },
                {
                    "id": 6,
                    "instruction": "Advance 'slow' by one node.",
                    "placeholderCode": "        slow = slow.next",
                    "validationRegex": "^\\s+slow\\s*=\\s*slow\\.next$",
                    "hint": "Standard middle-finding part.",
                    "solutionCode": "        slow = slow.next"
                },
                {
                    "id": 7,
                    "instruction": "Advance 'fast' by two nodes.",
                    "placeholderCode": "        fast = fast.next.next",
                    "validationRegex": "^\\s+fast\\s*=\\s*fast\\.next\\.next$",
                    "hint": "This makes `slow` reach the middle when `fast` reaches the end.",
                    "solutionCode": "        fast = fast.next.next"
                },
                {
                    "id": 8,
                    "instruction": "Identify the start of the second half.",
                    "placeholderCode": "    second = slow.next",
                    "validationRegex": "^\\s+second\\s*=\\s*slow\\.next$",
                    "hint": "The second half starts right after the `slow` pointer.",
                    "solutionCode": "    second = slow.next"
                },
                {
                    "id": 9,
                    "instruction": "Split the list into two halves.",
                    "placeholderCode": "    prev = slow.next = None",
                    "validationRegex": "^\\s+prev\\s*=\\s*slow\\.next\\s*=\\s*None$",
                    "hint": "Set `slow.next` to `None` to terminate the first half and initialize `prev` for reversal.",
                    "solutionCode": "    prev = slow.next = None"
                },
                {
                    "id": 10,
                    "instruction": "Start reversing the second half.",
                    "placeholderCode": "    while second:",
                    "validationRegex": "^\\s+while\\s+second:$",
                    "hint": "Iterate through the `second` half nodes.",
                    "solutionCode": "    while second:"
                },
                {
                    "id": 11,
                    "instruction": "Save the next node temporarily.",
                    "placeholderCode": "        tmp = second.next",
                    "validationRegex": "^\\s+tmp\\s*=\\s*second\\.next$",
                    "hint": "Keep track of the rest of the list before breaking the link.",
                    "solutionCode": "        tmp = second.next"
                },
                {
                    "id": 12,
                    "instruction": "Reverse the link of the current node.",
                    "placeholderCode": "        second.next = prev",
                    "validationRegex": "^\\s+second\\.next\\s*=\\s*prev$",
                    "hint": "Point the current node's `next` to the previous node.",
                    "solutionCode": "        second.next = prev"
                },
                {
                    "id": 13,
                    "instruction": "Move the 'prev' pointer forward.",
                    "placeholderCode": "        prev = second",
                    "validationRegex": "^\\s+prev\\s*=\\s*second$",
                    "hint": "The current node becomes the `prev` for the next iteration.",
                    "solutionCode": "        prev = second"
                },
                {
                    "id": 14,
                    "instruction": "Move to the next node in the original list.",
                    "placeholderCode": "        second = tmp",
                    "validationRegex": "^\\s+second\\s*=\\s*tmp$",
                    "hint": "Proceed with the saved `next` node.",
                    "solutionCode": "        second = tmp"
                },
                {
                    "id": 15,
                    "instruction": "Initialize pointers to the heads of both halves.",
                    "placeholderCode": "    first, second = head, prev",
                    "validationRegex": "^\\s+first,\\s*second\\s*=\\s*head,\\s*prev$",
                    "hint": "The first half starts at `head`, the reversed second half starts at `prev`.",
                    "solutionCode": "    first, second = head, prev"
                },
                {
                    "id": 16,
                    "instruction": "Merge the two halves interweaving nodes.",
                    "placeholderCode": "    while second:",
                    "validationRegex": "^\\s+while\\s+second:$",
                    "hint": "Continue interweaving as long as nodes remain in the second half.",
                    "solutionCode": "    while second:"
                },
                {
                    "id": 17,
                    "instruction": "Save the next pointers of both lists.",
                    "placeholderCode": "        tmp1, tmp2 = first.next, second.next",
                    "validationRegex": "^\\s+tmp1,\\s*tmp2\\s*=\\s*first\\.next,\\s*second\\.next$",
                    "hint": "Save the original next nodes of both halves.",
                    "solutionCode": "        tmp1, tmp2 = first.next, second.next"
                },
                {
                    "id": 18,
                    "instruction": "Link the first half node to the second half node.",
                    "placeholderCode": "        first.next = second",
                    "validationRegex": "^\\s+first\\.next\\s*=\\s*second$",
                    "hint": "Start the interweaving: L0 -> Ln.",
                    "solutionCode": "        first.next = second"
                },
                {
                    "id": 19,
                    "instruction": "Link the second half node back to the next node of the first half.",
                    "placeholderCode": "        second.next = tmp1",
                    "validationRegex": "^\\s+second\\.next\\s*=\\s*tmp1$",
                    "hint": "Continue the interweaving: Ln -> L1.",
                    "solutionCode": "        second.next = tmp1"
                },
                {
                    "id": 20,
                    "instruction": "Move the pointers forward to the next nodes to be processed.",
                    "placeholderCode": "        first, second = tmp1, tmp2",
                    "validationRegex": "^\\s+first,\\s*second\\s*=\\s*tmp1,\\s*tmp2$",
                    "hint": "The next nodes to merge are the ones we saved in `tmp1` and `tmp2`.",
                    "solutionCode": "        first, second = tmp1, tmp2"
                }
            ]
        }
    }
}