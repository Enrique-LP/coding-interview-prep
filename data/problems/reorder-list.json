{
    "id": "reorder-list",
    "title": "Reorder List",
    "description": "You are given the head of a singly linked-list. The list can be represented as: L0 -> L1 -> ... -> Ln - 1 -> Ln. Reorder the list to be on the following form: L0 -> Ln -> L1 -> Ln - 1 -> L2 -> Ln - 2 -> ... You may not modify the values in the list's nodes. Only nodes themselves may be changed.",
    "examples": [
        {
            "input": "head = [1,2,3,4]",
            "output": "[1,4,2,3]"
        },
        {
            "input": "head = [1,2,3,4,5]",
            "output": "[1,5,2,4,3]"
        }
    ],
    "constraints": [
        "The number of nodes in the list is in the range [1, 5 * 10^4].",
        "1 <= Node.val <= 1000"
    ],
    "difficulty": "Medium",
    "topic": "Linked List",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "List Conversion",
            "description": "Convert linked list to array, reorder, and rebuild.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'reorder_list' that takes 'head' as an argument.",
                    "placeholderCode": "def reorder_list(head):",
                    "validationRegex": "^def\\s+reorder_list\\(head\\):$",
                    "hint": "Use `def` to define the function named `reorder_list`.",
                    "solutionCode": "def reorder_list(head):"
                },
                {
                    "id": 2,
                    "instruction": "Convert linked list to a list of nodes.",
                    "placeholderCode": "    if not head: return\n    nodes = []\n    curr = head\n    while curr:\n        nodes.append(curr)\n        curr = curr.next",
                    "validationRegex": "^\\s+if\\s+not\\s+head:\\s*return\\s*nodes\\s*=\\s*\\[\\]\\s*curr\\s*=\\s*head\\s*while\\s+curr:\\s*nodes\\.append\\(curr\\)\\s*curr\\s*=\\s*curr\\.next$",
                    "hint": "Traverse the list and store nodes in an array.",
                    "solutionCode": "    if not head: return\n    nodes = []\n    curr = head\n    while curr:\n        nodes.append(curr)\n        curr = curr.next"
                },
                {
                    "id": 3,
                    "instruction": "Use two pointers to reorder the list.",
                    "placeholderCode": "    l, r = 0, len(nodes) - 1\n    while l < r:\n        nodes[l].next = nodes[r]\n        l += 1\n        if l == r: break\n        nodes[r].next = nodes[l]\n        r -= 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(nodes\\)\\s*-\\s*1\\s*while\\s+l\\s*<\\s*r:\\s*nodes\\[l\\]\\.next\\s*=\\s*nodes\\[r\\]\\s*l\\s*\\+=\\s*1\\s*if\\s+l\\s*==\\s*r:\\s*break\\s*nodes\\[r\\]\\.next\\s*=\\s*nodes\\[l\\]\\s*r\\s*-=\\s*1$",
                    "hint": "Use `l` and `r` pointers to link nodes from start and end.",
                    "solutionCode": "    l, r = 0, len(nodes) - 1\n    while l < r:\n        nodes[l].next = nodes[r]\n        l += 1\n        if l == r: break\n        nodes[r].next = nodes[l]\n        r -= 1"
                },
                {
                    "id": 4,
                    "instruction": "Set the next of the last node to None.",
                    "placeholderCode": "    nodes[l].next = None",
                    "validationRegex": "^\\s+nodes\\[l\\]\\.next\\s*=\\s*None$",
                    "hint": "Terminate the list to avoid cycles.",
                    "solutionCode": "    nodes[l].next = None"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Reverse Second Half",
            "description": "Find middle, reverse second half, and merge.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'reorder_list' that takes 'head' as an argument.",
                    "placeholderCode": "def reorder_list(head):",
                    "validationRegex": "^def\\s+reorder_list\\(head\\):$",
                    "hint": "Use `def` to define the function named `reorder_list`.",
                    "solutionCode": "def reorder_list(head):"
                },
                {
                    "id": 2,
                    "instruction": "Check if the list is empty (base case).",
                    "placeholderCode": "    if not head: return",
                    "validationRegex": "^\\s+if\\s+not\\s+head:\\s*return$",
                    "hint": "If the list is empty, there's nothing to reorder.",
                    "solutionCode": "    if not head: return"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the 'slow' pointer.",
                    "placeholderCode": "    slow = head",
                    "validationRegex": "^\\s+slow\\s*=\\s*head$",
                    "hint": "Start the `slow` pointer at the head.",
                    "solutionCode": "    slow = head"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the 'fast' pointer.",
                    "placeholderCode": "    fast = head.next",
                    "validationRegex": "^\\s+fast\\s*=\\s*head\\.next$",
                    "hint": "Start the `fast` pointer one node ahead of `slow`.",
                    "solutionCode": "    fast = head.next"
                },
                {
                    "id": 5,
                    "instruction": "Move the pointers until 'fast' reaches the end.",
                    "placeholderCode": "    while fast and fast.next:",
                    "validationRegex": "^\\s+while\\s+fast\\s+and\\s+fast\\.next:$",
                    "hint": "Loop while `fast` can still move two nodes forward.",
                    "solutionCode": "    while fast and fast.next:"
                },
                {
                    "id": 6,
                    "instruction": "Advance 'slow' by one node.",
                    "placeholderCode": "        slow = slow.next",
                    "validationRegex": "^\\s+slow\\s*=\\s*slow\\.next$",
                    "hint": "Slow moves 1 step.",
                    "solutionCode": "        slow = slow.next"
                },
                {
                    "id": 7,
                    "instruction": "Advance 'fast' by two nodes.",
                    "placeholderCode": "        fast = fast.next.next",
                    "validationRegex": "^\\s+fast\\s*=\\s*fast\\.next\\.next$",
                    "hint": "Fast moves 2 steps.",
                    "solutionCode": "        fast = fast.next.next"
                },
                {
                    "id": 8,
                    "instruction": "Identify the head of the second half.",
                    "placeholderCode": "    second = slow.next",
                    "validationRegex": "^\\s+second\\s*=\\s*slow\\.next$",
                    "hint": "The second half starts after the middle node.",
                    "solutionCode": "    second = slow.next"
                },
                {
                    "id": 9,
                    "instruction": "Split the list into two halves and initialize 'prev'.",
                    "placeholderCode": "    prev = slow.next = None",
                    "validationRegex": "^\\s+prev\\s*=\\s*slow\\.next\\s*=\\s*None$",
                    "hint": "Break the connection to the second half and start `prev` as `None`.",
                    "solutionCode": "    prev = slow.next = None"
                },
                {
                    "id": 10,
                    "instruction": "Loop through the second half to reverse it.",
                    "placeholderCode": "    while second:",
                    "validationRegex": "^\\s+while\\s+second:$",
                    "hint": "Standard list reversal loop.",
                    "solutionCode": "    while second:"
                },
                {
                    "id": 11,
                    "instruction": "Save the next node temporarily.",
                    "placeholderCode": "        tmp = second.next",
                    "validationRegex": "^\\s+tmp\\s*=\\s*second\\.next$",
                    "hint": "Store the rest of the list before you flip the arrow.",
                    "solutionCode": "        tmp = second.next"
                },
                {
                    "id": 12,
                    "instruction": "Reverse the current node's pointer.",
                    "placeholderCode": "        second.next = prev",
                    "validationRegex": "^\\s+second\\.next\\s*=\\s*prev$",
                    "hint": "Point the current node to its previous node.",
                    "solutionCode": "        second.next = prev"
                },
                {
                    "id": 13,
                    "instruction": "Update 'prev' to be the current node.",
                    "placeholderCode": "        prev = second",
                    "validationRegex": "^\\s+prev\\s*=\\s*second$",
                    "hint": "Shift the `prev` pointer one step forward.",
                    "solutionCode": "        prev = second"
                },
                {
                    "id": 14,
                    "instruction": "Advance to the next node in the original sequence.",
                    "placeholderCode": "        second = tmp",
                    "validationRegex": "^\\s+second\\s*=\\s*tmp$",
                    "hint": "Shift the `second` pointer using your saved reference.",
                    "solutionCode": "        second = tmp"
                },
                {
                    "id": 15,
                    "instruction": "Set pointers to the beginning of both halves.",
                    "placeholderCode": "    first, second = head, prev",
                    "validationRegex": "^\\s+first,\\s*second\\s*=\\s*head,\\s*prev$",
                    "hint": "Prepare for merging.",
                    "solutionCode": "    first, second = head, prev"
                },
                {
                    "id": 16,
                    "instruction": "Start merging until the second half is empty.",
                    "placeholderCode": "    while second:",
                    "validationRegex": "^\\s+while\\s+second:$",
                    "hint": "The second half will be shorter or equal to the first.",
                    "solutionCode": "    while second:"
                },
                {
                    "id": 17,
                    "instruction": "Store the original next pointers of both nodes.",
                    "placeholderCode": "        tmp1, tmp2 = first.next, second.next",
                    "validationRegex": "^\\s+tmp1,\\s*tmp2\\s*=\\s*first\\.next,\\s*second\\.next$",
                    "hint": "Save the 'future' connections.",
                    "solutionCode": "        tmp1, tmp2 = first.next, second.next"
                },
                {
                    "id": 18,
                    "instruction": "Link the first half node to the second half node.",
                    "placeholderCode": "        first.next = second",
                    "validationRegex": "^\\s+first\\.next\\s*=\\s*second$",
                    "hint": "This is L0 -> Ln.",
                    "solutionCode": "        first.next = second"
                },
                {
                    "id": 19,
                    "instruction": "Link the second half node back to the original next node.",
                    "placeholderCode": "        second.next = tmp1",
                    "validationRegex": "^\\s+second\\.next\\s*=\\s*tmp1$",
                    "hint": "This is Ln -> L1.",
                    "solutionCode": "        second.next = tmp1"
                },
                {
                    "id": 20,
                    "instruction": "Move both pointers forward to continue the merge.",
                    "placeholderCode": "        first, second = tmp1, tmp2",
                    "validationRegex": "^\\s+first,\\s*second\\s*=\\s*tmp1,\\s*tmp2$",
                    "hint": "Shift pointers to the next nodes to be processed.",
                    "solutionCode": "        first, second = tmp1, tmp2"
                }
            ]
        }
    }
}