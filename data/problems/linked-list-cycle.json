{
    "id": "linked-list-cycle",
    "title": "Linked List Cycle",
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, `pos` is used to denote the index of the node that tail's next pointer is connected to. Note that `pos` is not passed as a parameter.",
    "examples": [
        {
            "input": "head = [3,2,0,-4], pos = 1",
            "output": "true",
            "explanation": "There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
        },
        {
            "input": "head = [1,2], pos = 0",
            "output": "true",
            "explanation": "There is a cycle in the linked list, where the tail connects to the 0th node."
        },
        {
            "input": "head = [1], pos = -1",
            "output": "false",
            "explanation": "There is no cycle in the linked list."
        }
    ],
    "constraints": [
        "The number of the nodes in the list is in the range [0, 10^4].",
        "-10^5 <= Node.val <= 10^5",
        "pos is -1 or a valid index in the linked-list."
    ],
    "difficulty": "Easy",
    "topic": "Linked List",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "HashSet",
            "description": "Store visited nodes in a set to detect duplicates.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'has_cycle' that takes 'head' as an argument.",
                    "placeholderCode": "def has_cycle(head):",
                    "validationRegex": "^def\\s+has_cycle\\(head\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def has_cycle(head):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize an empty set to keep track of seen nodes.",
                    "placeholderCode": "    seen = set()",
                    "validationRegex": "^\\s+seen\\s*=\\s*set\\(\\)$",
                    "hint": "A set provides O(1) average time complexity for lookups.",
                    "solutionCode": "    seen = set()"
                },
                {
                    "id": 3,
                    "instruction": "Initialize a pointer 'curr' at the head of the list.",
                    "placeholderCode": "    curr = head",
                    "validationRegex": "^\\s+curr\\s*=\\s*head$",
                    "hint": "The pointer will help us traverse the list node by node.",
                    "solutionCode": "    curr = head"
                },
                {
                    "id": 4,
                    "instruction": "Loop through the list while 'curr' is not None.",
                    "placeholderCode": "    while curr:",
                    "validationRegex": "^\\s+while\\s+curr:$",
                    "hint": "If the list has no cycle, we will eventually hit None.",
                    "solutionCode": "    while curr:"
                },
                {
                    "id": 5,
                    "instruction": "Check if the current node has been visited before.",
                    "placeholderCode": "        if curr in seen:",
                    "validationRegex": "^\\s+if\\s+curr\\s+in\\s+seen:$",
                    "hint": "If it's in the set, we've found a cycle!",
                    "solutionCode": "        if curr in seen:"
                },
                {
                    "id": 6,
                    "instruction": "Return True if a cycle is detected.",
                    "placeholderCode": "            return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "Seeing the same node twice means the tail connects back to it.",
                    "solutionCode": "            return True"
                },
                {
                    "id": 7,
                    "instruction": "Add the current node to the 'seen' set.",
                    "placeholderCode": "        seen.add(curr)",
                    "validationRegex": "^\\s+seen\\.add\\(curr\\)$",
                    "hint": "Mark the node as visited before moving on.",
                    "solutionCode": "        seen.add(curr)"
                },
                {
                    "id": 8,
                    "instruction": "Move the 'curr' pointer to the next node.",
                    "placeholderCode": "        curr = curr.next",
                    "validationRegex": "^\\s+curr\\s*=\\s*curr\\.next$",
                    "hint": "Advance the traversal.",
                    "solutionCode": "        curr = curr.next"
                },
                {
                    "id": 9,
                    "instruction": "Return False if the loop finishes without finding a cycle.",
                    "placeholderCode": "    return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "If we reach None, it means the list is linear.",
                    "solutionCode": "    return False"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Floyd's Cycle-Finding Algorithm (Tortoise and Hare)",
            "description": "Use two pointers moving at different speeds to detect cycles with O(1) space.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'has_cycle' that takes 'head' as an argument.",
                    "placeholderCode": "def has_cycle(head):",
                    "validationRegex": "^def\\s+has_cycle\\(head\\):$",
                    "hint": "Start by defining the function.",
                    "solutionCode": "def has_cycle(head):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize both 'slow' and 'fast' pointers at the head.",
                    "placeholderCode": "    slow, fast = head, head",
                    "validationRegex": "^\\s+slow,\\s*fast\\s*=\\s*head,\\s*head$",
                    "hint": "Both pointers start at the same position.",
                    "solutionCode": "    slow, fast = head, head"
                },
                {
                    "id": 3,
                    "instruction": "Start a loop that continues while 'fast' and his next node exist.",
                    "placeholderCode": "    while fast and fast.next:",
                    "validationRegex": "^\\s+while\\s+fast\\s+and\\s+fast\\.next:$",
                    "hint": "If `fast` hits the end, there is no cycle.",
                    "solutionCode": "    while fast and fast.next:"
                },
                {
                    "id": 4,
                    "instruction": "Move the 'slow' pointer forward by one node.",
                    "placeholderCode": "        slow = slow.next",
                    "validationRegex": "^\\s+slow\\s*=\\s*slow\\.next$",
                    "hint": "The tortoise advances 1 step.",
                    "solutionCode": "        slow = slow.next"
                },
                {
                    "id": 5,
                    "instruction": "Move the 'fast' pointer forward by two nodes.",
                    "placeholderCode": "        fast = fast.next.next",
                    "validationRegex": "^\\s+fast\\s*=\\s*fast\\.next\\.next$",
                    "hint": "The hare advances 2 steps.",
                    "solutionCode": "        fast = fast.next.next"
                },
                {
                    "id": 6,
                    "instruction": "Check if the two pointers have met at the same node.",
                    "placeholderCode": "        if slow == fast:",
                    "validationRegex": "^\\s+if\\s+slow\\s*==\\s*fast:$",
                    "hint": "If they are at the same node, a cycle must exist.",
                    "solutionCode": "        if slow == fast:"
                },
                {
                    "id": 7,
                    "instruction": "Return True if a meeting is detected.",
                    "placeholderCode": "            return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "The hare has 'lapped' the tortoise inside the cycle.",
                    "solutionCode": "            return True"
                },
                {
                    "id": 8,
                    "instruction": "Return False if the loop completes (end of list reached).",
                    "placeholderCode": "    return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "If the hare reaches the end, there's no way back.",
                    "solutionCode": "    return False"
                }
            ]
        }
    }
}