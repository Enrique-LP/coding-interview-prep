{
    "id": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "examples": [
        {
            "input": "nums = [10,9,2,5,3,7,101,18]",
            "output": "4",
            "explanation": "The longest increasing subsequence is [2,3,7,101], therefore the length is 4."
        },
        {
            "input": "nums = [0,1,0,3,2,3]",
            "output": "4"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 2500",
        "-10^4 <= nums[i] <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Recursive",
            "description": "Recursively check include/exclude.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function length_of_lis that takes nums.",
                    "placeholderCode": "def length_of_lis(nums):",
                    "validationRegex": "^def\\s+length_of_lis\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def length_of_lis(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(i, prev_val):\n        if i == len(nums): return 0\n        if (i, prev_val) in memo: return memo[(i, prev_val)]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i,\\s*prev_val\\):\\s*if\\s+i\\s*==\\s*len\\(nums\\):\\s*return\\s+0\\s*if\\s*\\(i,\\s*prev_val\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(i,\\s*prev_val\\)\\]$",
                    "hint": "Recursive function `dfs(i, prev_val)` returns LIS length starting from `i` with previous value `prev_val`. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(i, prev_val):\n        if i == len(nums): return 0\n        if (i, prev_val) in memo: return memo[(i, prev_val)]"
                },
                {
                    "id": 3,
                    "instruction": "Exclude current element.",
                    "placeholderCode": "        res = dfs(i + 1, prev_val)",
                    "validationRegex": "^\\s+res\\s*=\\s*dfs\\(i\\s*\\+\\s*1,\\s*prev_val\\)$",
                    "hint": "Option 1: Skip current element.",
                    "solutionCode": "        res = dfs(i + 1, prev_val)"
                },
                {
                    "id": 4,
                    "instruction": "Include current element if valid.",
                    "placeholderCode": "        if nums[i] > prev_val:\n            res = max(res, 1 + dfs(i + 1, nums[i]))",
                    "validationRegex": "^\\s+if\\s+nums\\[i\\]\\s*>\\s+prev_val:\\s*res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(i\\s*\\+\\s*1,\\s*nums\\[i\\]\\)\\)$",
                    "hint": "Option 2: Include current element if it's greater than `prev_val`. Take max of both options.\\n\\nExample:\\nNums=[1, 2].\\nDFS(0, -inf):\\n  Skip 1 -> DFS(1, -inf) -> Skip 2 -> 0. Include 2 -> 1.\\n  Include 1 -> 1 + DFS(1, 1) -> Include 2 -> 1+1=2.\\nMax is 2.",
                    "solutionCode": "        if nums[i] > prev_val:\n            res = max(res, 1 + dfs(i + 1, nums[i]))"
                },
                {
                    "id": 5,
                    "instruction": "Memoize and return.",
                    "placeholderCode": "        memo[(i, prev_val)] = res\n        return res",
                    "validationRegex": "^\\s+memo\\[\\(i,\\s*prev_val\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in memo and return.",
                    "solutionCode": "        memo[(i, prev_val)] = res\n        return res"
                },
                {
                    "id": 6,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0, float('-inf'))",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*float\\('-inf'\\)\\)$",
                    "hint": "Start recursion with index 0 and negative infinity as previous value.",
                    "solutionCode": "    return dfs(0, float('-inf'))"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "DP (Iterative)",
            "description": "O(n^2) DP solution.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function length_of_lis that takes nums.",
                    "placeholderCode": "def length_of_lis(nums):",
                    "validationRegex": "^def\\s+length_of_lis\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def length_of_lis(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize DP array with 1s.",
                    "placeholderCode": "    dp = [1] * len(nums)",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[1\\]\\s*\\*\\s*len\\(nums\\)$",
                    "hint": "Initialize DP array of size n with 1s (each element is an increasing subsequence of length 1).",
                    "solutionCode": "    dp = [1] * len(nums)"
                },
                {
                    "id": 3,
                    "instruction": "Iterate backwards.",
                    "placeholderCode": "    for i in range(len(nums) - 1, -1, -1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] < nums[j]:\n                dp[i] = max(dp[i], 1 + dp[j])",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):\\s*for\\s+j\\s+in\\s+range\\(i\\s*\\+\\s*1,\\s*len\\(nums\\)\\):\\s*if\\s+nums\\[i\\]\\s*<\\s+nums\\[j\\]:\\s*dp\\[i\\]\\s*=\\s*max\\(dp\\[i\\],\\s*1\\s*\\+\\s*dp\\[j\\]\\)$",
                    "hint": "Iterate backwards. For each element `i`, check all subsequent elements `j`. If `nums[i] < nums[j]`, we can extend the subsequence ending at `j`.\\n\\nExample:\\nNums=[1, 2, 4, 3]. DP=[1, 1, 1, 1].\\ni=2 (4): No j > 2 with val > 4.\\ni=1 (2): j=2 (4>2) -> DP[1]=max(1, 1+1)=2. j=3 (3>2) -> DP[1]=max(2, 1+1)=2.\\ni=0 (1): j=1 (2>1) -> DP[0]=max(1, 1+2)=3.",
                    "solutionCode": "    for i in range(len(nums) - 1, -1, -1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] < nums[j]:\n                dp[i] = max(dp[i], 1 + dp[j])"
                },
                {
                    "id": 4,
                    "instruction": "Return max of DP array.",
                    "placeholderCode": "    return max(dp)",
                    "validationRegex": "^\\s+return\\s+max\\(dp\\)$",
                    "hint": "The answer is the maximum value in the DP array.",
                    "solutionCode": "    return max(dp)"
                }
            ]
        }
    }
}