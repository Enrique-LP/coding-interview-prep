{
    "id": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "examples": [
        {
            "input": "nums = [10,9,2,5,3,7,101,18]",
            "output": "4",
            "explanation": "The longest increasing subsequence is [2,3,7,101], therefore the length is 4."
        },
        {
            "input": "nums = [0,1,0,3,2,3]",
            "output": "4"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 2500",
        "-10^4 <= nums[i] <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively check every possible subsequence by either including or excluding each element.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function length_of_lis that takes nums.",
                    "placeholderCode": "def length_of_lis(nums):",
                    "validationRegex": "^def\\s+length_of_lis\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def length_of_lis(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(i, prev_val):\n        if i == len(nums): return 0\n        if (i, prev_val) in memo: return memo[(i, prev_val)]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i,\\s*prev_val\\):\\s*if\\s+i\\s*==\\s*len\\(nums\\):\\s*return\\s+0\\s*if\\s*\\(i,\\s*prev_val\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(i,\\s*prev_val\\)\\]$",
                    "hint": "Recursive function `dfs(i, prev_val)` returns LIS length starting from `i` with previous value `prev_val`. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(i, prev_val):\n        if i == len(nums): return 0\n        if (i, prev_val) in memo: return memo[(i, prev_val)]"
                },
                {
                    "id": 3,
                    "instruction": "Exclude current element.",
                    "placeholderCode": "        res = dfs(i + 1, prev_val)",
                    "validationRegex": "^\\s+res\\s*=\\s*dfs\\(i\\s*\\+\\s*1,\\s*prev_val\\)$",
                    "hint": "Option 1: Skip current element.",
                    "solutionCode": "        res = dfs(i + 1, prev_val)"
                },
                {
                    "id": 4,
                    "instruction": "Include current element if valid.",
                    "placeholderCode": "        if nums[i] > prev_val:\n            res = max(res, 1 + dfs(i + 1, nums[i]))",
                    "validationRegex": "^\\s+if\\s+nums\\[i\\]\\s*>\\s+prev_val:\\s*res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(i\\s*\\+\\s*1,\\s*nums\\[i\\]\\)\\)$",
                    "hint": "Option 2: Include current element if it's greater than `prev_val`. Take max of both options.",
                    "solutionCode": "        if nums[i] > prev_val:\n            res = max(res, 1 + dfs(i + 1, nums[i]))"
                },
                {
                    "id": 5,
                    "instruction": "Memoize and return.",
                    "placeholderCode": "        memo[(i, prev_val)] = res\n        return res",
                    "validationRegex": "^\\s+memo\\[\\(i,\\s*prev_val\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in memo and return.",
                    "solutionCode": "        memo[(i, prev_val)] = res\n        return res"
                },
                {
                    "id": 6,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0, float('-inf'))",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*float\\('-inf'\\)\\)$",
                    "hint": "Start recursion with index 0 and negative infinity as previous value.",
                    "solutionCode": "    return dfs(0, float('-inf'))"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iterative O(n^2) dynamic programming solution that builds the solution for each index based on subsequent elements.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function length_of_lis that takes nums.",
                    "placeholderCode": "def length_of_lis(nums):",
                    "validationRegex": "^def\\s+length_of_lis\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def length_of_lis(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP table 'dp' with 1s, as each element is a subsequence of length 1.",
                    "placeholderCode": "    dp = [1] * len(nums)",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[1\\]\\s*\\*\\s*len\\(nums\\)$",
                    "hint": "Initialize DP array of size n with 1s.",
                    "solutionCode": "    dp = [1] * len(nums)"
                },
                {
                    "id": 3,
                    "instruction": "Initiate a loop to iterate backwards through the array 'nums'.",
                    "placeholderCode": "    for i in range(len(nums) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "Starting from the end allows us to build the LIS solution bottom-up.",
                    "solutionCode": "    for i in range(len(nums) - 1, -1, -1):"
                },
                {
                    "id": 4,
                    "instruction": "For the current element at index 'i', initiate another loop to check all subsequent elements 'j'.",
                    "placeholderCode": "        for j in range(i + 1, len(nums)):",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(i\\s*\\+\\s*1,\\s*len\\(nums\\)\\):$",
                    "hint": "We are looking for any element 'j' that can follow 'i' in an increasing subsequence.",
                    "solutionCode": "        for j in range(i + 1, len(nums)):"
                },
                {
                    "id": 5,
                    "instruction": "Check if the element at index 'i' is smaller than the element at index 'j'.",
                    "placeholderCode": "            if nums[i] < nums[j]:",
                    "validationRegex": "^\\s+if\\s+nums\\[i\\]\\s*<\\s+nums\\[j\\]:$",
                    "hint": "Only if nums[i] < nums[j] can we extend the increasing subsequence.",
                    "solutionCode": "            if nums[i] < nums[j]:"
                },
                {
                    "id": 6,
                    "instruction": "Calculate the potential new LIS length starting at index 'i' using the result from index 'j'.",
                    "placeholderCode": "                potential_len = 1 + dp[j]",
                    "validationRegex": "^\\s+potential_len\\s*=\\s*1\\s*\\+\\s*dp\\[j\\]$",
                    "hint": "Add 1 (for the current element) to the LIS length found starting at 'j'.",
                    "solutionCode": "                potential_len = 1 + dp[j]"
                },
                {
                    "id": 7,
                    "instruction": "Update 'dp[i]' to the maximum value between its current value and the new potential length.",
                    "placeholderCode": "                dp[i] = max(dp[i], potential_len)",
                    "validationRegex": "^\\s+dp\\[i\\]\\s*=\\s*max\\(dp\\[i\\],\\s*potential_len\\)$",
                    "hint": "We want to store the longest increasing subsequence found so far for index 'i'.",
                    "solutionCode": "                dp[i] = max(dp[i], potential_len)"
                },
                {
                    "id": 8,
                    "instruction": "Return the maximum value in the 'dp' array, which represents the longest increasing subsequence overall.",
                    "placeholderCode": "    return max(dp)",
                    "validationRegex": "^\\s+return\\s+max\\(dp\\)$",
                    "hint": "The overall LIS can start at any position in the array.",
                    "solutionCode": "    return max(dp)"
                }
            ]
        }
    }
}