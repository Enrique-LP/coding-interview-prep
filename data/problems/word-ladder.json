{
    "id": "word-ladder",
    "title": "Word Ladder",
    "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Every adjacent pair of words differs by a single letter. Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWord. Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    "examples": [
        {
            "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
            "output": "5",
            "explanation": "One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", which is 5 words long."
        },
        {
            "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
            "output": "0"
        }
    ],
    "constraints": [
        "1 <= beginWord.length <= 10",
        "endWord.length == beginWord.length",
        "1 <= wordList.length <= 5000",
        "wordList[i].length == beginWord.length",
        "beginWord, endWord, and wordList[i] consist of lowercase English letters.",
        "beginWord != endWord",
        "All the words in wordList are unique."
    ],
    "difficulty": "Hard",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "BFS to find shortest path.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define ladderLength.",
                    "placeholderCode": "def ladderLength(beginWord, endWord, wordList):",
                    "validationRegex": "^def\\s+ladderLength\\(beginWord,\\s*endWord,\\s*wordList\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def ladderLength(beginWord, endWord, wordList):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize queue and set.",
                    "placeholderCode": "    if endWord not in wordList:\n        return 0\n    nei = collections.defaultdict(list)\n    wordList.append(beginWord)\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            nei[pattern].append(word)\n    visit = set([beginWord])\n    q = collections.deque([beginWord])\n    res = 1",
                    "validationRegex": "^\\s+if\\s+endWord\\s+not\\s+in\\s+wordList:\\s*return\\s*0\\s*nei\\s*=\\s*collections\\.defaultdict\\(list\\)\\s*wordList\\.append\\(beginWord\\)\\s*for\\s+word\\s+in\\s+wordList:\\s*for\\s+j\\s+in\\s+range\\(len\\(word\\)\\):\\s*pattern\\s*=\\s*word\\[:j\\]\\s*\\+\\s*\"\\*\"\\s*\\+\\s*word\\[j\\s*\\+\\s*1\\s*:\\]\\s*nei\\[pattern\\]\\.append\\(word\\)\\s*visit\\s*=\\s*set\\(\\[beginWord\\]\\)\\s*q\\s*=\\s*collections\\.deque\\(\\[beginWord\\]\\)\\s*res\\s*=\\s*1$",
                    "hint": "Preprocess words into patterns to quickly find neighbors. Initialize BFS queue with beginWord.\\n\\nExample:\\nWord 'hot' generates patterns: '*ot', 'h*t', 'ho*'.\\nMap: {'*ot': ['hot', 'dot', 'lot'], ...}.\\nThis allows O(1) lookup of neighbors.",
                    "solutionCode": "    if endWord not in wordList:\n        return 0\n    nei = collections.defaultdict(list)\n    wordList.append(beginWord)\n    for word in wordList:\n        for j in range(len(word)):\n            pattern = word[:j] + \"*\" + word[j + 1 :]\n            nei[pattern].append(word)\n    visit = set([beginWord])\n    q = collections.deque([beginWord])\n    res = 1"
                },
                {
                    "id": 3,
                    "instruction": "BFS loop.",
                    "placeholderCode": "    while q:\n        for i in range(len(q)):\n            word = q.popleft()\n            if word == endWord:\n                return res\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in nei[pattern]:\n                    if neighbor not in visit:\n                        visit.add(neighbor)\n                        q.append(neighbor)\n        res += 1",
                    "validationRegex": "^\\s+while\\s+q:\\s*for\\s+i\\s+in\\s+range\\(len\\(q\\)\\):\\s*word\\s*=\\s*q\\.popleft\\(\\)\\s*if\\s+word\\s*==\\s*endWord:\\s*return\\s+res\\s*for\\s+j\\s+in\\s+range\\(len\\(word\\)\\):\\s*pattern\\s*=\\s*word\\[:j\\]\\s*\\+\\s*\"\\*\"\\s*\\+\\s*word\\[j\\s*\\+\\s*1\\s*:\\]\\s*for\\s+neighbor\\s+in\\s+nei\\[pattern\\]:\\s*if\\s+neighbor\\s+not\\s+in\\s+visit:\\s*visit\\.add\\(neighbor\\)\\s*q\\.append\\(neighbor\\)\\s*res\\s*\\+=\\s*1$",
                    "hint": "Standard BFS. For each word, generate patterns, find neighbors, and add unvisited ones to queue. Increment result level by level.",
                    "solutionCode": "    while q:\n        for i in range(len(q)):\n            word = q.popleft()\n            if word == endWord:\n                return res\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                for neighbor in nei[pattern]:\n                    if neighbor not in visit:\n                        visit.add(neighbor)\n                        q.append(neighbor)\n        res += 1"
                },
                {
                    "id": 4,
                    "instruction": "Return 0.",
                    "placeholderCode": "    return 0",
                    "validationRegex": "^\\s+return\\s+0$",
                    "hint": "If queue empty and endWord not found, return 0.",
                    "solutionCode": "    return 0"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define ladderLength.",
                    "placeholderCode": "def ladderLength(beginWord, endWord, wordList):",
                    "validationRegex": "^def\\s+ladderLength\\(beginWord,\\s*endWord,\\s*wordList\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def ladderLength(beginWord, endWord, wordList):"
                },
                {
                    "id": 2,
                    "instruction": "Check if endWord is even in the list.",
                    "placeholderCode": "    if endWord not in wordList:",
                    "validationRegex": "^\\s+if\\s+endWord\\s+not\\s+in\\s+wordList:$",
                    "hint": "If the target word is missing, transformation is impossible.",
                    "solutionCode": "    if endWord not in wordList:"
                },
                {
                    "id": 3,
                    "instruction": "Return 0 if the word is not found.",
                    "placeholderCode": "        return 0",
                    "validationRegex": "^\\s+return\\s+0$",
                    "hint": "No path exists.",
                    "solutionCode": "        return 0"
                },
                {
                    "id": 4,
                    "instruction": "Initialize neighbor dictionary.",
                    "placeholderCode": "    nei = collections.defaultdict(list)",
                    "validationRegex": "^\\s+nei\\s*=\\s*collections\\.defaultdict\\(list\\)$",
                    "hint": "This will map word patterns (like 'h*t') to lists of matching words.",
                    "solutionCode": "    nei = collections.defaultdict(list)"
                },
                {
                    "id": 5,
                    "instruction": "Ensure beginWord is included for pattern generation.",
                    "placeholderCode": "    wordList.append(beginWord)",
                    "validationRegex": "^\\s+wordList\\.append\\(beginWord\\)$",
                    "hint": "We need to generate patterns for the starting word too.",
                    "solutionCode": "    wordList.append(beginWord)"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through every word in wordList.",
                    "placeholderCode": "    for word in wordList:",
                    "validationRegex": "^\\s+for\\s+word\\s+in\\s+wordList:$",
                    "hint": "O(N) loop where N is the number of words.",
                    "solutionCode": "    for word in wordList:"
                },
                {
                    "id": 7,
                    "instruction": "Iterate through each character position 'j' in the word.",
                    "placeholderCode": "        for j in range(len(word)):",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(len\\(word\\)\\):$",
                    "hint": "Words are short (length L), so this loop is O(L).",
                    "solutionCode": "        for j in range(len(word)):"
                },
                {
                    "id": 8,
                    "instruction": "Generate a pattern by replacing the character at 'j' with '*'.",
                    "placeholderCode": "            pattern = word[:j] + \"*\" + word[j + 1 :]",
                    "validationRegex": "^\\s+pattern\\s*=\\s*word\\[:j\\]\\s*\\+\\s*\"\\*\"\\s*\\+\\s*word\\[j\\s*\\+\\s*1\\s*:\\]$",
                    "hint": "Example: 'hot' position 0 becomes '*ot'.",
                    "solutionCode": "            pattern = word[:j] + \"*\" + word[j + 1 :]"
                },
                {
                    "id": 9,
                    "instruction": "Add the current word to the corresponding pattern in 'nei'.",
                    "placeholderCode": "            nei[pattern].append(word)",
                    "validationRegex": "^\\s+nei\\[pattern\\]\\.append\\(word\\)$",
                    "hint": "Grouping words by shared patterns efficiently finds neighbors differing by one letter.",
                    "solutionCode": "            nei[pattern].append(word)"
                },
                {
                    "id": 10,
                    "instruction": "Initialize visited set with beginWord.",
                    "placeholderCode": "    visit = set([beginWord])",
                    "validationRegex": "^\\s+visit\\s*=\\s*set\\(\\[beginWord\\]\\)$",
                    "hint": "Track visited words to avoid infinite loops and cycles.",
                    "solutionCode": "    visit = set([beginWord])"
                },
                {
                    "id": 11,
                    "instruction": "Initialize BFS queue with beginWord.",
                    "placeholderCode": "    q = collections.deque([beginWord])",
                    "validationRegex": "^\\s+q\\s*=\\s*collections\\.deque\\(\\[beginWord\\]\\)$",
                    "hint": "Queue is essential for Breadth-First Search.",
                    "solutionCode": "    q = collections.deque([beginWord])"
                },
                {
                    "id": 12,
                    "instruction": "Start transformation length at 1.",
                    "placeholderCode": "    res = 1",
                    "validationRegex": "^\\s+res\\s*=\\s*1$",
                    "hint": "The sequence starts with beginWord itself.",
                    "solutionCode": "    res = 1"
                },
                {
                    "id": 13,
                    "instruction": "Initiate the BFS while the queue is not empty.",
                    "placeholderCode": "    while q:",
                    "validationRegex": "^\\s+while\\s+q:$",
                    "hint": "Continue searching as long as there are words to explore.",
                    "solutionCode": "    while q:"
                },
                {
                    "id": 14,
                    "instruction": "Iterate through all words currently in the queue for the current level.",
                    "placeholderCode": "        for i in range(len(q)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(q\\)\\):$",
                    "hint": "This ensures we process the graph level by level (one transformation at a time).",
                    "solutionCode": "        for i in range(len(q)):"
                },
                {
                    "id": 15,
                    "instruction": "Pop the first word from the left of the queue.",
                    "placeholderCode": "            word = q.popleft()",
                    "validationRegex": "^\\s+word\\s*=\\s*q\\.popleft\\(\\)$",
                    "hint": "Standard deque operation to get the next element.",
                    "solutionCode": "            word = q.popleft()"
                },
                {
                    "id": 16,
                    "instruction": "Check if the current word is the target 'endWord'.",
                    "placeholderCode": "            if word == endWord:",
                    "validationRegex": "^\\s+if\\s+word\\s*==\\s*endWord:$",
                    "hint": "We check every word we extract from the queue.",
                    "solutionCode": "            if word == endWord:"
                },
                {
                    "id": 17,
                    "instruction": "If found, return the current step count 'res'.",
                    "placeholderCode": "                return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Success! The first time we reach the endWord, it's guaranteed to be the shortest path.",
                    "solutionCode": "                return res"
                },
                {
                    "id": 18,
                    "instruction": "For each character position 'j', find all possible neighbors.",
                    "placeholderCode": "            for j in range(len(word)):",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(len\\(word\\)\\):$",
                    "hint": "We check all possible 1-letter variations.",
                    "solutionCode": "            for j in range(len(word)):"
                },
                {
                    "id": 19,
                    "instruction": "Generate the pattern for the current word at position 'j'.",
                    "placeholderCode": "                pattern = word[:j] + \"*\" + word[j + 1 :]",
                    "validationRegex": "^\\s+pattern\\s*=\\s*word\\[:j\\]\\s*\\+\\s*\"\\*\"\\s*\\+\\s*word\\[j\\s*\\+\\s*1\\s*:\\]$",
                    "hint": "Match the logic used in preprocessing (Step 8).",
                    "solutionCode": "                pattern = word[:j] + \"*\" + word[j + 1 :]"
                },
                {
                    "id": 20,
                    "instruction": "Iterate through every neighbor associated with that pattern.",
                    "placeholderCode": "                for neighbor in nei[pattern]:",
                    "validationRegex": "^\\s+for\\s+neighbor\\s+in\\s+nei\\[pattern\\]:$",
                    "hint": "Our precomputed 'nei' dictionary gives us these words in O(1).",
                    "solutionCode": "                for neighbor in nei[pattern]:"
                },
                {
                    "id": 21,
                    "instruction": "Check if the neighbor haven't been visited yet.",
                    "placeholderCode": "                    if neighbor not in visit:",
                    "validationRegex": "^\\s+if\\s+neighbor\\s+not\\s+in\\s+visit:$",
                    "hint": "Essential to avoid cycles and redundant work.",
                    "solutionCode": "                    if neighbor not in visit:"
                },
                {
                    "id": 22,
                    "instruction": "Add the neighbor to the 'visit' set.",
                    "placeholderCode": "                        visit.add(neighbor)",
                    "validationRegex": "^\\s+visit\\.add\\(neighbor\\)$",
                    "hint": "Mark it immediately so other paths don't try to add it again.",
                    "solutionCode": "                        visit.add(neighbor)"
                },
                {
                    "id": 23,
                    "instruction": "Append the neighbor to the queue for the next level.",
                    "placeholderCode": "                        q.append(neighbor)",
                    "validationRegex": "^\\s+q\\.append\\(neighbor\\)$",
                    "hint": "The neighbor will be processed in the next level of BFS.",
                    "solutionCode": "                        q.append(neighbor)"
                },
                {
                    "id": 24,
                    "instruction": "After processing the entire current level, increment 'res'.",
                    "placeholderCode": "        res += 1",
                    "validationRegex": "^\\s+res\\s*\\+=\\s*1$",
                    "hint": "Move to the next transformation level.",
                    "solutionCode": "        res += 1"
                },
                {
                    "id": 25,
                    "instruction": "If the queue is empty and endWord was not found, return 0.",
                    "placeholderCode": "    return 0",
                    "validationRegex": "^\\s+return\\s+0$",
                    "hint": "If the loop finishes without a return, no path exists.",
                    "solutionCode": "    return 0"
                }
            ]
        }
    }
}