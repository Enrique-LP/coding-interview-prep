{
    "id": "implement-trie-prefix-tree",
    "title": "Implement Trie (Prefix Tree)",
    "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class.",
    "examples": [
        {
            "input": "[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]",
            "output": [
                null,
                null,
                true,
                false,
                true,
                null,
                true
            ]
        }
    ],
    "constraints": [
        "1 <= word.length, prefix.length <= 2000",
        "word and prefix consist only of lowercase English letters.",
        "At most 3 * 10^4 calls in total will be made to insert, search, and startsWith."
    ],
    "difficulty": "Medium",
    "topic": "Tries",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Standard Trie Implementation",
            "description": "Use a node-based architecture where each node contains a dictionary of children and a boolean flag for word endings.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the 'TrieNode' class.",
                    "placeholderCode": "class TrieNode:",
                    "validationRegex": "^class\\s+TrieNode:$",
                    "hint": "Each node representing a character in the trie.",
                    "solutionCode": "class TrieNode:"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the 'TrieNode' with a constructor.",
                    "placeholderCode": "    def __init__(self):",
                    "validationRegex": "^\\s+def\\s+__init__\\(self\\):$",
                    "hint": "Set up the node's internal state.",
                    "solutionCode": "    def __init__(self):"
                },
                {
                    "id": 3,
                    "instruction": "Initialize 'self.children' as an empty dictionary.",
                    "placeholderCode": "        self.children = {}",
                    "validationRegex": "^\\s+self\\.children\\s*=\\s*{}$",
                    "hint": "This dictionary will map characters to their corresponding child nodes.",
                    "solutionCode": "        self.children = {}"
                },
                {
                    "id": 4,
                    "instruction": "Initialize 'self.end_of_word' to False.",
                    "placeholderCode": "        self.end_of_word = False",
                    "validationRegex": "^\\s+self\\.end_of_word\\s*=\\s*False$",
                    "hint": "A boolean flag to indicate if a word ends at this node.",
                    "solutionCode": "        self.end_of_word = False"
                },
                {
                    "id": 5,
                    "instruction": "Define the main 'Trie' class.",
                    "placeholderCode": "class Trie:",
                    "validationRegex": "^class\\s+Trie:$",
                    "hint": "This class will provide the interface for trie operations.",
                    "solutionCode": "class Trie:"
                },
                {
                    "id": 6,
                    "instruction": "Initialize the 'Trie' with a root node.",
                    "placeholderCode": "    def __init__(self):\n        self.root = TrieNode()",
                    "validationRegex": "^\\s+def\\s+__init__\\(self\\):\\s*self\\.root\\s*=\\s*TrieNode\\(\\)$",
                    "hint": "The root node is the entry point of the prefix tree.",
                    "solutionCode": "    def __init__(self):\n        self.root = TrieNode()"
                },
                {
                    "id": 7,
                    "instruction": "Define the 'insert' method to add a word to the trie.",
                    "placeholderCode": "    def insert(self, word):",
                    "validationRegex": "^\\s+def\\s+insert\\(self,\\s*word\\):$",
                    "hint": "Traverse the tree character by character.",
                    "solutionCode": "    def insert(self, word):"
                },
                {
                    "id": 8,
                    "instruction": "Initialize a pointer 'curr' to the root.",
                    "placeholderCode": "        curr = self.root",
                    "validationRegex": "^\\s+curr\\s*=\\s*self\\.root$",
                    "hint": "Start at the root to process the first character.",
                    "solutionCode": "        curr = self.root"
                },
                {
                    "id": 9,
                    "instruction": "Iterate through each character in the word.",
                    "placeholderCode": "        for char in word:",
                    "validationRegex": "^\\s+for\\s+char\\s+in\\s+word:$",
                    "hint": "Each character represents a node in the path.",
                    "solutionCode": "        for char in word:"
                },
                {
                    "id": 10,
                    "instruction": "If the character is not in current node's children, create a new node.",
                    "placeholderCode": "            if char not in curr.children:\n                curr.children[char] = TrieNode()",
                    "validationRegex": "^\\s+if\\s+char\\s+not\\s+in\\s+curr\\.children:\\s*curr\\.children\\[char\\]\\s*=\\s*TrieNode\\(\\)$",
                    "hint": "Expand the trie dynamically as needed.",
                    "solutionCode": "            if char not in curr.children:\n                curr.children[char] = TrieNode()"
                },
                {
                    "id": 11,
                    "instruction": "Move 'curr' to the child node corresponding to the character.",
                    "placeholderCode": "            curr = curr.children[char]",
                    "validationRegex": "^\\s+curr\\s*=\\s*curr\\.children\\[char\\]$",
                    "hint": "Advance the pointer forward.",
                    "solutionCode": "            curr = curr.children[char]"
                },
                {
                    "id": 12,
                    "instruction": "Mark the current node as the end of a word.",
                    "placeholderCode": "        curr.end_of_word = True",
                    "validationRegex": "^\\s+curr\\.end_of_word\\s*=\\s*True$",
                    "hint": "Set the flag after processing all characters.",
                    "solutionCode": "        curr.end_of_word = True"
                },
                {
                    "id": 13,
                    "instruction": "Define the 'search' method.",
                    "placeholderCode": "    def search(self, word):",
                    "validationRegex": "^\\s+def\\s+search\\(self,\\s*word\\):$",
                    "hint": "Check if a complete word exists in the trie.",
                    "solutionCode": "    def search(self, word):"
                },
                {
                    "id": 14,
                    "instruction": "Initialize 'curr' pointer for searching.",
                    "placeholderCode": "        curr = self.root",
                    "validationRegex": "^\\s+curr\\s*=\\s*self\\.root$",
                    "hint": "Search starts from the root.",
                    "solutionCode": "        curr = self.root"
                },
                {
                    "id": 15,
                    "instruction": "Iterate through the word characters.",
                    "placeholderCode": "        for char in word:",
                    "validationRegex": "^\\s+for\\s+char\\s+in\\s+word:$",
                    "hint": "Follow the path defined by the word.",
                    "solutionCode": "        for char in word:"
                },
                {
                    "id": 16,
                    "instruction": "Return False if a character node is missing.",
                    "placeholderCode": "            if char not in curr.children: return False",
                    "validationRegex": "^\\s+if\\s+char\\s+not\\s+in\\s+curr\\.children:\\s*return\\s+False$",
                    "hint": "If we can't find a character, the word doesn't exist.",
                    "solutionCode": "            if char not in curr.children: return False"
                },
                {
                    "id": 17,
                    "instruction": "Move to the next node.",
                    "placeholderCode": "            curr = curr.children[char]",
                    "validationRegex": "^\\s+curr\\s*=\\s*curr\\.children\\[char\\]$",
                    "hint": "Continue down the path.",
                    "solutionCode": "            curr = curr.children[char]"
                },
                {
                    "id": 18,
                    "instruction": "Return the value of the 'end_of_word' flag.",
                    "placeholderCode": "        return curr.end_of_word",
                    "validationRegex": "^\\s+return\\s+curr\\.end_of_word$",
                    "hint": "Verify if the search stopped at a valid word ending.",
                    "solutionCode": "        return curr.end_of_word"
                },
                {
                    "id": 19,
                    "instruction": "Define the 'startsWith' method.",
                    "placeholderCode": "    def startsWith(self, prefix):",
                    "validationRegex": "^\\s+def\\s+startsWith\\(self,\\s*prefix\\):$",
                    "hint": "Check if any word starts with the given prefix.",
                    "solutionCode": "    def startsWith(self, prefix):"
                },
                {
                    "id": 20,
                    "instruction": "Initialize 'curr' for prefix checking.",
                    "placeholderCode": "        curr = self.root",
                    "validationRegex": "^\\s+curr\\s*=\\s*self\\.root$",
                    "hint": "Process the prefix from the root.",
                    "solutionCode": "        curr = self.root"
                },
                {
                    "id": 21,
                    "instruction": "Iterate through prefix characters.",
                    "placeholderCode": "        for char in prefix:",
                    "validationRegex": "^\\s+for\\s+char\\s+in\\s+prefix:$",
                    "hint": "Each character must exist in sequence.",
                    "solutionCode": "        for char in prefix:"
                },
                {
                    "id": 22,
                    "instruction": "Return False if any prefix character is missing.",
                    "placeholderCode": "            if char not in curr.children: return False",
                    "validationRegex": "^\\s+if\\s+char\\s+not\\s+in\\s+curr\\.children:\\s*return\\s+False$",
                    "hint": "If the prefix breaks, no word starts with it.",
                    "solutionCode": "            if char not in curr.children: return False"
                },
                {
                    "id": 23,
                    "instruction": "Advance the 'curr' pointer.",
                    "placeholderCode": "            curr = curr.children[char]",
                    "validationRegex": "^\\s+curr\\s*=\\s*curr\\.children\\[char\\]$",
                    "hint": "Continue the prefix match.",
                    "solutionCode": "            curr = curr.children[char]"
                },
                {
                    "id": 24,
                    "instruction": "Return True if the entire prefix was found.",
                    "placeholderCode": "        return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "If we finished the loop, the prefix exists.",
                    "solutionCode": "        return True"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Efficient Trie (Dictionary Based)",
            "description": "Uses a dictionary for children to provide O(1) character lookup and a boolean flag for word presence.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the 'TrieNode' class.",
                    "placeholderCode": "class TrieNode:",
                    "validationRegex": "^class\\s+TrieNode:$",
                    "hint": "This class represents a single node in the Trie.",
                    "solutionCode": "class TrieNode:"
                },
                {
                    "id": 2,
                    "instruction": "Define the constructor for 'TrieNode'.",
                    "placeholderCode": "    def __init__(self):",
                    "validationRegex": "^\\s+def\\s+__init__\\(self\\):$",
                    "hint": "Set up the initial variables for each node.",
                    "solutionCode": "    def __init__(self):"
                },
                {
                    "id": 3,
                    "instruction": "Create a dictionary to store child nodes.",
                    "placeholderCode": "        self.children = {}",
                    "validationRegex": "^\\s+self\\.children\\s*=\\s*{}$",
                    "hint": "Maps each character to its child 'TrieNode'.",
                    "solutionCode": "        self.children = {}"
                },
                {
                    "id": 4,
                    "instruction": "Create a boolean flag to mark the end of a word.",
                    "placeholderCode": "        self.end_of_word = False",
                    "validationRegex": "^\\s+self\\.end_of_word\\s*=\\s*False$",
                    "hint": "Set this to True when a complete word finishes at this node.",
                    "solutionCode": "        self.end_of_word = False"
                },
                {
                    "id": 5,
                    "instruction": "Define the wrapper 'Trie' class.",
                    "placeholderCode": "class Trie:",
                    "validationRegex": "^class\\s+Trie:$",
                    "hint": "This class coordinates the insert and search operations.",
                    "solutionCode": "class Trie:"
                },
                {
                    "id": 6,
                    "instruction": "Initialize the trie with a root 'TrieNode'.",
                    "placeholderCode": "    def __init__(self):\n        self.root = TrieNode()",
                    "validationRegex": "^\\s+def\\s+__init__\\(self\\):\\s*self\\.root\\s*=\\s*TrieNode\\(\\)$",
                    "hint": "The root is an empty prefix that branches out to all words.",
                    "solutionCode": "    def __init__(self):\n        self.root = TrieNode()"
                },
                {
                    "id": 7,
                    "instruction": "Define the 'insert' method.",
                    "placeholderCode": "    def insert(self, word):",
                    "validationRegex": "^\\s+def\\s+insert\\(self,\\s*word\\):$",
                    "hint": "Adds a new word sequence to the structure.",
                    "solutionCode": "    def insert(self, word):"
                },
                {
                    "id": 8,
                    "instruction": "Point 'curr' to the root node to start insertion.",
                    "placeholderCode": "        curr = self.root",
                    "validationRegex": "^\\s+curr\\s*=\\s*self\\.root$",
                    "hint": "Insertion always begins from the top of the tree.",
                    "solutionCode": "        curr = self.root"
                },
                {
                    "id": 9,
                    "instruction": "Loop through each character in the input word.",
                    "placeholderCode": "        for char in word:",
                    "validationRegex": "^\\s+for\\s+char\\s+in\\s+word:$",
                    "hint": "Process the word character by character.",
                    "solutionCode": "        for char in word:"
                },
                {
                    "id": 10,
                    "instruction": "Check if the character exists in child nodes; if not, create it.",
                    "placeholderCode": "            if char not in curr.children:\n                curr.children[char] = TrieNode()",
                    "validationRegex": "^\\s+if\\s+char\\s+not\\s+in\\s+curr\\.children:\\s*curr\\.children\\[char\\]\\s*=\\s*TrieNode\\(\\)$",
                    "hint": "Add new nodes only when a character isn't already present.",
                    "solutionCode": "            if char not in curr.children:\n                curr.children[char] = TrieNode()"
                },
                {
                    "id": 11,
                    "instruction": "Advance the current node pointer to the next character's node.",
                    "placeholderCode": "            curr = curr.children[char]",
                    "validationRegex": "^\\s+curr\\s*=\\s*curr\\.children\\[char\\]$",
                    "hint": "Step deeper into the tree for the next character.",
                    "solutionCode": "            curr = curr.children[char]"
                },
                {
                    "id": 12,
                    "instruction": "Set 'end_of_word' to True on the final character's node.",
                    "placeholderCode": "        curr.end_of_word = True",
                    "validationRegex": "^\\s+curr\\.end_of_word\\s*=\\s*True$",
                    "hint": "Indicates that the sequence of nodes traversed matches a whole word.",
                    "solutionCode": "        curr.end_of_word = True"
                },
                {
                    "id": 13,
                    "instruction": "Define the 'search' method.",
                    "placeholderCode": "    def search(self, word):",
                    "validationRegex": "^\\s+def\\s+search\\(self,\\s*word\\):$",
                    "hint": "Looks for a specific complete word.",
                    "solutionCode": "    def search(self, word):"
                },
                {
                    "id": 14,
                    "instruction": "Set 'curr' to root to begin search.",
                    "placeholderCode": "        curr = self.root",
                    "validationRegex": "^\\s+curr\\s*=\\s*self\\.root$",
                    "hint": "Traversing from root is standard for all trie operations.",
                    "solutionCode": "        curr = self.root"
                },
                {
                    "id": 15,
                    "instruction": "Iterate over the word's characters.",
                    "placeholderCode": "        for char in word:",
                    "validationRegex": "^\\s+for\\s+char\\s+in\\s+word:$",
                    "hint": "Follow the character links in the trie.",
                    "solutionCode": "        for char in word:"
                },
                {
                    "id": 16,
                    "instruction": "If a character is missing, return False.",
                    "placeholderCode": "            if char not in curr.children: return False",
                    "validationRegex": "^\\s+if\\s+char\\s+not\\s+in\\s+curr\\.children:\\s*return\\s+False$",
                    "hint": "If the path is broken, the word isn't in the trie.",
                    "solutionCode": "            if char not in curr.children: return False"
                },
                {
                    "id": 17,
                    "instruction": "Update 'curr' to the child node.",
                    "placeholderCode": "            curr = curr.children[char]",
                    "validationRegex": "^\\s+curr\\s*=\\s*curr\\.children\\[char\\]$",
                    "hint": "Move along the existing path.",
                    "solutionCode": "            curr = curr.children[char]"
                },
                {
                    "id": 18,
                    "instruction": "Return the status of 'end_of_word' from the final node.",
                    "placeholderCode": "        return curr.end_of_word",
                    "validationRegex": "^\\s+return\\s+curr\\.end_of_word$",
                    "hint": "Found the path, but check if it's a complete word or just a prefix.",
                    "solutionCode": "        return curr.end_of_word"
                },
                {
                    "id": 19,
                    "instruction": "Define the 'startsWith' method.",
                    "placeholderCode": "    def startsWith(self, prefix):",
                    "validationRegex": "^\\s+def\\s+startsWith\\(self,\\s*prefix\\):$",
                    "hint": "This method checks for prefix existence, regardless of word endings.",
                    "solutionCode": "    def startsWith(self, prefix):"
                },
                {
                    "id": 20,
                    "instruction": "Initialize 'curr' at the root.",
                    "placeholderCode": "        curr = self.root",
                    "validationRegex": "^\\s+curr\\s*=\\s*self\\.root$",
                    "hint": "Prepare for prefix traversal.",
                    "solutionCode": "        curr = self.root"
                },
                {
                    "id": 21,
                    "instruction": "Loop through each character in the prefix.",
                    "placeholderCode": "        for char in prefix:",
                    "validationRegex": "^\\s+for\\s+char\\s+in\\s+prefix:$",
                    "hint": "Verify the presence of each character in order.",
                    "solutionCode": "        for char in prefix:"
                },
                {
                    "id": 22,
                    "instruction": "If a prefix character is absent, return False.",
                    "placeholderCode": "            if char not in curr.children: return False",
                    "validationRegex": "^\\s+if\\s+char\\s+not\\s+in\\s+curr\\.children:\\s*return\\s+False$",
                    "hint": "Any missing node means the prefix doesn't exist.",
                    "solutionCode": "            if char not in curr.children: return False"
                },
                {
                    "id": 23,
                    "instruction": "Move the pointer to the child node.",
                    "placeholderCode": "            curr = curr.children[char]",
                    "validationRegex": "^\\s+curr\\s*=\\s*curr\\.children\\[char\\]$",
                    "hint": "Advance along the prefix path.",
                    "solutionCode": "            curr = curr.children[char]"
                },
                {
                    "id": 24,
                    "instruction": "Return True if all characters were successfully matched.",
                    "placeholderCode": "        return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "If the loop finishes, the prefix path is fully present.",
                    "solutionCode": "        return True"
                }
            ]
        }
    }
}