{
    "id": "minimum-window-substring",
    "title": "Minimum Window Substring",
    "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\". The testcases will be generated such that the answer is unique.",
    "examples": [
        {
            "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
            "output": "\"BANC\"",
            "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."
        },
        {
            "input": "s = \"a\", t = \"a\"",
            "output": "\"a\""
        },
        {
            "input": "s = \"a\", t = \"aa\"",
            "output": "\"\""
        }
    ],
    "constraints": [
        "m == s.length",
        "n == t.length",
        "1 <= m, n <= 10^5",
        "s and t consist of uppercase and lowercase English letters."
    ],
    "difficulty": "Hard",
    "topic": "Sliding Window",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Nested Loops",
            "description": "Check every substring.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_window that takes s and t.",
                    "placeholderCode": "def min_window(s, t):",
                    "validationRegex": "^def\\s+min_window\\(s,\\s*t\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_window(s, t):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate all substrings.",
                    "placeholderCode": "    res = \"\"\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            sub = s[i : j + 1]\n            # Check if sub contains t (omitted for brevity)\n            pass",
                    "validationRegex": "^\\s+res\\s*=\\s*\"\"\\s*for\\s+i\\s+in\\s+range\\(len\\(s\\)\\):\\s*for\\s+j\\s+in\\s+range\\(i,\\s*len\\(s\\)\\):\\s*sub\\s*=\\s*s\\[i\\s*:\\s*j\\s*\\+\\s*1\\]\\s*pass$",
                    "hint": "Iterate through all substrings using nested loops.",
                    "solutionCode": "    res = \"\"\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            sub = s[i : j + 1]\n            # Check if sub contains t (omitted for brevity)\n            pass"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Sliding Window",
            "description": "Expand right to satisfy, shrink left to minimize.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_window.",
                    "placeholderCode": "def min_window(s, t):",
                    "validationRegex": "^def\\s+min_window\\(s,\\s*t\\):$",
                    "hint": "Define the function with target `t` and source `s`.",
                    "solutionCode": "def min_window(s, t):"
                },
                {
                    "id": 2,
                    "instruction": "Handle the empty case for string t.",
                    "placeholderCode": "    if t == \"\": return \"\"",
                    "validationRegex": "^\\s+if\\s+t\\s*==\\s*\"\":\\s*return\\s*\"\"$",
                    "hint": "If we need nothing, return an empty string.",
                    "solutionCode": "    if t == \"\": return \"\""
                },
                {
                    "id": 3,
                    "instruction": "Initialize frequency dictionaries for T and the current window.",
                    "placeholderCode": "    countT, window = {}, {}",
                    "validationRegex": "^\\s+countT,\\s*window\\s*=\\s*\\{\\},\\s*\\{\\}$",
                    "hint": "We need to track what characters we NEED (`countT`) and what we HAVE in the window (`window`).",
                    "solutionCode": "    countT, window = {}, {}"
                },
                {
                    "id": 4,
                    "instruction": "Start a loop to iterate through each character in target string t.",
                    "placeholderCode": "    for c in t:",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+t:$",
                    "hint": "We need to go through string `t` to count character frequencies.",
                    "solutionCode": "    for c in t:"
                },
                {
                    "id": 5,
                    "instruction": "Update the count of character 'c' in the countT dictionary.",
                    "placeholderCode": "        countT[c] = 1 + countT.get(c, 0)",
                    "validationRegex": "^\\s+countT\\[c\\]\\s*=\\s*1\\s*\\+\\s*countT\\.get\\(c,\\s*0\\)$",
                    "hint": "Increment the value for key `c`. If `c` is not present, use 0 as the default.",
                    "solutionCode": "        countT[c] = 1 + countT.get(c, 0)"
                },
                {
                    "id": 6,
                    "instruction": "Initialize status variables.",
                    "placeholderCode": "    have, need = 0, len(countT)",
                    "validationRegex": "^\\s+have,\\s*need\\s*=\\s*0,\\s*len\\(countT\\)$",
                    "hint": "`need` is the number of UNIQUE characters in `t`. `have` is how many of those unique characters satisfy the required frequency in our window.",
                    "solutionCode": "    have, need = 0, len(countT)"
                },
                {
                    "id": 7,
                    "instruction": "Initialize the variable to store the best window range.",
                    "placeholderCode": "    res = [-1, -1]",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[-1,\\s*-1\\]$",
                    "hint": "We use `[-1, -1]` to store the start and end indices of the smallest valid window we find. Since we haven't found any yet, we start with dummy values.",
                    "solutionCode": "    res = [-1, -1]"
                },
                {
                    "id": 8,
                    "instruction": "Initialize the variable to track the minimum window length.",
                    "placeholderCode": "    resLen = float(\"inf\")",
                    "validationRegex": "^\\s+resLen\\s*=\\s*float\\(\"inf\"\\)$",
                    "hint": "We start with `infinity` because we want any valid window found to be smaller than the current `resLen`.",
                    "solutionCode": "    resLen = float(\"inf\")"
                },
                {
                    "id": 9,
                    "instruction": "Initialize the left pointer of the sliding window.",
                    "placeholderCode": "    l = 0",
                    "validationRegex": "^\\s+l\\s*=\\s*0$",
                    "hint": "The left pointer `l` marks the beginning of our current window.",
                    "solutionCode": "    l = 0"
                },
                {
                    "id": 10,
                    "instruction": "Start the main loop to expand the window using the right pointer r.",
                    "placeholderCode": "    for r in range(len(s)):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(len\\(s\\)\\):$",
                    "hint": "This loop defines the right boundary of our window, expanding it from left to right as `r` increases.",
                    "solutionCode": "    for r in range(len(s)):"
                },
                {
                    "id": 11,
                    "instruction": "Retrieve the character at the current right pointer position.",
                    "placeholderCode": "        c = s[r]",
                    "validationRegex": "^\\s+c\\s*=\\s*s\\[r\\]$",
                    "hint": "We assign `s[r]` to a variable `c` to make it easier to work with in the following steps.",
                    "solutionCode": "        c = s[r]"
                },
                {
                    "id": 12,
                    "instruction": "Add the current character to the window count.",
                    "placeholderCode": "        window[c] = 1 + window.get(c, 0)",
                    "validationRegex": "^\\s+window\\[c\\]\\s*=\\s*1\\s*\\+\\s*window\\.get\\(c,\\s*0\\)$",
                    "hint": "Update our window frequency dictionary.",
                    "solutionCode": "        window[c] = 1 + window.get(c, 0)"
                },
                {
                    "id": 13,
                    "instruction": "Check if the current character's frequency requirement is met.",
                    "placeholderCode": "        if c in countT and window[c] == countT[c]:",
                    "validationRegex": "^\\s+if\\s+c\\s+in\\s+countT\\s+and\\s+window\\[c\\]\\s*==\\s*countT\\[c\\]:$",
                    "hint": "We only care about characters that are in `countT`. If our window has reached the exact frequency needed for character `c`, we've satisfied one unique character requirement.",
                    "solutionCode": "        if c in countT and window[c] == countT[c]:"
                },
                {
                    "id": 14,
                    "instruction": "Increment the count of satisfied character requirements.",
                    "placeholderCode": "            have += 1",
                    "validationRegex": "^\\s+have\\s*\\+=\\s*1$",
                    "hint": "The `have` variable tracks how many unique characters from `t` have been fully satisfied in the current window.",
                    "solutionCode": "            have += 1"
                },
                {
                    "id": 15,
                    "instruction": "Start contracting the window from the left as long as it remains valid.",
                    "placeholderCode": "        while have == need:",
                    "validationRegex": "^\\s+while\\s+have\\s*==\\s*need:$",
                    "hint": "When `have == need`, our current window `[l, r]` contains all necessary characters. We enter this loop to see if we can shrink the window from the left while keeping it valid to find the minimum length.",
                    "solutionCode": "        while have == need:"
                },
                {
                    "id": 16,
                    "instruction": "Update the result if the current window is smaller.",
                    "placeholderCode": "            if (r - l + 1) < resLen:\n                res = [l, r]\n                resLen = (r - l + 1)",
                    "validationRegex": "^\\s+if\\s+\\(r\\s*-\\s*l\\s*\\+\\s*1\\)\\s*<\\s*resLen:\\s*res\\s*=\\s*\\[l,\\s*r\\]\\s*resLen\\s*=\\s*\\(r\\s*-\\s*l\\s*\\+\\s*1\\)$",
                    "hint": "We found a valid window! Save its boundaries and update the minimum length.",
                    "solutionCode": "            if (r - l + 1) < resLen:\n                res = [l, r]\n                resLen = (r - l + 1)"
                },
                {
                    "id": 17,
                    "instruction": "Remove the character at the left from the window.",
                    "placeholderCode": "            window[s[l]] -= 1\n            if s[l] in countT and window[s[l]] < countT[s[l]]:\n                have -= 1\n            l += 1",
                    "validationRegex": "^\\s+window\\[s\\[l\\]\\]\\s*-=\\s*1\\s*if\\s+s\\[l\\]\\s+in\\s+countT\\s+and\\s+window\\[s\\[l\\]\\]\\s*<\\s*countT\\[s\\[l\\]\\]:\\s*have\\s*-=\\s*1\\s*l\\s*\\+=\\s*1$",
                    "hint": "Crucial: Pop the left character. If losing it makes the window invalid (`have < need`), the while loop will end. Increment `l` to move the left border.",
                    "solutionCode": "            window[s[l]] -= 1\n            if s[l] in countT and window[s[l]] < countT[s[l]]:\n                have -= 1\n            l += 1"
                },
                {
                    "id": 18,
                    "instruction": "Return the final result as a substring.",
                    "placeholderCode": "    l, r = res\n    return s[l : r + 1] if resLen != float(\"inf\") else \"\"",
                    "validationRegex": "^\\s+l\\s*,\\s*r\\s*=\\s*res\\s+return\\s+s\\[l\\s*:\\s*r\\s*\\+\\s*1\\]\\s+if\\s+resLen\\s*!=\\s*float\\(\"inf\"\\)\\s+else\\s+\"\"$",
                    "hint": "Retrieve the best boundaries from `res`. If `resLen` is still infinity, it means no valid window was found.",
                    "solutionCode": "    l, r = res\n    return s[l : r + 1] if resLen != float(\"inf\") else \"\""
                }
            ]
        }
    }
}