{
    "id": "distinct-subsequences",
    "title": "Distinct Subsequences",
    "description": "Given two strings s and t, return the number of distinct subsequences of s which equals t. The test cases are generated so that the answer fits on a 32-bit signed integer.",
    "examples": [
        {
            "input": "s = \"rabbbit\", t = \"rabbit\"",
            "output": "3",
            "explanation": "As shown below, there are 3 ways you can generate \"rabbit\" from s.\nrabbbit\nrabbbit\nrabbbit"
        },
        {
            "input": "s = \"babgbag\", t = \"bag\"",
            "output": "5",
            "explanation": "As shown below, there are 5 ways you can generate \"bag\" from s.\nbabgbag\nbabgbag\nbabgbag\nbabgbag\nbabgbag"
        }
    ],
    "constraints": [
        "1 <= s.length, t.length <= 1000",
        "s and t consist of English letters."
    ],
    "difficulty": "Hard",
    "topic": "2-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively check matching characters with memoization to find the number of distinct subsequences.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function num_distinct that takes strings s and t.",
                    "placeholderCode": "def num_distinct(s, t):",
                    "validationRegex": "^def\\s+num_distinct\\(s,\\s*t\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def num_distinct(s, t):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(i, j):\n        if j == len(t): return 1\n        if i == len(s): return 0\n        if (i, j) in memo: return memo[(i, j)]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i,\\s*j\\):\\s*if\\s+j\\s*==\\s*len\\(t\\):\\s*return\\s+1\\s*if\\s+i\\s*==\\s*len\\(s\\):\\s*return\\s+0\\s*if\\s*\\(i,\\s*j\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(i,\\s*j\\)\\]$",
                    "hint": "Recursive function `dfs(i, j)` returns ways to form t[j:] from s[i:]. Base cases: t consumed -> 1, s consumed -> 0. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(i, j):\n        if j == len(t): return 1\n        if i == len(s): return 0\n        if (i, j) in memo: return memo[(i, j)]"
                },
                {
                    "id": 3,
                    "instruction": "If characters match, sum the results of including or excluding the character from s.",
                    "placeholderCode": "        if s[i] == t[j]:\n            res = dfs(i + 1, j + 1) + dfs(i + 1, j)",
                    "validationRegex": "^\\s+if\\s+s\\[i\\]\\s*==\\s+t\\[j\\]:\\s*res\\s*=\\s*dfs\\(i\\s*\\+\\s*1,\\s*j\\s*\\+\\s*1\\)\\s*\\+\\s*dfs\\(i\\s*\\+\\s*1,\\s*j\\)$",
                    "hint": "If characters match, we can either use s[i] (move both pointers) or skip s[i] (move only i). Sum both possibilities.",
                    "solutionCode": "        if s[i] == t[j]:\n            res = dfs(i + 1, j + 1) + dfs(i + 1, j)"
                },
                {
                    "id": 4,
                    "instruction": "If characters do not match, exclude the current character from s.",
                    "placeholderCode": "        else:\n            res = dfs(i + 1, j)",
                    "validationRegex": "^\\s+else:\\s*res\\s*=\\s*dfs\\(i\\s*\\+\\s*1,\\s*j\\)$",
                    "hint": "If characters don't match, we must skip s[i].",
                    "solutionCode": "        else:\n            res = dfs(i + 1, j)"
                },
                {
                    "id": 5,
                    "instruction": "Memoize and return the result.",
                    "placeholderCode": "        memo[(i, j)] = res\n        return res",
                    "validationRegex": "^\\s+memo\\[\\(i,\\s*j\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in memo and return.",
                    "solutionCode": "        memo[(i, j)] = res\n        return res"
                },
                {
                    "id": 6,
                    "instruction": "Start the recursion from the beginning of both strings.",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start recursion from beginning of both strings.",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Use 2D bottom-up dynamic programming to efficiently count distinct subsequences in O(m*n) time.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function num_distinct that takes strings s and t.",
                    "placeholderCode": "def num_distinct(s, t):",
                    "validationRegex": "^def\\s+num_distinct\\(s,\\s*t\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def num_distinct(s, t):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP table with zeros for dimensions (len(s)+1) by (len(t)+1).",
                    "placeholderCode": "    dp = [[0 for j in range(len(t) + 1)] for i in range(len(s) + 1)]",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[\\[0\\s+for\\s+j\\s+in\\s+range\\(len\\(t\\)\\s*\\+\\s*1\\)\\]\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\)\\s*\\+\\s*1\\)\\]$",
                    "hint": "dp[i][j] will store the number of distinct subsequences of s[i:] that match t[j:].",
                    "solutionCode": "    dp = [[0 for j in range(len(t) + 1)] for i in range(len(s) + 1)]"
                },
                {
                    "id": 3,
                    "instruction": "Initiate a loop to set the base cases for when the target string 't' is empty.",
                    "placeholderCode": "    for i in range(len(s) + 1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\)\\s*\\+\\s*1\\):$",
                    "hint": "An empty string 't' is a subsequence of any suffix of 's'.",
                    "solutionCode": "    for i in range(len(s) + 1):"
                },
                {
                    "id": 4,
                    "instruction": "Set the base case value to 1 in the DP table for an empty 't'.",
                    "placeholderCode": "        dp[i][len(t)] = 1",
                    "validationRegex": "^\\s+dp\\[i\\]\\[len\\(t\\)\\]\\s*=\\s*1$",
                    "hint": "There is exactly one way to form an empty string (by picking nothing).",
                    "solutionCode": "        dp[i][len(t)] = 1"
                },
                {
                    "id": 5,
                    "instruction": "Initiate the outer loop to iterate backwards through string 's'.",
                    "placeholderCode": "    for i in range(len(s) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "We process the string from the end to build solutions using previously computed subproblems.",
                    "solutionCode": "    for i in range(len(s) - 1, -1, -1):"
                },
                {
                    "id": 6,
                    "instruction": "Initiate the inner loop to iterate backwards through string 't'.",
                    "placeholderCode": "        for j in range(len(t) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(len\\(t\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "Each cell dp[i][j] depends on cells with larger i or j indices.",
                    "solutionCode": "        for j in range(len(t) - 1, -1, -1):"
                },
                {
                    "id": 7,
                    "instruction": "Check if the current characters from 's' and 't' match.",
                    "placeholderCode": "            if s[i] == t[j]:",
                    "validationRegex": "^\\s+if\\s+s\\[i\\]\\s*==\\s+t\\[j\\]:$",
                    "hint": "When characters match, we have multiple ways to proceed.",
                    "solutionCode": "            if s[i] == t[j]:"
                },
                {
                    "id": 8,
                    "instruction": "If they match, add the ways to form the subsequence using the character (diagonal) and skipping the character (down).",
                    "placeholderCode": "                dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]",
                    "validationRegex": "^\\s+dp\\[i\\]\\[j\\]\\s*=\\s*dp\\[i\\s*\\+\\s*1\\]\\[j\\s*\\+\\s*1\\]\\s*\\+\\s*dp\\[i\\s*\\+\\s*1\\]\\[j\\]$",
                    "hint": "Using s[i] reduces both targets, skipping it only moves the s index.",
                    "solutionCode": "                dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]"
                },
                {
                    "id": 9,
                    "instruction": "If the characters do not match, handle the alternative case.",
                    "placeholderCode": "            else:",
                    "validationRegex": "^\\s+else:$",
                    "hint": "When no match is found, we only have one option.",
                    "solutionCode": "            else:"
                },
                {
                    "id": 10,
                    "instruction": "If they don't match, the result is simply the ways to form the subsequence skipping the current character in 's'.",
                    "placeholderCode": "                dp[i][j] = dp[i + 1][j]",
                    "validationRegex": "^\\s+dp\\[i\\]\\[j\\]\\s*=\\s*dp\\[i\\s*\\+\\s*1\\]\\[j\\]$",
                    "hint": "Transition to the subproblem where we only skip the current character in s.",
                    "solutionCode": "                dp[i][j] = dp[i + 1][j]"
                },
                {
                    "id": 11,
                    "instruction": "Return the final count from the top-left of the DP table.",
                    "placeholderCode": "    return dp[0][0]",
                    "validationRegex": "^\\s+return\\s+dp\\[0\\]\\[0\\]$",
                    "hint": "The result dp[0][0] represents the matches for the full strings starting from index 0.",
                    "solutionCode": "    return dp[0][0]"
                }
            ]
        }
    }
}