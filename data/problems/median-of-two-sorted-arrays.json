{
    "id": "median-of-two-sorted-arrays",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "examples": [
        {
            "input": "nums1 = [1,3], nums2 = [2]",
            "output": "2.00000"
        },
        {
            "input": "nums1 = [1,2], nums2 = [3,4]",
            "output": "2.50000"
        }
    ],
    "constraints": [
        "nums1.length == m",
        "nums2.length == n",
        "0 <= m <= 1000",
        "0 <= n <= 1000",
        "1 <= m + n <= 2000",
        "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "difficulty": "Hard",
    "topic": "Binary Search",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Merge and Sort",
            "description": "Merge arrays and find median.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_median_sorted_arrays that takes nums1 and nums2.",
                    "placeholderCode": "def find_median_sorted_arrays(nums1, nums2):",
                    "validationRegex": "^def\\s+find_median_sorted_arrays\\(nums1,\\s*nums2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_median_sorted_arrays(nums1, nums2):"
                },
                {
                    "id": 2,
                    "instruction": "Merge and sort.",
                    "placeholderCode": "    nums = sorted(nums1 + nums2)\n    n = len(nums)",
                    "validationRegex": "^\\s+nums\\s*=\\s*sorted\\(nums1\\s*\\+\\s*nums2\\)\\s*n\\s*=\\s*len\\(nums\\)$",
                    "hint": "Concatenate and sort the arrays.",
                    "solutionCode": "    nums = sorted(nums1 + nums2)\n    n = len(nums)"
                },
                {
                    "id": 3,
                    "instruction": "Find median.",
                    "placeholderCode": "    if n % 2 == 1:\n        return float(nums[n // 2])\n    else:\n        return (nums[n // 2] + nums[n // 2 - 1]) / 2.0",
                    "validationRegex": "^\\s+if\\s+n\\s*%\\s*2\\s*==\\s*1:\\s*return\\s+float\\(nums\\[n\\s*//\\s*2\\]\\)\\s*else:\\s*return\\s*\\(nums\\[n\\s*//\\s*2\\]\\s*\\+\\s*nums\\[n\\s*//\\s*2\\s*-\\s*1\\]\\)\\s*/\\s*2\\.0$",
                    "hint": "Return middle element if odd, else average of two middle elements.",
                    "solutionCode": "    if n % 2 == 1:\n        return float(nums[n // 2])\n    else:\n        return (nums[n // 2] + nums[n // 2 - 1]) / 2.0"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Binary Search",
            "description": "Binary search on the smaller array partition.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_median_sorted_arrays that takes nums1 and nums2.",
                    "placeholderCode": "def find_median_sorted_arrays(nums1, nums2):",
                    "validationRegex": "^def\\s+find_median_sorted_arrays\\(nums1,\\s*nums2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_median_sorted_arrays(nums1, nums2):"
                },
                {
                    "id": 2,
                    "instruction": "Assign pointers A and B to nums1 and nums2.",
                    "placeholderCode": "    A, B = nums1, nums2",
                    "validationRegex": "^\\s+A,\\s*B\\s*=\\s*nums1,\\s*nums2$",
                    "hint": "Start by identifying the arrays we will be working with.",
                    "solutionCode": "    A, B = nums1, nums2"
                },
                {
                    "id": 3,
                    "instruction": "Calculate the total number of elements in both arrays.",
                    "placeholderCode": "    total = len(nums1) + len(nums2)",
                    "validationRegex": "^\\s+total\\s*=\\s*len\\(nums1\\)\\s*\\+\\s*len\\(nums2\\)$",
                    "hint": "We need the total length to calculate the median position.",
                    "solutionCode": "    total = len(nums1) + len(nums2)"
                },
                {
                    "id": 4,
                    "instruction": "Find the middle partition index (half).",
                    "placeholderCode": "    half = total // 2",
                    "validationRegex": "^\\s+half\\s*=\\s*total\\s*//\\s*2$",
                    "hint": "The median will be found around this half point of the combined arrays.",
                    "solutionCode": "    half = total // 2"
                },
                {
                    "id": 5,
                    "instruction": "Check if array B is smaller than array A.",
                    "placeholderCode": "    if len(B) < len(A):",
                    "validationRegex": "^\\s+if\\s+len\\(B\\)\\s*<\\s+len\\(A\\):$",
                    "hint": "We want to perform binary search on the smaller array for O(log(min(m,n))) complexity.",
                    "solutionCode": "    if len(B) < len(A):"
                },
                {
                    "id": 6,
                    "instruction": "Swap A and B to ensure A is always the smaller array.",
                    "placeholderCode": "        A, B = B, A",
                    "validationRegex": "^\\s+A,\\s*B\\s*=\\s*B,\\s*A$",
                    "hint": "If B was smaller, make it A so our binary search remains efficient.",
                    "solutionCode": "        A, B = B, A"
                },
                {
                    "id": 7,
                    "instruction": "Initialize binary search pointers l and r for array A.",
                    "placeholderCode": "    l, r = 0, len(A) - 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(A\\)\\s*-\\s*1$",
                    "hint": "Set up the search space for our binary search on the smaller array.",
                    "solutionCode": "    l, r = 0, len(A) - 1"
                },
                {
                    "id": 8,
                    "instruction": "Start the infinite loop for binary search.",
                    "placeholderCode": "    while True:",
                    "validationRegex": "^\\s+while\\s+True:$",
                    "hint": "We use an infinite loop because we are guaranteed to find a solution.",
                    "solutionCode": "    while True:"
                },
                {
                    "id": 9,
                    "instruction": "Calculate partition index i for array A.",
                    "placeholderCode": "        i = (l + r) // 2",
                    "validationRegex": "^\\s+i\\s*=\\s*\\(l\\s*\\+\\s*r\\)\\s*//\\s*2$",
                    "hint": "Find the middle of array A for our current search range.",
                    "solutionCode": "        i = (l + r) // 2"
                },
                {
                    "id": 10,
                    "instruction": "Calculate partition index j for array B.",
                    "placeholderCode": "        j = half - i - 2",
                    "validationRegex": "^\\s+j\\s*=\\s*half\\s*-\\s*i\\s*-\\s*2$",
                    "hint": "Index j is derived from i to ensure we split the total elements into two equal halves.",
                    "solutionCode": "        j = half - i - 2"
                },
                {
                    "id": 11,
                    "instruction": "Determine the value to the left of the partition in A.",
                    "placeholderCode": "        Aleft = A[i] if i >= 0 else float(\"-infinity\")",
                    "validationRegex": "^\\s+Aleft\\s*=\\s*A\\[i\\]\\s+if\\s+i\\s*>=\\s*0\\s+else\\s+float\\(\"-infinity\"\\)$",
                    "hint": "If i is out of bounds on the left, use negative infinity as a placeholder.",
                    "solutionCode": "        Aleft = A[i] if i >= 0 else float(\"-infinity\")"
                },
                {
                    "id": 12,
                    "instruction": "Determine the value to the right of the partition in A.",
                    "placeholderCode": "        Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")",
                    "validationRegex": "^\\s+Aright\\s*=\\s*A\\[i\\s*\\+\\s*1\\]\\s+if\\s*\\(i\\s*\\+\\s*1\\)\\s*<\\s+len\\(A\\)\\s+else\\s+float\\(\"infinity\"\\)$",
                    "hint": "If i+1 is out of bounds on the right, use positive infinity as a placeholder.",
                    "solutionCode": "        Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")"
                },
                {
                    "id": 13,
                    "instruction": "Determine the value to the left of the partition in B.",
                    "placeholderCode": "        Bleft = B[j] if j >= 0 else float(\"-infinity\")",
                    "validationRegex": "^\\s+Bleft\\s*=\\s*B\\[j\\]\\s+if\\s+j\\s*>=\\s*0\\s+else\\s+float\\(\"-infinity\"\\)$",
                    "hint": "Use negative infinity if the partition in B is at the very beginning.",
                    "solutionCode": "        Bleft = B[j] if j >= 0 else float(\"-infinity\")"
                },
                {
                    "id": 14,
                    "instruction": "Determine the value to the right of the partition in B.",
                    "placeholderCode": "        Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")",
                    "validationRegex": "^\\s+Bright\\s*=\\s*B\\[j\\s*\\+\\s*1\\]\\s+if\\s*\\(j\\s*\\+\\s*1\\)\\s*<\\s+len\\(B\\)\\s+else\\s+float\\(\"infinity\"\\)$",
                    "hint": "Use positive infinity if the partition in B is at the very end.",
                    "solutionCode": "        Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")"
                },
                {
                    "id": 15,
                    "instruction": "Check if the current partition is valid.",
                    "placeholderCode": "        if Aleft <= Bright and Bleft <= Aright:",
                    "validationRegex": "^\\s+if\\s+Aleft\\s*<=\\s*Bright\\s+and\\s+Bleft\\s*<=\\s*Aright:$",
                    "hint": "The partition is correct if every element on the left side is less than or equal to every element on the right side.",
                    "solutionCode": "        if Aleft <= Bright and Bleft <= Aright:"
                },
                {
                    "id": 16,
                    "instruction": "If the total number of elements is odd, find the median.",
                    "placeholderCode": "            if total % 2:",
                    "validationRegex": "^\\s+if\\s+total\\s*%\\s*2:$",
                    "hint": "For an odd number of elements, we just need the smallest value on the right side.",
                    "solutionCode": "            if total % 2:"
                },
                {
                    "id": 17,
                    "instruction": "Return the minimum of the two right values as the median.",
                    "placeholderCode": "                return min(Aright, Bright)",
                    "validationRegex": "^\\s+return\\s+min\\(Aright,\\s*Bright\\)$",
                    "hint": "In an odd total, the median is the starting element of the right half.",
                    "solutionCode": "                return min(Aright, Bright)"
                },
                {
                    "id": 18,
                    "instruction": "Return the average of the maximum left and minimum right values for an even total.",
                    "placeholderCode": "            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2",
                    "validationRegex": "^\\s+return\\s*\\(max\\(Aleft,\\s*Bleft\\)\\s*\\+\\s*min\\(Aright,\\s*Bright\\)\\)\\s*/\\s*2$",
                    "hint": "For even totals, the median is the average of the two middle elements (the largest of the left and the smallest of the right).",
                    "solutionCode": "            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2"
                },
                {
                    "id": 19,
                    "instruction": "Handle the case where the partition in A is too far to the right.",
                    "placeholderCode": "        elif Aleft > Bright:",
                    "validationRegex": "^\\s+elif\\s+Aleft\\s*>\\s*Bright:$",
                    "hint": "If the value in A is too large, we need to move our search to the left.",
                    "solutionCode": "        elif Aleft > Bright:"
                },
                {
                    "id": 20,
                    "instruction": "Update the right pointer r to search the left side of the current range.",
                    "placeholderCode": "            r = i - 1",
                    "validationRegex": "^\\s+r\\s*=\\s*i\\s*-\\s*1$",
                    "hint": "Narrow the search range in array A by moving the right pointer.",
                    "solutionCode": "            r = i - 1"
                },
                {
                    "id": 21,
                    "instruction": "Otherwise, move the left pointer l to search the right side of the current range.",
                    "placeholderCode": "        else:\n            l = i + 1",
                    "validationRegex": "^\\s+else:\\s*l\\s*=\\s*i\\s*\\+\\s*1$",
                    "hint": "If the binary search didn't go left, it must go right.",
                    "solutionCode": "        else:\n            l = i + 1"
                }
            ]
        }
    }
}