{
    "id": "median-of-two-sorted-arrays",
    "title": "Median of Two Sorted Arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
    "examples": [
        {
            "input": "nums1 = [1,3], nums2 = [2]",
            "output": "2.00000"
        },
        {
            "input": "nums1 = [1,2], nums2 = [3,4]",
            "output": "2.50000"
        }
    ],
    "constraints": [
        "nums1.length == m",
        "nums2.length == n",
        "0 <= m <= 1000",
        "0 <= n <= 1000",
        "1 <= m + n <= 2000",
        "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "difficulty": "Hard",
    "topic": "Binary Search",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Merge and Sort",
            "description": "Merge arrays and find median.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_median_sorted_arrays that takes nums1 and nums2.",
                    "placeholderCode": "def find_median_sorted_arrays(nums1, nums2):",
                    "validationRegex": "^def\\s+find_median_sorted_arrays\\(nums1,\\s*nums2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_median_sorted_arrays(nums1, nums2):"
                },
                {
                    "id": 2,
                    "instruction": "Merge and sort.",
                    "placeholderCode": "    nums = sorted(nums1 + nums2)\n    n = len(nums)",
                    "validationRegex": "^\\s+nums\\s*=\\s*sorted\\(nums1\\s*\\+\\s*nums2\\)\\s*n\\s*=\\s*len\\(nums\\)$",
                    "hint": "Concatenate and sort the arrays.",
                    "solutionCode": "    nums = sorted(nums1 + nums2)\n    n = len(nums)"
                },
                {
                    "id": 3,
                    "instruction": "Find median.",
                    "placeholderCode": "    if n % 2 == 1:\n        return float(nums[n // 2])\n    else:\n        return (nums[n // 2] + nums[n // 2 - 1]) / 2.0",
                    "validationRegex": "^\\s+if\\s+n\\s*%\\s*2\\s*==\\s*1:\\s*return\\s+float\\(nums\\[n\\s*//\\s*2\\]\\)\\s*else:\\s*return\\s*\\(nums\\[n\\s*//\\s*2\\]\\s*\\+\\s*nums\\[n\\s*//\\s*2\\s*-\\s*1\\]\\)\\s*/\\s*2\\.0$",
                    "hint": "Return middle element if odd, else average of two middle elements.",
                    "solutionCode": "    if n % 2 == 1:\n        return float(nums[n // 2])\n    else:\n        return (nums[n // 2] + nums[n // 2 - 1]) / 2.0"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Binary Search",
            "description": "Binary search on the smaller array partition.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_median_sorted_arrays that takes nums1 and nums2.",
                    "placeholderCode": "def find_median_sorted_arrays(nums1, nums2):",
                    "validationRegex": "^def\\s+find_median_sorted_arrays\\(nums1,\\s*nums2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_median_sorted_arrays(nums1, nums2):"
                },
                {
                    "id": 2,
                    "instruction": "Assign pointers A and B to nums1 and nums2.",
                    "placeholderCode": "    A, B = nums1, nums2",
                    "validationRegex": "^\\s+A,\\s*B\\s*=\\s*nums1,\\s*nums2$",
                    "hint": "Start by identifying the arrays we will be working with.",
                    "solutionCode": "    A, B = nums1, nums2"
                },
                {
                    "id": 3,
                    "instruction": "Calculate the total number of elements in both arrays.",
                    "placeholderCode": "    total = len(nums1) + len(nums2)",
                    "validationRegex": "^\\s+total\\s*=\\s*len\\(nums1\\)\\s*\\+\\s*len\\(nums2\\)$",
                    "hint": "We need the total length to calculate the median position.",
                    "solutionCode": "    total = len(nums1) + len(nums2)"
                },
                {
                    "id": 4,
                    "instruction": "Find the middle partition index (half).",
                    "placeholderCode": "    half = total // 2",
                    "validationRegex": "^\\s+half\\s*=\\s*total\\s*//\\s*2$",
                    "hint": "The median will be found around this half point of the combined arrays.",
                    "solutionCode": "    half = total // 2"
                },
                {
                    "id": 5,
                    "instruction": "Check if array B is smaller than array A.",
                    "placeholderCode": "    if len(B) < len(A):",
                    "validationRegex": "^\\s+if\\s+len\\(B\\)\\s*<\\s+len\\(A\\):$",
                    "hint": "We want to perform binary search on the smaller array for O(log(min(m,n))) complexity.",
                    "solutionCode": "    if len(B) < len(A):"
                },
                {
                    "id": 6,
                    "instruction": "Swap A and B to ensure A is always the smaller array.",
                    "placeholderCode": "        A, B = B, A",
                    "validationRegex": "^\\s+A,\\s*B\\s*=\\s*B,\\s*A$",
                    "hint": "If B was smaller, make it A so our binary search remains efficient.",
                    "solutionCode": "        A, B = B, A"
                },
                {
                    "id": 7,
                    "instruction": "Perform binary search to find the correct partition.",
                    "placeholderCode": "    l, r = 0, len(A) - 1\n    while True:\n        i = (l + r) // 2\n        j = half - i - 2\n        Aleft = A[i] if i >= 0 else float(\"-infinity\")\n        Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n        Bleft = B[j] if j >= 0 else float(\"-infinity\")\n        Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n        if Aleft <= Bright and Bleft <= Aright:\n            if total % 2:\n                return min(Aright, Bright)\n            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n        elif Aleft > Bright:\n            r = i - 1\n        else:\n            l = i + 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(A\\)\\s*-\\s*1\\s*while\\s+True:\\s*i\\s*=\\s*\\(l\\s*\\+\\s*r\\)\\s*//\\s*2\\s*j\\s*=\\s*half\\s*-\\s*i\\s*-\\s*2\\s*Aleft\\s*=\\s*A\\[i\\]\\s+if\\s+i\\s*>=\\s*0\\s+else\\s+float\\(\"-infinity\"\\)\\s*Aright\\s*=\\s*A\\[i\\s*\\+\\s*1\\]\\s+if\\s*\\(i\\s*\\+\\s*1\\)\\s*<\\s+len\\(A\\)\\s+else\\s+float\\(\"infinity\"\\)\\s*Bleft\\s*=\\s*B\\[j\\]\\s+if\\s+j\\s*>=\\s*0\\s+else\\s+float\\(\"-infinity\"\\)\\s*Bright\\s*=\\s*B\\[j\\s*\\+\\s*1\\]\\s+if\\s*\\(j\\s*\\+\\s*1\\)\\s*<\\s+len\\(B\\)\\s+else\\s+float\\(\"infinity\"\\)\\s*if\\s+Aleft\\s*<=\\s*Bright\\s+and\\s+Bleft\\s*<=\\s*Aright:\\s*if\\s+total\\s*%\\s*2:\\s*return\\s+min\\(Aright,\\s*Bright\\)\\s*return\\s*\\(max\\(Aleft,\\s*Bleft\\)\\s*\\+\\s*min\\(Aright,\\s*Bright\\)\\)\\s*/\\s*2\\s*elif\\s+Aleft\\s*>\\s*Bright:\\s*r\\s*=\\s*i\\s*-\\s*1\\s*else:\\s*l\\s*=\\s*i\\s*\\+\\s*1$",
                    "hint": "Use binary search on the smaller array A to find the partition point where elements on the left are smaller than elements on the right in both arrays.",
                    "solutionCode": "    l, r = 0, len(A) - 1\n    while True:\n        i = (l + r) // 2\n        j = half - i - 2\n        Aleft = A[i] if i >= 0 else float(\"-infinity\")\n        Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n        Bleft = B[j] if j >= 0 else float(\"-infinity\")\n        Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n        if Aleft <= Bright and Bleft <= Aright:\n            if total % 2:\n                return min(Aright, Bright)\n            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n        elif Aleft > Bright:\n            r = i - 1\n        else:\n            l = i + 1"
                }
            ]
        }
    }
}