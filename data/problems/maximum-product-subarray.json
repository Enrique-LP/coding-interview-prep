{
    "id": "maximum-product-subarray",
    "title": "Maximum Product Subarray",
    "description": "Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer.",
    "examples": [
        {
            "input": "nums = [2,3,-2,4]",
            "output": "6",
            "explanation": "[2,3] has the largest product 6."
        },
        {
            "input": "nums = [-2,0,-1]",
            "output": "0",
            "explanation": "The result cannot be 2, because [-2,-1] is not a subarray."
        }
    ],
    "constraints": [
        "1 <= nums.length <= 2 * 10^4",
        "-10 <= nums[i] <= 10",
        "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
    ],
    "difficulty": "Medium",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Nested Loops",
            "description": "Check all subarrays.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_product that takes nums.",
                    "placeholderCode": "def max_product(nums):",
                    "validationRegex": "^def\\s+max_product\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_product(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize max product.",
                    "placeholderCode": "    if not nums: return 0\n    res = nums[0]",
                    "validationRegex": "^\\s+if\\s+not\\s+nums:\\s*return\\s+0\\s*res\\s*=\\s*nums\\[0\\]$",
                    "hint": "Handle empty array case. Initialize result with first element.",
                    "solutionCode": "    if not nums: return 0\n    res = nums[0]"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through all subarrays.",
                    "placeholderCode": "    for i in range(len(nums)):\n        curr = 1\n        for j in range(i, len(nums)):\n            curr *= nums[j]\n            res = max(res, curr)",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\):\\s*curr\\s*=\\s*1\\s*for\\s+j\\s+in\\s+range\\(i,\\s*len\\(nums\\)\\):\\s*curr\\s*\\*=\\s*nums\\[j\\]\\s*res\\s*=\\s*max\\(res,\\s*curr\\)$",
                    "hint": "Double loop to generate all subarrays. Calculate product for each and update max.\\n\\nExample:\\nNums=[2, 3].\\ni=0: j=0 -> 2. j=1 -> 2*3=6.\\ni=1: j=1 -> 3.\\nMax is 6.",
                    "solutionCode": "    for i in range(len(nums)):\n        curr = 1\n        for j in range(i, len(nums)):\n            curr *= nums[j]\n            res = max(res, curr)"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the maximum product found.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "DP (Iterative)",
            "description": "Track min and max product ending at each position.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_product that takes nums.",
                    "placeholderCode": "def max_product(nums):",
                    "validationRegex": "^def\\s+max_product\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_product(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result and current min/max.",
                    "placeholderCode": "    res = max(nums)\n    curMin, curMax = 1, 1",
                    "validationRegex": "^\\s+res\\s*=\\s*max\\(nums\\)\\s*curMin,\\s*curMax\\s*=\\s*1,\\s*1$",
                    "hint": "Initialize result to max element in nums (handles single negative number case). Initialize curMin and curMax to 1.",
                    "solutionCode": "    res = max(nums)\n    curMin, curMax = 1, 1"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through nums.",
                    "placeholderCode": "    for n in nums:\n        if n == 0:\n            curMin, curMax = 1, 1\n            continue",
                    "validationRegex": "^\\s+for\\s+n\\s+in\\s+nums:\\s*if\\s+n\\s*==\\s*0:\\s*curMin,\\s*curMax\\s*=\\s*1,\\s*1\\s*continue$",
                    "hint": "Iterate. If number is 0, reset curMin/curMax to 1 (subarray break).",
                    "solutionCode": "    for n in nums:\n        if n == 0:\n            curMin, curMax = 1, 1\n            continue"
                },
                {
                    "id": 4,
                    "instruction": "Update min and max products.",
                    "placeholderCode": "        tmp = curMax * n\n        curMax = max(n * curMax, n * curMin, n)\n        curMin = min(tmp, n * curMin, n)",
                    "validationRegex": "^\\s+tmp\\s*=\\s*curMax\\s*\\*\\s*n\\s*curMax\\s*=\\s*max\\(n\\s*\\*\\s*curMax,\\s*n\\s*\\*\\s*curMin,\\s*n\\)\\s*curMin\\s*=\\s*min\\(tmp,\\s*n\\s*\\*\\s*curMin,\\s*n\\)$",
                    "hint": "Update curMax and curMin. Since n can be negative, multiplying by curMin could yield a new max. Consider n itself as start of new subarray.\\n\\nExample:\\nNums=[2, 3, -2].\\nInit: Res=2, Min=1, Max=1.\\nN=2: Max=2, Min=2. Res=2.\\nN=3: Max=6, Min=3. Res=6.\\nN=-2: Tmp=6*-2=-12. Max=max(-12, 3*-2, -2)=-2. Min=min(-12, -6, -2)=-12. Res=6.",
                    "solutionCode": "        tmp = curMax * n\n        curMax = max(n * curMax, n * curMin, n)\n        curMin = min(tmp, n * curMin, n)"
                },
                {
                    "id": 5,
                    "instruction": "Update result.",
                    "placeholderCode": "        res = max(res, curMax)",
                    "validationRegex": "^\\s+res\\s*=\\s*max\\(res,\\s*curMax\\)$",
                    "hint": "Update global result with current max.",
                    "solutionCode": "        res = max(res, curMax)"
                },
                {
                    "id": 6,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the maximum product found.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}