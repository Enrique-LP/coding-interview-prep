{
    "id": "target-sum",
    "title": "Target Sum",
    "description": "You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers. Return the number of different expressions that you can build, which evaluates to target.",
    "examples": [
        {
            "input": "nums = [1,1,1,1,1], target = 3",
            "output": "5",
            "explanation": "-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3"
        },
        {
            "input": "nums = [1], target = 1",
            "output": "1"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 20",
        "0 <= nums[i] <= 1000",
        "0 <= sum(nums[i]) <= 1000",
        "-1000 <= target <= 1000"
    ],
    "difficulty": "Medium",
    "topic": "2-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Recursive",
            "description": "Recursively try + and -.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_target_sum_ways that takes nums and target.",
                    "placeholderCode": "def find_target_sum_ways(nums, target):",
                    "validationRegex": "^def\\s+find_target_sum_ways\\(nums,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_target_sum_ways(nums, target):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(i, total):\n        if i == len(nums):\n            return 1 if total == target else 0\n        if (i, total) in memo: return memo[(i, total)]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i,\\s*total\\):\\s*if\\s+i\\s*==\\s*len\\(nums\\):\\s*return\\s+1\\s+if\\s+total\\s*==\\s*target\\s+else\\s+0\\s*if\\s*\\(i,\\s*total\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(i,\\s*total\\)\\]$",
                    "hint": "Recursive function `dfs(i, total)` returns ways to reach target from index `i` with current sum `total`. Base case: end of nums -> check if total == target. Check memo.\\n\\nExample:\\nNums=[1], Target=1.\\nDFS(0, 0): DFS(1, 1) + DFS(1, -1).\\n  DFS(1, 1): Total=1=Target. Return 1.\\n  DFS(1, -1): Total=-1!=Target. Return 0.",
                    "solutionCode": "    memo = {}\n    def dfs(i, total):\n        if i == len(nums):\n            return 1 if total == target else 0\n        if (i, total) in memo: return memo[(i, total)]"
                },
                {
                    "id": 3,
                    "instruction": "Sum results of adding and subtracting.",
                    "placeholderCode": "        res = dfs(i + 1, total + nums[i]) + dfs(i + 1, total - nums[i])\n        memo[(i, total)] = res\n        return res",
                    "validationRegex": "^\\s+res\\s*=\\s*dfs\\(i\\s*\\+\\s*1,\\s*total\\s*\\+\\s*nums\\[i\\]\\)\\s*\\+\\s*dfs\\(i\\s*\\+\\s*1,\\s*total\\s*-\\s*nums\\[i\\]\\)\\s*memo\\[\\(i,\\s*total\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Try adding current number and subtracting current number. Sum the results.",
                    "solutionCode": "        res = dfs(i + 1, total + nums[i]) + dfs(i + 1, total - nums[i])\n        memo[(i, total)] = res\n        return res"
                },
                {
                    "id": 4,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start recursion from index 0 with sum 0.",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "DP (Iterative)",
            "description": "Track counts of each sum.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_target_sum_ways that takes nums and target.",
                    "placeholderCode": "def find_target_sum_ways(nums, target):",
                    "validationRegex": "^def\\s+find_target_sum_ways\\(nums,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_target_sum_ways(nums, target):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize DP dictionary.",
                    "placeholderCode": "    dp = {0: 1}",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\{0:\\s*1\\}$",
                    "hint": "Use a dictionary `dp` to map sum -> count of ways. Start with sum 0 having 1 way.",
                    "solutionCode": "    dp = {0: 1}"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through nums.",
                    "placeholderCode": "    for n in nums:\n        next_dp = {}\n        for total, count in dp.items():\n            next_dp[total + n] = next_dp.get(total + n, 0) + count\n            next_dp[total - n] = next_dp.get(total - n, 0) + count\n        dp = next_dp",
                    "validationRegex": "^\\s+for\\s+n\\s+in\\s+nums:\\s*next_dp\\s*=\\s*\\{\\}\\s*for\\s+total,\\s*count\\s+in\\s+dp\\.items\\(\\):\\s*next_dp\\[total\\s*\\+\\s*n\\]\\s*=\\s*next_dp\\.get\\(total\\s*\\+\\s*n,\\s*0\\)\\s*\\+\\s*count\\s*next_dp\\[total\\s*-\\s*n\\]\\s*=\\s*next_dp\\.get\\(total\\s*-\\s*n,\\s*0\\)\\s*\\+\\s*count\\s*dp\\s*=\\s*next_dp$",
                    "hint": "For each number, update the possible sums. New sums are `total + n` and `total - n`.\\n\\nExample:\\nNums=[1, 1], Target=0.\\nInit: DP={0: 1}.\\nN=1: Next={1: 1, -1: 1}.\\nN=1: Next={2: 1, 0: 1, 0: 1, -2: 1} -> {2: 1, 0: 2, -2: 1}.\\nResult: DP[0] = 2.",
                    "solutionCode": "    for n in nums:\n        next_dp = {}\n        for total, count in dp.items():\n            next_dp[total + n] = next_dp.get(total + n, 0) + count\n            next_dp[total - n] = next_dp.get(total - n, 0) + count\n        dp = next_dp"
                },
                {
                    "id": 4,
                    "instruction": "Return result for target.",
                    "placeholderCode": "    return dp.get(target, 0)",
                    "validationRegex": "^\\s+return\\s+dp\\.get\\(target,\\s*0\\)$",
                    "hint": "Return the count of ways to reach `target`.",
                    "solutionCode": "    return dp.get(target, 0)"
                }
            ]
        }
    }
}