{
    "id": "target-sum",
    "title": "Target Sum",
    "description": "You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers. Return the number of different expressions that you can build, which evaluates to target.",
    "examples": [
        {
            "input": "nums = [1,1,1,1,1], target = 3",
            "output": "5",
            "explanation": "-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3"
        },
        {
            "input": "nums = [1], target = 1",
            "output": "1"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 20",
        "0 <= nums[i] <= 1000",
        "0 <= sum(nums[i]) <= 1000",
        "-1000 <= target <= 1000"
    ],
    "difficulty": "Medium",
    "topic": "2-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively explore all possible combinations of adding or subtracting each number from the target using memoization.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_target_sum_ways that takes nums and target.",
                    "placeholderCode": "def find_target_sum_ways(nums, target):",
                    "validationRegex": "^def\\s+find_target_sum_ways\\(nums,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_target_sum_ways(nums, target):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(i, total):\n        if i == len(nums):\n            return 1 if total == target else 0\n        if (i, total) in memo: return memo[(i, total)]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i,\\s*total\\):\\s*if\\s+i\\s*==\\s*len\\(nums\\):\\s*return\\s+1\\s+if\\s+total\\s*==\\s*target\\s+else\\s+0\\s*if\\s*\\(i,\\s*total\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(i,\\s*total\\)\\]$",
                    "hint": "Recursive function `dfs(i, total)` returns ways to reach target from index `i` with current sum `total`. Base case: end of nums -> check if total == target. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(i, total):\n        if i == len(nums):\n            return 1 if total == target else 0\n        if (i, total) in memo: return memo[(i, total)]"
                },
                {
                    "id": 3,
                    "instruction": "Sum results of adding and subtracting.",
                    "placeholderCode": "        res = dfs(i + 1, total + nums[i]) + dfs(i + 1, total - nums[i])\n        memo[(i, total)] = res\n        return res",
                    "validationRegex": "^\\s+res\\s*=\\s*dfs\\(i\\s*\\+\\s*1,\\s*total\\s*\\+\\s*nums\\[i\\]\\)\\s*\\+\\s*dfs\\(i\\s*\\+\\s*1,\\s*total\\s*-\\s*nums\\[i\\]\\)\\s*memo\\[\\(i,\\s*total\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Try adding current number and subtracting current number. Sum the results.",
                    "solutionCode": "        res = dfs(i + 1, total + nums[i]) + dfs(i + 1, total - nums[i])\n        memo[(i, total)] = res\n        return res"
                },
                {
                    "id": 4,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start recursion from index 0 with sum 0.",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iterative dynamic programming approach using a dictionary to map possible sums to the number of ways to achieve them.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_target_sum_ways that takes nums and target.",
                    "placeholderCode": "def find_target_sum_ways(nums, target):",
                    "validationRegex": "^def\\s+find_target_sum_ways\\(nums,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_target_sum_ways(nums, target):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP dictionary with sum 0 having 1 way.",
                    "placeholderCode": "    dp = {0: 1}",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\{0:\\s*1\\}$",
                    "hint": "The dictionary will track 'sum: number_of_ways'. Starting at 0 ways for 0 sum.",
                    "solutionCode": "    dp = {0: 1}"
                },
                {
                    "id": 3,
                    "instruction": "Initiate a loop to iterate through each number 'n' in 'nums'.",
                    "placeholderCode": "    for n in nums:",
                    "validationRegex": "^\\s+for\\s+n\\s+in\\s+nums:$",
                    "hint": "Each number can either be added or subtracted to influence the total sum.",
                    "solutionCode": "    for n in nums:"
                },
                {
                    "id": 4,
                    "instruction": "Initialize a dictionary 'next_dp' to store sum counts for the next iteration.",
                    "placeholderCode": "        next_dp = {}",
                    "validationRegex": "^\\s+next_dp\\s*=\\s*\\{\\}$",
                    "hint": "This will hold the updated counts after applying the current number 'n'.",
                    "solutionCode": "        next_dp = {}"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through the current sums and their counts in the 'dp' dictionary.",
                    "placeholderCode": "        for total, count in dp.items():",
                    "validationRegex": "^\\s+for\\s+total,\\s*count\\s+in\\s+dp\\.items\\(\\):$",
                    "hint": "We apply the current number 'n' to every sum reached so far.",
                    "solutionCode": "        for total, count in dp.items():"
                },
                {
                    "id": 6,
                    "instruction": "Update 'next_dp' by adding the current count to the result of 'total + n'.",
                    "placeholderCode": "            next_dp[total + n] = next_dp.get(total + n, 0) + count",
                    "validationRegex": "^\\s+next_dp\\[total\\s*\\+\\s*n\\]\\s*=\\s*next_dp\\.get\\(total\\s*\\+\\s*n,\\s*0\\)\\s*\\+\\s*count$",
                    "hint": "Adding 'n' to 'total' creates a new set of possible expressions.",
                    "solutionCode": "            next_dp[total + n] = next_dp.get(total + n, 0) + count"
                },
                {
                    "id": 7,
                    "instruction": "Update 'next_dp' by adding the current count to the result of 'total - n'.",
                    "placeholderCode": "            next_dp[total - n] = next_dp.get(total - n, 0) + count",
                    "validationRegex": "^\\s+next_dp\\[total\\s*-\\s*n\\]\\s*=\\s*next_dp\\.get\\(total\\s*-\\s*n,\\s*0\\)\\s*\\+\\s*count$",
                    "hint": "Subtracting 'n' from 'total' is the other possible expression for this number.",
                    "solutionCode": "            next_dp[total - n] = next_dp.get(total - n, 0) + count"
                },
                {
                    "id": 8,
                    "instruction": "Replace the 'dp' dictionary with 'next_dp' to prepare for the next number in 'nums'.",
                    "placeholderCode": "        dp = next_dp",
                    "validationRegex": "^\\s+dp\\s*=\\s*next_dp$",
                    "hint": "We carry forward only the results after the latest number has been processed.",
                    "solutionCode": "        dp = next_dp"
                },
                {
                    "id": 9,
                    "instruction": "Return the number of ways to achieve the target sum, or 0 if it's not possible.",
                    "placeholderCode": "    return dp.get(target, 0)",
                    "validationRegex": "^\\s+return\\s+dp\\.get\\(target,\\s*0\\)$",
                    "hint": "The count of ways to reach 'target' is stored in the DP dictionary.",
                    "solutionCode": "    return dp.get(target, 0)"
                }
            ]
        }
    }
}