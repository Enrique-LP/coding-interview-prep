{
    "id": "longest-common-subsequence",
    "title": "Longest Common Subsequence",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.",
    "examples": [
        {
            "input": "text1 = \"abcde\", text2 = \"ace\"",
            "output": "3",
            "explanation": "The longest common subsequence is \"ace\" and its length is 3."
        },
        {
            "input": "text1 = \"abc\", text2 = \"abc\"",
            "output": "3"
        }
    ],
    "constraints": [
        "1 <= text1.length, text2.length <= 1000",
        "text1 and text2 consist of only lowercase English characters."
    ],
    "difficulty": "Medium",
    "topic": "2-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively check matching characters using memoization to find the longest common subsequence.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function longest_common_subsequence that takes text1 and text2.",
                    "placeholderCode": "def longest_common_subsequence(text1, text2):",
                    "validationRegex": "^def\\s+longest_common_subsequence\\(text1,\\s*text2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def longest_common_subsequence(text1, text2):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(i, j):\n        if i == len(text1) or j == len(text2): return 0\n        if (i, j) in memo: return memo[(i, j)]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i,\\s*j\\):\\s*if\\s+i\\s*==\\s*len\\(text1\\)\\s+or\\s+j\\s*==\\s*len\\(text2\\):\\s*return\\s+0\\s*if\\s*\\(i,\\s*j\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(i,\\s*j\\)\\]$",
                    "hint": "Recursive function `dfs(i, j)` returns LCS of text1[i:] and text2[j:]. Base case: end of either string -> 0. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(i, j):\n        if i == len(text1) or j == len(text2): return 0\n        if (i, j) in memo: return memo[(i, j)]"
                },
                {
                    "id": 3,
                    "instruction": "If match, add 1 and recurse diagonals.",
                    "placeholderCode": "        if text1[i] == text2[j]:\n            res = 1 + dfs(i + 1, j + 1)",
                    "validationRegex": "^\\s+if\\s+text1\\[i\\]\\s*==\\s+text2\\[j\\]:\\s*res\\s*=\\s*1\\s*\\+\\s*dfs\\(i\\s*\\+\\s*1,\\s*j\\s*\\+\\s*1\\)$",
                    "hint": "If characters match, they are part of LCS. Add 1 and move both pointers.",
                    "solutionCode": "        if text1[i] == text2[j]:\n            res = 1 + dfs(i + 1, j + 1)"
                },
                {
                    "id": 4,
                    "instruction": "If no match, take max of skipping one char from either string.",
                    "placeholderCode": "        else:\n            res = max(dfs(i + 1, j), dfs(i, j + 1))",
                    "validationRegex": "^\\s+else:\\s*res\\s*=\\s*max\\(dfs\\(i\\s*\\+\\s*1,\\s*j\\),\\s*dfs\\(i,\\s*j\\s*\\+\\s*1\\)\\)$",
                    "hint": "If characters don't match, either skip char from text1 or text2. Take max result.",
                    "solutionCode": "        else:\n            res = max(dfs(i + 1, j), dfs(i, j + 1))"
                },
                {
                    "id": 5,
                    "instruction": "Memoize and return.",
                    "placeholderCode": "        memo[(i, j)] = res\n        return res",
                    "validationRegex": "^\\s+memo\\[\\(i,\\s*j\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in memo and return.",
                    "solutionCode": "        memo[(i, j)] = res\n        return res"
                },
                {
                    "id": 6,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start recursion from beginning of both strings.",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iterative dynamic programming approach using a 2D table to build the solution bottom-up O(n*m).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function longest_common_subsequence that takes text1 and text2.",
                    "placeholderCode": "def longest_common_subsequence(text1, text2):",
                    "validationRegex": "^def\\s+longest_common_subsequence\\(text1,\\s*text2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def longest_common_subsequence(text1, text2):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP grid with zeros, having dimensions (len(text1) + 1) by (len(text2) + 1).",
                    "placeholderCode": "    dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)]",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[\\[0\\s+for\\s+j\\s+in\\s+range\\(len\\(text2\\)\\s*\\+\\s*1\\)\\]\\s+for\\s+i\\s+in\\s+range\\(len\\(text1\\)\\s*\\+\\s*1\\)\\]$",
                    "hint": "The grid will store the LCS lengths for all possible suffixes.",
                    "solutionCode": "    dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)]"
                },
                {
                    "id": 3,
                    "instruction": "Initiate a loop to iterate backwards through the indices of the first string.",
                    "placeholderCode": "    for i in range(len(text1) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(text1\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "Starting from the end allows us to build the solution bottom-up.",
                    "solutionCode": "    for i in range(len(text1) - 1, -1, -1):"
                },
                {
                    "id": 4,
                    "instruction": "Inside the first loop, initiate a second loop to iterate backwards through the indices of the second string.",
                    "placeholderCode": "        for j in range(len(text2) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(len\\(text2\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "We compare every character of the first string against every character of the second string.",
                    "solutionCode": "        for j in range(len(text2) - 1, -1, -1):"
                },
                {
                    "id": 5,
                    "instruction": "Check if the characters at current indices 'i' and 'j' match.",
                    "placeholderCode": "            if text1[i] == text2[j]:",
                    "validationRegex": "^\\s+if\\s+text1\\[i\\]\\s*==\\s+text2\\[j\\]:$",
                    "hint": "A match means this character contributes to the length of the subsequence.",
                    "solutionCode": "            if text1[i] == text2[j]:"
                },
                {
                    "id": 6,
                    "instruction": "If the characters match, update the DP table by adding 1 to the result of skipping both characters.",
                    "placeholderCode": "                dp[i][j] = 1 + dp[i + 1][j + 1]",
                    "validationRegex": "^\\s+dp\\[i\\]\\[j\\]\\s*=\\s*1\\s*\\+\\s*dp\\[i\\s*\\+\\s*1\\]\\[j\\s*\\+\\s*1\\]$",
                    "hint": "The value at dp[i+1][j+1] represents the LCS length from the remaining suffixes.",
                    "solutionCode": "                dp[i][j] = 1 + dp[i + 1][j + 1]"
                },
                {
                    "id": 7,
                    "instruction": "If the characters do not match, begin the alternative logic.",
                    "placeholderCode": "            else:",
                    "validationRegex": "^\\s+else:$",
                    "hint": "We must choose the path that yields the longer subsequence.",
                    "solutionCode": "            else:"
                },
                {
                    "id": 8,
                    "instruction": "Update the DP table by taking the maximum result of skipping one character from either string.",
                    "placeholderCode": "                dp[i][j] = max(dp[i][j + 1], dp[i + 1][j])",
                    "validationRegex": "^\\s+dp\\[i\\]\\[j\\]\\s*=\\s*max\\(dp\\[i\\]\\[j\\s*\\+\\s*1\\],\\s*dp\\[i\\s*\\+\\s*1\\]\\[j\\]\\)$",
                    "hint": "We look at the previously computed results to find the maximum possible LCS length.",
                    "solutionCode": "                dp[i][j] = max(dp[i][j + 1], dp[i + 1][j])"
                },
                {
                    "id": 9,
                    "instruction": "Return the final LCS length stored at the beginning of the grid.",
                    "placeholderCode": "    return dp[0][0]",
                    "validationRegex": "^\\s+return\\s+dp\\[0\\]\\[0\\]$",
                    "hint": "The answer is now stored in the first cell of the DP table.",
                    "solutionCode": "    return dp[0][0]"
                }
            ]
        }
    }
}