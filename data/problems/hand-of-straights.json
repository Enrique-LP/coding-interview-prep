{
    "id": "hand-of-straights",
    "title": "Hand of Straights",
    "description": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards. Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.",
    "examples": [
        {
            "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
            "output": "true",
            "explanation": "Alice's hand can be rearranged as [1,2,3],[2,3,4],[6,7,8]"
        },
        {
            "input": "hand = [1,2,3,4,5], groupSize = 4",
            "output": "false",
            "explanation": "Alice's hand can not be rearranged into groups of 4."
        }
    ],
    "constraints": [
        "1 <= hand.length <= 10^4",
        "0 <= hand[i] <= 10^9",
        "1 <= groupSize <= hand.length"
    ],
    "difficulty": "Medium",
    "topic": "Greedy",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Sort the entire hand and iteratively form groups of consecutive cards by decrementing their counts in a frequency map.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function is_n_straight_hand that takes hand and groupSize.",
                    "placeholderCode": "def is_n_straight_hand(hand, groupSize):",
                    "validationRegex": "^def\\s+is_n_straight_hand\\(hand,\\s*groupSize\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def is_n_straight_hand(hand, groupSize):"
                },
                {
                    "id": 2,
                    "instruction": "Check if the total number of cards is divisible by groupSize; if not, return False.",
                    "placeholderCode": "    if len(hand) % groupSize: return False",
                    "validationRegex": "^\\s+if\\s+len\\(hand\\)\\s*%\\s*groupSize:\\s*return\\s+False$",
                    "hint": "Groups must be exactly groupSize big.",
                    "solutionCode": "    if len(hand) % groupSize: return False"
                },
                {
                    "id": 3,
                    "instruction": "Initialize an empty dictionary to store the frequency of each card.",
                    "placeholderCode": "    count = {}",
                    "validationRegex": "^\\s+count\\s*=\\s*\\{\\}$",
                    "hint": "Create an empty hash map.",
                    "solutionCode": "    count = {}"
                },
                {
                    "id": 4,
                    "instruction": "Iterate through the hand to count the frequency of each card.",
                    "placeholderCode": "    for n in hand:\n        count[n] = count.get(n, 0) + 1",
                    "validationRegex": "^\\s+for\\s+n\\s+in\\s+hand:\\s*count\\[n\\]\\s*=\\s*count\\.get\\(n,\\s*0\\)\\s*\\+\\s*1$",
                    "hint": "Populate the frequency map.",
                    "solutionCode": "    for n in hand:\n        count[n] = count.get(n, 0) + 1"
                },
                {
                    "id": 5,
                    "instruction": "Sort the input hand array to process cards in increasing order of their values.",
                    "placeholderCode": "    hand.sort()",
                    "validationRegex": "^\\s+hand\\.sort\\(\\)$",
                    "hint": "Sorting allows us to start groups from the smallest available cards.",
                    "solutionCode": "    hand.sort()"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through the sorted hand, and for each available card, try to form a consecutive group of groupSize by checking and decrementing counts.",
                    "placeholderCode": "    for i in hand:\n        if count[i] == 0: continue\n        for j in range(groupSize):\n            if count.get(i + j, 0) == 0: return False\n            count[i + j] -= 1",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+hand:\\s*if\\s+count\\[i\\]\\s*==\\s*0:\\s*continue\\s*for\\s+j\\s+in\\s+range\\(groupSize\\):\\s*if\\s+count\\.get\\(i\\s*\\+\\s*j,\\s*0\\)\\s*==\\s*0:\\s*return\\s+False\\s*count\\[i\\s*\\+\\s*j\\]\\s*-=\\s*1$",
                    "hint": "For each card i, we need cards from i to i + groupSize - 1.",
                    "solutionCode": "    for i in hand:\n        if count[i] == 0: continue\n        for j in range(groupSize):\n            if count.get(i + j, 0) == 0: return False\n            count[i + j] -= 1"
                },
                {
                    "id": 7,
                    "instruction": "Return True if all cards have been successfully organized into valid groups.",
                    "placeholderCode": "    return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "Success case.",
                    "solutionCode": "    return True"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Efficiently form groups using a Min-Heap to always retrieve the smallest available card and a hash map for frequency tracking.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Import the heapq module to use heap operations.",
                    "placeholderCode": "import heapq",
                    "validationRegex": "^import\\s+heapq$",
                    "hint": "We need the heapq library for our min-heap.",
                    "solutionCode": "import heapq"
                },
                {
                    "id": 2,
                    "instruction": "Define the function is_n_straight_hand that takes hand and groupSize.",
                    "placeholderCode": "def is_n_straight_hand(hand, groupSize):",
                    "validationRegex": "^def\\s+is_n_straight_hand\\(hand,\\s*groupSize\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def is_n_straight_hand(hand, groupSize):"
                },
                {
                    "id": 3,
                    "instruction": "Check if the total number of cards is divisible by groupSize; if not, return False.",
                    "placeholderCode": "    if len(hand) % groupSize: return False",
                    "validationRegex": "^\\s+if\\s+len\\(hand\\)\\s*%\\s*groupSize:\\s*return\\s+False$",
                    "hint": "Every group must have exactly groupSize cards.",
                    "solutionCode": "    if len(hand) % groupSize: return False"
                },
                {
                    "id": 4,
                    "instruction": "Initialize an empty hash map 'count' to store card frequencies.",
                    "placeholderCode": "    count = {}",
                    "validationRegex": "^\\s+count\\s*=\\s*\\{\\}$",
                    "hint": "This will track how many of each card we have left.",
                    "solutionCode": "    count = {}"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through the hand to populate the frequency map.",
                    "placeholderCode": "    for n in hand:",
                    "validationRegex": "^\\s+for\\s+n\\s+in\\s+hand:$",
                    "hint": "Count each card's occurrence.",
                    "solutionCode": "    for n in hand:"
                },
                {
                    "id": 6,
                    "instruction": "Update the count for the current card in the hash map.",
                    "placeholderCode": "        count[n] = count.get(n, 0) + 1",
                    "validationRegex": "^\\s+count\\[n\\]\\s*=\\s*count\\.get\\(n,\\s*0\\)\\s*\\+\\s*1$",
                    "hint": "Increment the value for key 'n'.",
                    "solutionCode": "        count[n] = count.get(n, 0) + 1"
                },
                {
                    "id": 7,
                    "instruction": "Create a list 'minH' containing the unique card values from the count keys.",
                    "placeholderCode": "    minH = list(count.keys())",
                    "validationRegex": "^\\s+minH\\s*=\\s*list\\(count\\.keys\\(\\)\\)$",
                    "hint": "We only need one of each value in the heap.",
                    "solutionCode": "    minH = list(count.keys())"
                },
                {
                    "id": 8,
                    "instruction": "Transform the list 'minH' into a min-heap.",
                    "placeholderCode": "    heapq.heapify(minH)",
                    "validationRegex": "^\\s+heapq\\.heapify\\(minH\\)$",
                    "hint": "Heapify will organize the list so the smallest element is always at index 0.",
                    "solutionCode": "    heapq.heapify(minH)"
                },
                {
                    "id": 9,
                    "instruction": "Initiate a while loop to process cards as long as the heap is not empty.",
                    "placeholderCode": "    while minH:",
                    "validationRegex": "^\\s+while\\s+minH:$",
                    "hint": "Continue forming groups until all cards are used.",
                    "solutionCode": "    while minH:"
                },
                {
                    "id": 10,
                    "instruction": "Peek at the smallest available card value in the heap to use as the starting point of a group.",
                    "placeholderCode": "        first = minH[0]",
                    "validationRegex": "^\\s+first\\s*=\\s*minH\\[0\\]$",
                    "hint": "The smallest card must start a consecutive group.",
                    "solutionCode": "        first = minH[0]"
                },
                {
                    "id": 11,
                    "instruction": "Iterate through the expected consecutive values from 'first' to 'first + groupSize - 1'.",
                    "placeholderCode": "        for i in range(first, first + groupSize):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(first,\\s*first\\s*\\+\\s*groupSize\\):$",
                    "hint": "Try to find each card needed for the group.",
                    "solutionCode": "        for i in range(first, first + groupSize):"
                },
                {
                    "id": 12,
                    "instruction": "Check if the required card exists in our counts; if not, return False.",
                    "placeholderCode": "            if i not in count: return False",
                    "validationRegex": "^\\s+if\\s+i\\s+not\\s+in\\s+count:\\s*return\\s+False$",
                    "hint": "If a consecutive card is missing, we can't form the group.",
                    "solutionCode": "            if i not in count: return False"
                },
                {
                    "id": 13,
                    "instruction": "Decrement the frequency of the current card as it has been used in a group.",
                    "placeholderCode": "            count[i] -= 1",
                    "validationRegex": "^\\s+count\\[i\\]\\s*-=\\s*1$",
                    "hint": "Mark the card as used.",
                    "solutionCode": "            count[i] -= 1"
                },
                {
                    "id": 14,
                    "instruction": "If the count of a card becomes zero, check if it is the current minimum in the heap and remove it.",
                    "placeholderCode": "            if count[i] == 0:\n                if i != minH[0]: return False\n                heapq.heappop(minH)",
                    "validationRegex": "^\\s+if\\s+count\\[i\\]\\s*==\\s*0:\\s*if\\s+i\\s*!=\\s*minH\\[0\\]:\\s*return\\s+False\\s*heapq\\.heappop\\(minH\\)$",
                    "hint": "If we use up all instances of a card, it MUST be the smallest one in our heap to keep the sequence valid. Pop it from the heap.",
                    "solutionCode": "            if count[i] == 0:\n                if i != minH[0]: return False\n                heapq.heappop(minH)"
                },
                {
                    "id": 15,
                    "instruction": "Return True after successfully forming all required groups.",
                    "placeholderCode": "    return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "All groups were formed correctly.",
                    "solutionCode": "    return True"
                }
            ]
        }
    }
}