{
    "id": "binary-search",
    "title": "Binary Search",
    "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.",
    "examples": [
        {
            "input": "nums = [-1,0,3,5,9,12], target = 9",
            "output": "4",
            "explanation": "9 exists in nums and its index is 4"
        },
        {
            "input": "nums = [-1,0,3,5,9,12], target = 2",
            "output": "-1",
            "explanation": "2 does not exist in nums so return -1"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 10^4",
        "-10^4 <= nums[i], target <= 10^4",
        "All the integers in nums are unique.",
        "nums is sorted in ascending order."
    ],
    "difficulty": "Easy",
    "topic": "Binary Search",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Linear Search",
            "description": "Check every element. (O(n))",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function search that takes nums and target.",
                    "placeholderCode": "def search(nums, target):",
                    "validationRegex": "^def\\s+search\\(nums,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def search(nums, target):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate through the array.",
                    "placeholderCode": "    for i, n in enumerate(nums):",
                    "validationRegex": "^\\s+for\\s+i,\\s*n\\s+in\\s+enumerate\\(nums\\):$",
                    "hint": "Iterate using `enumerate` to get index and value.",
                    "solutionCode": "    for i, n in enumerate(nums):"
                },
                {
                    "id": 3,
                    "instruction": "If element equals target, return index.",
                    "placeholderCode": "        if n == target:\n            return i",
                    "validationRegex": "^\\s+if\\s+n\\s*==\\s*target:\\s*return\\s+i$",
                    "hint": "Check if current element matches target.",
                    "solutionCode": "        if n == target:\n            return i"
                },
                {
                    "id": 4,
                    "instruction": "Return -1 if not found.",
                    "placeholderCode": "    return -1",
                    "validationRegex": "^\\s+return\\s+-1$",
                    "hint": "Return -1 if loop completes without finding target.",
                    "solutionCode": "    return -1"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Binary Search",
            "description": "Divide search space in half. (O(log n))",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function search that takes nums and target.",
                    "placeholderCode": "def search(nums, target):",
                    "validationRegex": "^def\\s+search\\(nums,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def search(nums, target):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize left and right pointers.",
                    "placeholderCode": "    l, r = 0, len(nums) - 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(nums\\)\\s*-\\s*1$",
                    "hint": "Set `l` to 0 and `r` to last index.",
                    "solutionCode": "    l, r = 0, len(nums) - 1"
                },
                {
                    "id": 3,
                    "instruction": "Loop while l <= r.",
                    "placeholderCode": "    while l <= r:",
                    "validationRegex": "^\\s+while\\s+l\\s*<=\\s*r:$",
                    "hint": "Loop while search space is valid.",
                    "solutionCode": "    while l <= r:"
                },
                {
                    "id": 4,
                    "instruction": "Calculate mid index.",
                    "placeholderCode": "        mid = (l + r) // 2",
                    "validationRegex": "^\\s+mid\\s*=\\s*\\(l\\s*\\+\\s*r\\)\\s*//\\s*2$",
                    "hint": "Calculate middle index.",
                    "solutionCode": "        mid = (l + r) // 2"
                },
                {
                    "id": 5,
                    "instruction": "If mid value > target, move right pointer.",
                    "placeholderCode": "        if nums[mid] > target:\n            r = mid - 1",
                    "validationRegex": "^\\s+if\\s+nums\\[mid\\]\\s*>\\s+target:\\s*r\\s*=\\s*mid\\s*-\\s*1$",
                    "hint": "If `nums[mid] > target`, search left half.\\n\\nExample:\\nnums=[-1, 0, 3, 5, 9, 12], target=9.\\nl=0, r=5, mid=2 (val=3). 3 < 9. Search right.\\nl=3, r=5, mid=4 (val=9). 9 == 9. Found.",
                    "solutionCode": "        if nums[mid] > target:\n            r = mid - 1"
                },
                {
                    "id": 6,
                    "instruction": "If mid value < target, move left pointer.",
                    "placeholderCode": "        elif nums[mid] < target:\n            l = mid + 1",
                    "validationRegex": "^\\s+elif\\s+nums\\[mid\\]\\s*<\\s+target:\\s*l\\s*=\\s*mid\\s*\\+\\s*1$",
                    "hint": "If `nums[mid] < target`, search right half.",
                    "solutionCode": "        elif nums[mid] < target:\n            l = mid + 1"
                },
                {
                    "id": 7,
                    "instruction": "If found, return mid.",
                    "placeholderCode": "        else:\n            return mid",
                    "validationRegex": "^\\s+else:\\s*return\\s+mid$",
                    "hint": "Target found, return index.",
                    "solutionCode": "        else:\n            return mid"
                },
                {
                    "id": 8,
                    "instruction": "Return -1 if loop finishes.",
                    "placeholderCode": "    return -1",
                    "validationRegex": "^\\s+return\\s+-1$",
                    "hint": "Return -1 if not found.",
                    "solutionCode": "    return -1"
                }
            ]
        }
    }
}