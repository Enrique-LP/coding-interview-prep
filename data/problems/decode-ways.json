{
    "id": "decode-ways",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> \"1\", 'B' -> \"2\", ... 'Z' -> \"26\". To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into: \"AAJF\" with the grouping (1 1 10 6), \"KJF\" with the grouping (11 10 6). Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\". Given a string s containing only digits, return the number of ways to decode it.",
    "examples": [
        {
            "input": "s = \"12\"",
            "output": "2",
            "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."
        },
        {
            "input": "s = \"226\"",
            "output": "3",
            "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
        },
        {
            "input": "s = \"06\"",
            "output": "0"
        }
    ],
    "constraints": [
        "1 <= s.length <= 100",
        "s contains only digits and may contain leading zero(s)."
    ],
    "difficulty": "Medium",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Recursive",
            "description": "Recursively check 1 or 2 digit decodings.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function num_decodings that takes s.",
                    "placeholderCode": "def num_decodings(s):",
                    "validationRegex": "^def\\s+num_decodings\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def num_decodings(s):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    dp = {len(s): 1}\n    def dfs(i):\n        if i in dp: return dp[i]\n        if s[i] == \"0\": return 0",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\{len\\(s\\):\\s*1\\}\\s*def\\s+dfs\\(i\\):\\s*if\\s+i\\s+in\\s+dp:\\s*return\\s+dp\\[i\\]\\s*if\\s+s\\[i\\]\\s*==\\s*\"0\":\\s*return\\s+0$",
                    "hint": "Use a dictionary `dp` for memoization. Base case: if index reaches end of string, return 1 (valid decoding). If current char is '0', return 0 (invalid).",
                    "solutionCode": "    dp = {len(s): 1}\n    def dfs(i):\n        if i in dp: return dp[i]\n        if s[i] == \"0\": return 0"
                },
                {
                    "id": 3,
                    "instruction": "Check single digit decoding.",
                    "placeholderCode": "        res = dfs(i + 1)",
                    "validationRegex": "^\\s+res\\s*=\\s*dfs\\(i\\s*\\+\\s*1\\)$",
                    "hint": "Recursively call for the next character (single digit decoding).",
                    "solutionCode": "        res = dfs(i + 1)"
                },
                {
                    "id": 4,
                    "instruction": "Check two digit decoding.",
                    "placeholderCode": "        if (i + 1 < len(s) and (s[i] == \"1\" or\n            (s[i] == \"2\" and s[i + 1] in \"0123456\"))):\n            res += dfs(i + 2)",
                    "validationRegex": "^\\s+if\\s*\\(i\\s*\\+\\s*1\\s*<\\s+len\\(s\\)\\s+and\\s*\\(s\\[i\\]\\s*==\\s*\"1\"\\s+or\\s*\\(s\\[i\\]\\s*==\\s*\"2\"\\s+and\\s+s\\[i\\s*\\+\\s*1\\]\\s+in\\s*\"0123456\"\\)\\)\\):\\s*res\\s*\\+=\\s*dfs\\(i\\s*\\+\\s*2\\)$",
                    "hint": "If two digits form a valid number (10-26), add the result of dfs(i + 2).",
                    "solutionCode": "        if (i + 1 < len(s) and (s[i] == \"1\" or\n            (s[i] == \"2\" and s[i + 1] in \"0123456\"))):\n            res += dfs(i + 2)"
                },
                {
                    "id": 5,
                    "instruction": "Store result in memoization table and return.",
                    "placeholderCode": "        dp[i] = res\n        return res",
                    "validationRegex": "^\\s+dp\\[i\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in `dp` and return it.",
                    "solutionCode": "        dp[i] = res\n        return res"
                },
                {
                    "id": 6,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0\\)$",
                    "hint": "Start recursion from index 0.",
                    "solutionCode": "    return dfs(0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "DP (Iterative)",
            "description": "Iterate backwards to find decodings.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function num_decodings that takes s.",
                    "placeholderCode": "def num_decodings(s):",
                    "validationRegex": "^def\\s+num_decodings\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def num_decodings(s):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize DP map.",
                    "placeholderCode": "    dp = {len(s): 1}",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\{len\\(s\\):\\s*1\\}$",
                    "hint": "Initialize DP map with base case: empty string has 1 way to decode.",
                    "solutionCode": "    dp = {len(s): 1}"
                },
                {
                    "id": 3,
                    "instruction": "Iterate backwards through string.",
                    "placeholderCode": "    for i in range(len(s) - 1, -1, -1):\n        if s[i] == \"0\":\n            dp[i] = 0\n        else:\n            dp[i] = dp[i + 1]",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):\\s*if\\s+s\\[i\\]\\s*==\\s*\"0\":\\s*dp\\[i\\]\\s*=\\s*0\\s*else:\\s*dp\\[i\\]\\s*=\\s*dp\\[i\\s*\\+\\s*1\\]$",
                    "hint": "Iterate backwards. If char is '0', ways is 0. Else, it's at least equal to ways for next char (single digit).\\n\\nExample:\\nS=\"12\". DP=[0, 0, 1].\\ni=1 ('2'): DP[1] = DP[2] = 1.\\ni=0 ('1'): DP[0] = DP[1] = 1. Check \"12\": Valid. DP[0] += DP[2] -> 2.\\nResult: 2.",
                    "solutionCode": "    for i in range(len(s) - 1, -1, -1):\n        if s[i] == \"0\":\n            dp[i] = 0\n        else:\n            dp[i] = dp[i + 1]"
                },
                {
                    "id": 4,
                    "instruction": "Check two digit decoding.",
                    "placeholderCode": "        if (i + 1 < len(s) and (s[i] == \"1\" or\n            (s[i] == \"2\" and s[i + 1] in \"0123456\"))):\n            dp[i] += dp[i + 2]",
                    "validationRegex": "^\\s+if\\s*\\(i\\s*\\+\\s*1\\s*<\\s+len\\(s\\)\\s+and\\s*\\(s\\[i\\]\\s*==\\s*\"1\"\\s+or\\s*\\(s\\[i\\]\\s*==\\s*\"2\"\\s+and\\s+s\\[i\\s*\\+\\s*1\\]\\s+in\\s*\"0123456\"\\)\\)\\):\\s*dp\\[i\\]\\s*\\+=\\s*dp\\[i\\s*\\+\\s*2\\]$",
                    "hint": "If two digits form valid number, add ways from i+2.",
                    "solutionCode": "        if (i + 1 < len(s) and (s[i] == \"1\" or\n            (s[i] == \"2\" and s[i + 1] in \"0123456\"))):\n            dp[i] += dp[i + 2]"
                },
                {
                    "id": 5,
                    "instruction": "Return result.",
                    "placeholderCode": "    return dp[0]",
                    "validationRegex": "^\\s+return\\s+dp\\[0\\]$",
                    "hint": "Return total ways starting from index 0.",
                    "solutionCode": "    return dp[0]"
                }
            ]
        }
    }
}