{
    "id": "decode-ways",
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> \"1\", 'B' -> \"2\", ... 'Z' -> \"26\". To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into: \"AAJF\" with the grouping (1 1 10 6), \"KJF\" with the grouping (11 10 6). Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\". Given a string s containing only digits, return the number of ways to decode it.",
    "examples": [
        {
            "input": "s = \"12\"",
            "output": "2",
            "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."
        },
        {
            "input": "s = \"226\"",
            "output": "3",
            "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
        },
        {
            "input": "s = \"06\"",
            "output": "0"
        }
    ],
    "constraints": [
        "1 <= s.length <= 100",
        "s contains only digits and may contain leading zero(s)."
    ],
    "difficulty": "Medium",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively check 1 or 2 digit decodings.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function num_decodings that takes s.",
                    "placeholderCode": "def num_decodings(s):",
                    "validationRegex": "^def\\s+num_decodings\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def num_decodings(s):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    dp = {len(s): 1}\n    def dfs(i):\n        if i in dp: return dp[i]\n        if s[i] == \"0\": return 0",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\{len\\(s\\):\\s*1\\}\\s*def\\s+dfs\\(i\\):\\s*if\\s+i\\s+in\\s+dp:\\s*return\\s+dp\\[i\\]\\s*if\\s+s\\[i\\]\\s*==\\s*\"0\":\\s*return\\s+0$",
                    "hint": "Use a dictionary `dp` for memoization. Base case: if index reaches end of string, return 1 (valid decoding). If current char is '0', return 0 (invalid).",
                    "solutionCode": "    dp = {len(s): 1}\n    def dfs(i):\n        if i in dp: return dp[i]\n        if s[i] == \"0\": return 0"
                },
                {
                    "id": 3,
                    "instruction": "Check single digit decoding.",
                    "placeholderCode": "        res = dfs(i + 1)",
                    "validationRegex": "^\\s+res\\s*=\\s*dfs\\(i\\s*\\+\\s*1\\)$",
                    "hint": "Recursively call for the next character (single digit decoding).",
                    "solutionCode": "        res = dfs(i + 1)"
                },
                {
                    "id": 4,
                    "instruction": "Check two digit decoding.",
                    "placeholderCode": "        if (i + 1 < len(s) and (s[i] == \"1\" or\n            (s[i] == \"2\" and s[i + 1] in \"0123456\"))):\n            res += dfs(i + 2)",
                    "validationRegex": "^\\s+if\\s*\\(i\\s*\\+\\s*1\\s*<\\s+len\\(s\\)\\s+and\\s*\\(s\\[i\\]\\s*==\\s*\"1\"\\s+or\\s*\\(s\\[i\\]\\s*==\\s*\"2\"\\s+and\\s+s\\[i\\s*\\+\\s*1\\]\\s+in\\s*\"0123456\"\\)\\)\\):\\s*res\\s*\\+=\\s*dfs\\(i\\s*\\+\\s*2\\)$",
                    "hint": "If two digits form a valid number (10-26), add the result of dfs(i + 2).",
                    "solutionCode": "        if (i + 1 < len(s) and (s[i] == \"1\" or\n            (s[i] == \"2\" and s[i + 1] in \"0123456\"))):\n            res += dfs(i + 2)"
                },
                {
                    "id": 5,
                    "instruction": "Store result in memoization table and return.",
                    "placeholderCode": "        dp[i] = res\n        return res",
                    "validationRegex": "^\\s+dp\\[i\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in `dp` and return it.",
                    "solutionCode": "        dp[i] = res\n        return res"
                },
                {
                    "id": 6,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0\\)$",
                    "hint": "Start recursion from index 0.",
                    "solutionCode": "    return dfs(0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iterate backwards to find decodings in O(n) time and O(n) space.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function num_decodings that takes s.",
                    "placeholderCode": "def num_decodings(s):",
                    "validationRegex": "^def\\s+num_decodings\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def num_decodings(s):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP table with the base case: an empty string has one way to be decoded.",
                    "placeholderCode": "    dp = {len(s): 1}",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\{len\\(s\\):\\s*1\\}$",
                    "hint": "We use a dictionary/table where index 'len(s)' is the base case.",
                    "solutionCode": "    dp = {len(s): 1}"
                },
                {
                    "id": 3,
                    "instruction": "Iterate backwards through the string starting from the last character.",
                    "placeholderCode": "    for i in range(len(s) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "Dynamic programming works here by solving subproblems from right to left.",
                    "solutionCode": "    for i in range(len(s) - 1, -1, -1):"
                },
                {
                    "id": 4,
                    "instruction": "Check if the current character is '0', which cannot start a valid decoding.",
                    "placeholderCode": "        if s[i] == \"0\":",
                    "validationRegex": "^\\s+if\\s+s\\[i\\]\\s*==\\s*\"0\":$",
                    "hint": "If s[i] is '0', there are 0 ways to decode any substring starting at this index.",
                    "solutionCode": "        if s[i] == \"0\":"
                },
                {
                    "id": 5,
                    "instruction": "Assign 0 to the current DP state if it starts with '0'.",
                    "placeholderCode": "            dp[i] = 0",
                    "validationRegex": "^\\s+dp\\[i\\]\\s*=\\s*0$",
                    "hint": "A leading zero makes the current decoding path invalid.",
                    "solutionCode": "            dp[i] = 0"
                },
                {
                    "id": 6,
                    "instruction": "Handle the case where the current character is a valid single digit (1-9).",
                    "placeholderCode": "        else:",
                    "validationRegex": "^\\s+else:$",
                    "hint": "If s[i] is not '0', it can at least be decoded as a single character.",
                    "solutionCode": "        else:"
                },
                {
                    "id": 7,
                    "instruction": "Set the current DP state to the value of the next state.",
                    "placeholderCode": "            dp[i] = dp[i + 1]",
                    "validationRegex": "^\\s+dp\\[i\\]\\s*=\\s*dp\\[i\\s*\\+\\s*1\\]$",
                    "hint": "The number of ways is at least the ways available for the remainder of the string.",
                    "solutionCode": "            dp[i] = dp[i + 1]"
                },
                {
                    "id": 8,
                    "instruction": "Check if the next two digits form a valid number between 10 and 26.",
                    "placeholderCode": "        if (i + 1 < len(s) and (s[i] == \"1\" or\n            (s[i] == \"2\" and s[i + 1] in \"0123456\"))):",
                    "validationRegex": "^\\s+if\\s*\\(i\\s*\\+\\s*1\\s*<\\s+len\\(s\\)\\s+and\\s*\\(s\\[i\\]\\s*==\\s*\"1\"\\s+or\\s*\\(s\\[i\\]\\s*==\\s*\"2\"\\s+and\\s+s\\[i\\s*\\+\\s*1\\]\\s+in\\s*\"0123456\"\\)\\)\\):$",
                    "hint": "Two-digit decodings are valid if the value is between 10 and 26.",
                    "solutionCode": "        if (i + 1 < len(s) and (s[i] == \"1\" or\n            (s[i] == \"2\" and s[i + 1] in \"0123456\"))):"
                },
                {
                    "id": 9,
                    "instruction": "Add the number of decodings from two positions ahead to the current state.",
                    "placeholderCode": "            dp[i] += dp[i + 2]",
                    "validationRegex": "^\\s+dp\\[i\\]\\s*\\+=\\s*dp\\[i\\s*\\+\\s*2\\]$",
                    "hint": "This step accounts for the multiple ways to decode by including the results of the two-digit path.",
                    "solutionCode": "            dp[i] += dp[i + 2]"
                },
                {
                    "id": 10,
                    "instruction": "Return the total number of ways to decode the message starting from index 0.",
                    "placeholderCode": "    return dp[0]",
                    "validationRegex": "^\\s+return\\s+dp\\[0\\]$",
                    "hint": "After completing the loop, the first entry in our table holds the answer.",
                    "solutionCode": "    return dp[0]"
                }
            ]
        }
    }
}