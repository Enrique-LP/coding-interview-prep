{
    "id": "min-cost-climbing-stairs",
    "title": "Min Cost Climbing Stairs",
    "description": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor.",
    "examples": [
        {
            "input": "cost = [10,15,20]",
            "output": "15"
        },
        {
            "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
            "output": "6"
        }
    ],
    "constraints": [
        "2 <= cost.length <= 1000",
        "0 <= cost[i] <= 999"
    ],
    "difficulty": "Easy",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Calculate min cost recursively.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_cost_climbing_stairs that takes cost.",
                    "placeholderCode": "def min_cost_climbing_stairs(cost):",
                    "validationRegex": "^def\\s+min_cost_climbing_stairs\\(cost\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_cost_climbing_stairs(cost):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper.",
                    "placeholderCode": "    def dfs(i):\n        if i >= len(cost): return 0\n        return cost[i] + min(dfs(i + 1), dfs(i + 2))",
                    "validationRegex": "^\\s+def\\s+dfs\\(i\\):\\s*if\\s+i\\s*>=\\s+len\\(cost\\):\\s*return\\s+0\\s*return\\s+cost\\[i\\]\\s*\\+\\s*min\\(dfs\\(i\\s*\\+\\s*1\\),\\s*dfs\\(i\\s*\\+\\s*2\\)\\)$",
                    "hint": "Recursive function. If index out of bounds, return 0. Else return cost[i] + min(dfs(i+1), dfs(i+2)).",
                    "solutionCode": "    def dfs(i):\n        if i >= len(cost): return 0\n        return cost[i] + min(dfs(i + 1), dfs(i + 2))"
                },
                {
                    "id": 3,
                    "instruction": "Return min of starting at 0 or 1.",
                    "placeholderCode": "    return min(dfs(0), dfs(1))",
                    "validationRegex": "^\\s+return\\s+min\\(dfs\\(0\\),\\s*dfs\\(1\\)\\)$",
                    "hint": "We can start at step 0 or step 1. Return the minimum of both.",
                    "solutionCode": "    return min(dfs(0), dfs(1))"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iterate backwards to find min cost in-place, O(n) time and O(1) space.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_cost_climbing_stairs that takes cost.",
                    "placeholderCode": "def min_cost_climbing_stairs(cost):",
                    "validationRegex": "^def\\s+min_cost_climbing_stairs\\(cost\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_cost_climbing_stairs(cost):"
                },
                {
                    "id": 2,
                    "instruction": "Append 0 to cost for top floor.",
                    "placeholderCode": "    cost.append(0)",
                    "validationRegex": "^\\s+cost\\.append\\(0\\)$",
                    "hint": "Append 0 to the cost array to represent the top of the floor (destination).",
                    "solutionCode": "    cost.append(0)"
                },
                {
                    "id": 3,
                    "instruction": "Iterate backwards from the third-to-last element down to index 0.",
                    "placeholderCode": "    for i in range(len(cost) - 3, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(cost\\)\\s*-\\s*3,\\s*-1,\\s*-1\\):$",
                    "hint": "Start from index len(cost)-3 because len(cost)-1 is the top floor and len(cost)-2 has no choice but to go to the top.",
                    "solutionCode": "    for i in range(len(cost) - 3, -1, -1):"
                },
                {
                    "id": 4,
                    "instruction": "Update the current cost with the minimum of the next two possible steps.",
                    "placeholderCode": "        cost[i] += min(cost[i + 1], cost[i + 2])",
                    "validationRegex": "^\\s+cost\\[i\\]\\s*\\+=\\s*min\\(cost\\[i\\s*\\+\\s*1\\],\\s*cost\\[i\\s*\\+\\s*2\\]\\)$",
                    "hint": "At each step, we choose the cheapest way to continue climbing.",
                    "solutionCode": "        cost[i] += min(cost[i + 1], cost[i + 2])"
                },
                {
                    "id": 5,
                    "instruction": "Return min of first two costs.",
                    "placeholderCode": "    return min(cost[0], cost[1])",
                    "validationRegex": "^\\s+return\\s+min\\(cost\\[0\\],\\s*cost\\[1\\]\\)$",
                    "hint": "The answer is the minimum cost to start at step 0 or step 1.",
                    "solutionCode": "    return min(cost[0], cost[1])"
                }
            ]
        }
    }
}