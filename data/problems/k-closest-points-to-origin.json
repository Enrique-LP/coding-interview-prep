{
    "id": "k-closest-points-to-origin",
    "title": "K Closest Points to Origin",
    "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., sqrt((x1 - x2)^2 + (y1 - y2)^2)). You may return the answer in any order.",
    "examples": [
        {
            "input": "points = [[1,3],[-2,2]], k = 1",
            "output": "[[-2,2]]",
            "explanation": "The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin. We only want the closest k = 1 points from the origin, so the answer is [[-2,2]]."
        },
        {
            "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
            "output": "[[3,3],[-2,4]]"
        }
    ],
    "constraints": [
        "1 <= k <= points.length <= 10^4",
        "-10^4 < xi, yi < 10^4"
    ],
    "difficulty": "Medium",
    "topic": "Heap / Priority Queue",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Sorting",
            "description": "Sort points by distance.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function k_closest that takes points and k.",
                    "placeholderCode": "def k_closest(points, k):",
                    "validationRegex": "^def\\s+k_closest\\(points,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def k_closest(points, k):"
                },
                {
                    "id": 2,
                    "instruction": "Sort points using lambda for distance calculation.",
                    "placeholderCode": "    points.sort(key=lambda p: p[0]**2 + p[1]**2)",
                    "validationRegex": "^\\s+points\\.sort\\(key=lambda\\s+p:\\s+p\\[0\\]\\*\\*2\\s*\\+\\s*p\\[1\\]\\*\\*2\\)$",
                    "hint": "Sort the points based on their squared Euclidean distance from the origin.",
                    "solutionCode": "    points.sort(key=lambda p: p[0]**2 + p[1]**2)"
                },
                {
                    "id": 3,
                    "instruction": "Return the first k points.",
                    "placeholderCode": "    return points[:k]",
                    "validationRegex": "^\\s+return\\s+points\\[:k\\]$",
                    "hint": "Slice the sorted list to get the k closest points.",
                    "solutionCode": "    return points[:k]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Min Heap",
            "description": "Use a min heap to store points with distances.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function k_closest that takes points and k.",
                    "placeholderCode": "def k_closest(points, k):",
                    "validationRegex": "^def\\s+k_closest\\(points,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def k_closest(points, k):"
                },
                {
                    "id": 2,
                    "instruction": "Create a list of [distance, x, y].",
                    "placeholderCode": "    import heapq\n    minHeap = []\n    for x, y in points:\n        dist = (x ** 2) + (y ** 2)\n        minHeap.append([dist, x, y])",
                    "validationRegex": "^\\s+import\\s+heapq\\s*minHeap\\s*=\\s*\\[\\]\\s*for\\s+x,\\s*y\\s+in\\s+points:\\s*dist\\s*=\\s*\\(x\\s*\\*\\*\\s*2\\)\\s*\\+\\s*\\(y\\s*\\*\\*\\s*2\\)\\s*minHeap\\.append\\(\\[dist,\\s*x,\\s*y\\]\\)$",
                    "hint": "Calculate distances and store them with coordinates in a list.\\n\\nExample:\\nPoint (1, 3). Dist = 1^2 + 3^2 = 10.\\nStore [10, 1, 3].",
                    "solutionCode": "    import heapq\n    minHeap = []\n    for x, y in points:\n        dist = (x ** 2) + (y ** 2)\n        minHeap.append([dist, x, y])"
                },
                {
                    "id": 3,
                    "instruction": "Heapify the list.",
                    "placeholderCode": "    heapq.heapify(minHeap)",
                    "validationRegex": "^\\s+heapq\\.heapify\\(minHeap\\)$",
                    "hint": "Convert the list into a min-heap.",
                    "solutionCode": "    heapq.heapify(minHeap)"
                },
                {
                    "id": 4,
                    "instruction": "Pop k times to get closest points.",
                    "placeholderCode": "    res = []\n    for _ in range(k):\n        dist, x, y = heapq.heappop(minHeap)\n        res.append([x, y])",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*for\\s+_\\s+in\\s+range\\(k\\):\\s*dist,\\s*x,\\s*y\\s*=\\s*heapq\\.heappop\\(minHeap\\)\\s*res\\.append\\(\\[x,\\s*y\\]\\)$",
                    "hint": "Extract the k smallest elements from the heap.",
                    "solutionCode": "    res = []\n    for _ in range(k):\n        dist, x, y = heapq.heappop(minHeap)\n        res.append([x, y])"
                },
                {
                    "id": 5,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the list of k closest points.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}