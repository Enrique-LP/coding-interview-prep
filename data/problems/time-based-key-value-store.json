{
    "id": "time-based-key-value-store",
    "title": "Time Based Key-Value Store",
    "description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.",
    "examples": [
        {
            "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
            "output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]"
        }
    ],
    "constraints": [
        "1 <= key.length, value.length <= 100",
        "key and value consist of lowercase English letters and digits.",
        "1 <= timestamp <= 10^7",
        "All the timestamps timestamp of set are strictly increasing.",
        "At most 2 * 10^5 calls will be made to set and get."
    ],
    "difficulty": "Medium",
    "topic": "Binary Search",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Linear Search",
            "description": "Store values in list and search linearly.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the class TimeMap.",
                    "placeholderCode": "class TimeMap:\n    def __init__(self):\n        self.store = collections.defaultdict(list)",
                    "validationRegex": "^class\\s+TimeMap:\\s*def\\s+__init__\\(self\\):\\s*self\\.store\\s*=\\s*collections\\.defaultdict\\(list\\)$",
                    "hint": "Initialize `self.store` as a defaultdict of lists.",
                    "solutionCode": "class TimeMap:\n    def __init__(self):\n        self.store = collections.defaultdict(list)"
                },
                {
                    "id": 2,
                    "instruction": "Implement set.",
                    "placeholderCode": "    def set(self, key, value, timestamp):\n        self.store[key].append([value, timestamp])",
                    "validationRegex": "^\\s+def\\s+set\\(self,\\s*key,\\s*value,\\s*timestamp\\):\\s*self\\.store\\[key\\]\\.append\\(\\[value,\\s*timestamp\\]\\)$",
                    "hint": "Append `[value, timestamp]` to the list for `key`.",
                    "solutionCode": "    def set(self, key, value, timestamp):\n        self.store[key].append([value, timestamp])"
                },
                {
                    "id": 3,
                    "instruction": "Implement get.",
                    "placeholderCode": "    def get(self, key, timestamp):\n        res = \"\"\n        values = self.store.get(key, [])\n        for v, t in values:\n            if t <= timestamp:\n                res = v\n        return res",
                    "validationRegex": "^\\s+def\\s+get\\(self,\\s*key,\\s*timestamp\\):\\s*res\\s*=\\s*\"\"\\s*values\\s*=\\s*self\\.store\\.get\\(key,\\s*\\[\\]\\)\\s*for\\s+v,\\s*t\\s+in\\s+values:\\s*if\\s+t\\s*<=\\s*timestamp:\\s*res\\s*=\\s*v\\s*return\\s+res$",
                    "hint": "Iterate through values. Update `res` if `t <= timestamp`.",
                    "solutionCode": "    def get(self, key, timestamp):\n        res = \"\"\n        values = self.store.get(key, [])\n        for v, t in values:\n            if t <= timestamp:\n                res = v\n        return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Binary Search",
            "description": "Binary search for the timestamp.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the class TimeMap.",
                    "placeholderCode": "class TimeMap:\n    def __init__(self):\n        self.store = collections.defaultdict(list)",
                    "validationRegex": "^class\\s+TimeMap:\\s*def\\s+__init__\\(self\\):\\s*self\\.store\\s*=\\s*collections\\.defaultdict\\(list\\)$",
                    "hint": "Initialize `self.store` as a defaultdict of lists.",
                    "solutionCode": "class TimeMap:\n    def __init__(self):\n        self.store = collections.defaultdict(list)"
                },
                {
                    "id": 2,
                    "instruction": "Implement set.",
                    "placeholderCode": "    def set(self, key, value, timestamp):\n        self.store[key].append([value, timestamp])",
                    "validationRegex": "^\\s+def\\s+set\\(self,\\s*key,\\s*value,\\s*timestamp\\):\\s*self\\.store\\[key\\]\\.append\\(\\[value,\\s*timestamp\\]\\)$",
                    "hint": "Append `[value, timestamp]` to the list for `key`.",
                    "solutionCode": "    def set(self, key, value, timestamp):\n        self.store[key].append([value, timestamp])"
                },
                {
                    "id": 3,
                    "instruction": "Implement get.",
                    "placeholderCode": "    def get(self, key, timestamp):\n        res = \"\"\n        values = self.store.get(key, [])\n        l, r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res",
                    "validationRegex": "^\\s+def\\s+get\\(self,\\s*key,\\s*timestamp\\):\\s*res\\s*=\\s*\"\"\\s*values\\s*=\\s*self\\.store\\.get\\(key,\\s*\\[\\]\\)\\s*l,\\s*r\\s*=\\s*0,\\s*len\\(values\\)\\s*-\\s*1\\s*while\\s+l\\s*<=\\s*r:\\s*m\\s*=\\s*\\(l\\s*\\+\\s*r\\)\\s*//\\s*2\\s*if\\s+values\\[m\\]\\[1\\]\\s*<=\\s*timestamp:\\s*res\\s*=\\s*values\\[m\\]\\[0\\]\\s*l\\s*=\\s*m\\s*\\+\\s*1\\s*else:\\s*r\\s*=\\s*m\\s*-\\s*1\\s*return\\s+res$",
                    "hint": "Use binary search to find the largest timestamp <= input timestamp.\\n\\nExample:\\nValues=[(bar, 1), (bar2, 4)]. Get time=3.\\nMid=(bar, 1). 1 <= 3. Res=bar. Try right.\\nMid=(bar2, 4). 4 > 3. Try left. Final Res=bar.",
                    "solutionCode": "    def get(self, key, timestamp):\n        res = \"\"\n        values = self.store.get(key, [])\n        l, r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res"
                }
            ]
        }
    }
}