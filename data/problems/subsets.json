{
    "id": "subsets",
    "title": "Subsets",
    "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "examples": [
        {
            "input": "nums = [1,2,3]",
            "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
        },
        {
            "input": "nums = [0]",
            "output": "[[],[0]]"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 10",
        "-10 <= nums[i] <= 10",
        "All the numbers of nums are unique."
    ],
    "difficulty": "Medium",
    "topic": "Backtracking",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Iteratively add new element to existing subsets.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function subsets that takes nums.",
                    "placeholderCode": "def subsets(nums):",
                    "validationRegex": "^def\\s+subsets\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def subsets(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result with empty subset.",
                    "placeholderCode": "    res = [[]]",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\[\\]\\]$",
                    "hint": "Start with a list containing an empty list.",
                    "solutionCode": "    res = [[]]"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through each number.",
                    "placeholderCode": "    for num in nums:",
                    "validationRegex": "^\\s+for\\s+num\\s+in\\s+nums:$",
                    "hint": "Loop through every number in the input array.",
                    "solutionCode": "    for num in nums:"
                },
                {
                    "id": 4,
                    "instruction": "Add number to all existing subsets to create new ones.",
                    "placeholderCode": "        res += [curr + [num] for curr in res]",
                    "validationRegex": "^\\s+res\\s*\\+=\\s*\\[curr\\s*\\+\\s*\\[num\\]\\s+for\\s+curr\\s+in\\s+res\\]$",
                    "hint": "For each existing subset, create a new subset by appending the current number.\\n\\nExample:\\nNums=[1, 2].\\nInit: [[]].\\nNum=1: Add 1 to [] -> [1]. Res=[[], [1]].\\nNum=2: Add 2 to [] -> [2]. Add 2 to [1] -> [1, 2]. Res=[[], [1], [2], [1, 2]].",
                    "solutionCode": "        res += [curr + [num] for curr in res]"
                },
                {
                    "id": 5,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the list of all subsets.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "DFS to explore include/exclude decisions.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function subsets that takes nums.",
                    "placeholderCode": "def subsets(nums):",
                    "validationRegex": "^def\\s+subsets\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def subsets(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the list for storing all subsets.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "Initialize an empty list to store the final result.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 3,
                    "instruction": "Initialize a temporary list for the current subset.",
                    "placeholderCode": "    subset = []",
                    "validationRegex": "^\\s+subset\\s*=\\s*\\[\\]$",
                    "hint": "This list will be modified as we explore different branches of the DFS.",
                    "solutionCode": "    subset = []"
                },
                {
                    "id": 4,
                    "instruction": "Define the recursive dfs function that takes the current index i.",
                    "placeholderCode": "    def dfs(i):",
                    "validationRegex": "^\\s+def\\s+dfs\\(i\\):$",
                    "hint": "This function will explore the decision tree for each element.",
                    "solutionCode": "    def dfs(i):"
                },
                {
                    "id": 5,
                    "instruction": "Add a base case to check if the current index has reached the end of the array.",
                    "placeholderCode": "        if i >= len(nums):",
                    "validationRegex": "^\\s+if\\s+i\\s*>=\\s+len\\(nums\\):$",
                    "hint": "When i equals the length of nums, we have made a decision for every element.",
                    "solutionCode": "        if i >= len(nums):"
                },
                {
                    "id": 6,
                    "instruction": "Inside the base case, append a copy of the current subset to the result list.",
                    "placeholderCode": "            res.append(subset.copy())",
                    "validationRegex": "^\\s+res\\.append\\(subset\\.copy\\(\\)\\)$",
                    "hint": "We must use .copy() because the subset list is modified in other parts of the code.",
                    "solutionCode": "            res.append(subset.copy())"
                },
                {
                    "id": 7,
                    "instruction": "Return from the function after adding the subset to the results.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "Stop the recursion for this branch.",
                    "solutionCode": "            return"
                },
                {
                    "id": 8,
                    "instruction": "Add the current element to the subset list (decision to include).",
                    "placeholderCode": "        subset.append(nums[i])",
                    "validationRegex": "^\\s+subset\\.append\\(nums\\[i\\]\\)$",
                    "hint": "This represents the 'include' branch of our decision tree.",
                    "solutionCode": "        subset.append(nums[i])"
                },
                {
                    "id": 9,
                    "instruction": "Recursive call to dfs for the next index after including the element.",
                    "placeholderCode": "        dfs(i + 1)",
                    "validationRegex": "^\\s+dfs\\(i\\s*\\+\\s*1\\)$",
                    "hint": "Explore all subproblems that include nums[i].",
                    "solutionCode": "        dfs(i + 1)"
                },
                {
                    "id": 10,
                    "instruction": "Decision to exclude nums[i].",
                    "placeholderCode": "        subset.pop()\n        dfs(i + 1)",
                    "validationRegex": "^\\s+subset\\.pop\\(\\)\\s*dfs\\(i\\s*\\+\\s*1\\)$",
                    "hint": "Backtrack: remove the current number and recurse (exclude decision).\\n\\nExample:\\nNums=[1, 2].\\nStart: [].\\nInclude 1 -> [1]. Recurse -> Include 2 -> [1, 2].\\nBacktrack 2 -> [1]. Exclude 2 -> [1].\\nBacktrack 1 -> []. Exclude 1 -> [].",
                    "solutionCode": "        subset.pop()\n        dfs(i + 1)"
                },
                {
                    "id": 11,
                    "instruction": "Call dfs starting at 0 and return result.",
                    "placeholderCode": "    dfs(0)\n    return res",
                    "validationRegex": "^\\s+dfs\\(0\\)\\s*return\\s+res$",
                    "hint": "Start the DFS from index 0.",
                    "solutionCode": "    dfs(0)\n    return res"
                }
            ]
        }
    }
}