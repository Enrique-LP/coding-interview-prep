{
    "id": "search-a-2d-matrix",
    "title": "Search a 2D Matrix",
    "description": "You are given an m x n integer matrix matrix with the following two properties: Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time complexity.",
    "examples": [
        {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
            "output": "true"
        },
        {
            "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
            "output": "false"
        }
    ],
    "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 100",
        "-10^4 <= matrix[i][j], target <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "Binary Search",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Linear Search",
            "description": "Check every element in the matrix.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function search_matrix that takes matrix and target.",
                    "placeholderCode": "def search_matrix(matrix, target):",
                    "validationRegex": "^def\\s+search_matrix\\(matrix,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def search_matrix(matrix, target):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate through each row.",
                    "placeholderCode": "    for row in matrix:",
                    "validationRegex": "^\\s+for\\s+row\\s+in\\s+matrix:$",
                    "hint": "Iterate through rows.",
                    "solutionCode": "    for row in matrix:"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through each element in the row.",
                    "placeholderCode": "        for n in row:",
                    "validationRegex": "^\\s+for\\s+n\\s+in\\s+row:$",
                    "hint": "Iterate through elements in row.",
                    "solutionCode": "        for n in row:"
                },
                {
                    "id": 4,
                    "instruction": "Return True if found.",
                    "placeholderCode": "            if n == target:\n                return True",
                    "validationRegex": "^\\s+if\\s+n\\s*==\\s*target:\\s*return\\s+True$",
                    "hint": "Check if element matches target.",
                    "solutionCode": "            if n == target:\n                return True"
                },
                {
                    "id": 5,
                    "instruction": "Return False if not found.",
                    "placeholderCode": "    return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "Return False if not found.",
                    "solutionCode": "    return False"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Double Binary Search",
            "description": "Binary search rows, then binary search the row.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function search_matrix that takes matrix and target.",
                    "placeholderCode": "def search_matrix(matrix, target):",
                    "validationRegex": "^def\\s+search_matrix\\(matrix,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def search_matrix(matrix, target):"
                },
                {
                    "id": 2,
                    "instruction": "Get the number of rows and columns in the matrix.",
                    "placeholderCode": "    ROWS, COLS = len(matrix), len(matrix[0])",
                    "validationRegex": "^\\s+ROWS,\\s*COLS\\s*=\\s*len\\(matrix\\),\\s*len\\(matrix\\[0\\]\\)$",
                    "hint": "We need `ROWS` to define our row search boundaries and `COLS` for the final element search.",
                    "solutionCode": "    ROWS, COLS = len(matrix), len(matrix[0])"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the top and bottom pointers for binary searching the rows.",
                    "placeholderCode": "    top, bot = 0, ROWS - 1",
                    "validationRegex": "^\\s+top,\\s*bot\\s*=\\s*0,\\s*ROWS\\s*-\\s*1$",
                    "hint": "The `top` pointer starts at the first row (0) and `bot` at the last row (`ROWS - 1`).",
                    "solutionCode": "    top, bot = 0, ROWS - 1"
                },
                {
                    "id": 4,
                    "instruction": "Start a while loop to binary search through the rows.",
                    "placeholderCode": "    while top <= bot:",
                    "validationRegex": "^\\s+while\\s+top\\s*<=\\s*bot:$",
                    "hint": "The search continues as long as we have a valid range of rows to check.",
                    "solutionCode": "    while top <= bot:"
                },
                {
                    "id": 5,
                    "instruction": "Calculate the middle row index.",
                    "placeholderCode": "        row = (top + bot) // 2",
                    "validationRegex": "^\\s+row\\s*=\\s*\\(top\\s*\\+\\s*bot\\)\\s*//\\s*2$",
                    "hint": "Average the `top` and `bot` pointers to find the pivot row.",
                    "solutionCode": "        row = (top + bot) // 2"
                },
                {
                    "id": 6,
                    "instruction": "Check if the target is greater than the last element of the current row.",
                    "placeholderCode": "        if target > matrix[row][-1]:",
                    "validationRegex": "^\\s+if\\s+target\\s*>\\s+matrix\\[row\\]\\[-1\\]:$",
                    "hint": "If the target is larger than the row's maximum, it must be in a row further down.",
                    "solutionCode": "        if target > matrix[row][-1]:"
                },
                {
                    "id": 7,
                    "instruction": "Move the top pointer to search in higher-indexed rows.",
                    "placeholderCode": "            top = row + 1",
                    "validationRegex": "^\\s+top\\s*=\\s*row\\s*\\+\\s*1$",
                    "hint": "Discard the current row and everything above it.",
                    "solutionCode": "            top = row + 1"
                },
                {
                    "id": 8,
                    "instruction": "Check if the target is smaller than the first element of the current row.",
                    "placeholderCode": "        elif target < matrix[row][0]:",
                    "validationRegex": "^\\s+elif\\s+target\\s*<\\s+matrix\\[row\\]\\[0\\]:$",
                    "hint": "If the target is smaller than the row's minimum, it must be in a row further up.",
                    "solutionCode": "        elif target < matrix[row][0]:"
                },
                {
                    "id": 9,
                    "instruction": "Move the bottom pointer to search in lower-indexed rows.",
                    "placeholderCode": "            bot = row - 1",
                    "validationRegex": "^\\s+bot\\s*=\\s*row\\s*-\\s*1$",
                    "hint": "Discard the current row and everything below it.",
                    "solutionCode": "            bot = row - 1"
                },
                {
                    "id": 10,
                    "instruction": "Break the loop if the target is within the range of the current row.",
                    "placeholderCode": "        else:\n            break",
                    "validationRegex": "^\\s+else:\\s*break$",
                    "hint": "We've found the potential row! Exit the loop to proceed with the column search.",
                    "solutionCode": "        else:\n            break"
                },
                {
                    "id": 11,
                    "instruction": "If no valid row was found, return False.",
                    "placeholderCode": "    if not (top <= bot):\n        return False",
                    "validationRegex": "^\\s+if\\s+not\\s*\\(top\\s*<=\\s*bot\\):\\s*return\\s+False$",
                    "hint": "If the pointers crossed, the target doesn't fit in any row's range.",
                    "solutionCode": "    if not (top <= bot):\n        return False"
                },
                {
                    "id": 12,
                    "instruction": "Set the final row index to be searched.",
                    "placeholderCode": "    row = (top + bot) // 2",
                    "validationRegex": "^\\s+row\\s*=\\s*\\(top\\s*\\+\\s*bot\\)\\s*//\\s*2$",
                    "hint": "We use the resulting pointers from the row search to pin down exactly which row we'll scan.",
                    "solutionCode": "    row = (top + bot) // 2"
                },
                {
                    "id": 13,
                    "instruction": "Initialize the left and right pointers for searching within the row.",
                    "placeholderCode": "    l, r = 0, COLS - 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*COLS\\s*-\\s*1$",
                    "hint": "Start `l` at 0 and `r` at the last column index.",
                    "solutionCode": "    l, r = 0, COLS - 1"
                },
                {
                    "id": 14,
                    "instruction": "Start a while loop to binary search through the row's elements.",
                    "placeholderCode": "    while l <= r:",
                    "validationRegex": "^\\s+while\\s+l\\s*<=\\s*r:$",
                    "hint": "Standard binary search loop across columns.",
                    "solutionCode": "    while l <= r:"
                },
                {
                    "id": 15,
                    "instruction": "Calculate the middle column index.",
                    "placeholderCode": "        m = (l + r) // 2",
                    "validationRegex": "^\\s+m\\s*=\\s*\\(l\\s*\\+\\s*r\\)\\s*//\\s*2$",
                    "hint": "Find the center of the current column range.",
                    "solutionCode": "        m = (l + r) // 2"
                },
                {
                    "id": 16,
                    "instruction": "Check if the target is greater than the middle element.",
                    "placeholderCode": "        if target > matrix[row][m]:",
                    "validationRegex": "^\\s+if\\s+target\\s*>\\s+matrix\\[row\\]\\[m\\]:$",
                    "hint": "If target is larger, search the right half of the row.",
                    "solutionCode": "        if target > matrix[row][m]:"
                },
                {
                    "id": 17,
                    "instruction": "Move the left pointer to the right of the middle index.",
                    "placeholderCode": "            l = m + 1",
                    "validationRegex": "^\\s+l\\s*=\\s*m\\s*\\+\\s*1$",
                    "hint": "Discard the left half of the column search space.",
                    "solutionCode": "            l = m + 1"
                },
                {
                    "id": 18,
                    "instruction": "Check if the target is smaller than the middle element.",
                    "placeholderCode": "        elif target < matrix[row][m]:",
                    "validationRegex": "^\\s+elif\\s+target\\s*<\\s+matrix\\[row\\]\\[m\\]:$",
                    "hint": "If target is smaller, search the left half of the row.",
                    "solutionCode": "        elif target < matrix[row][m]:"
                },
                {
                    "id": 19,
                    "instruction": "Move the right pointer to the left of the middle index.",
                    "placeholderCode": "            r = m - 1",
                    "validationRegex": "^\\s+r\\s*=\\s*m\\s*-\\s*1$",
                    "hint": "Discard the right half of the column search space.",
                    "solutionCode": "            r = m - 1"
                },
                {
                    "id": 20,
                    "instruction": "If the target matches the middle element, return True.",
                    "placeholderCode": "        else:\n            return True",
                    "validationRegex": "^\\s+else:\\s*return\\s+True$",
                    "hint": "Found it! Return True immediately.",
                    "solutionCode": "        else:\n            return True"
                },
                {
                    "id": 21,
                    "instruction": "Return False if the target was not found in the matrix.",
                    "placeholderCode": "    return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "Both searches are complete and the target wasn't found.",
                    "solutionCode": "    return False"
                }
            ]
        }
    }
}