{
    "id": "merge-intervals",
    "title": "Merge Intervals",
    "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "examples": [
        {
            "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
            "output": "[[1,6],[8,10],[15,18]]",
            "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
        },
        {
            "input": "intervals = [[1,4],[4,5]]",
            "output": "[[1,5]]",
            "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
        }
    ],
    "constraints": [
        "1 <= intervals.length <= 10^4",
        "intervals[i].length == 2",
        "0 <= starti <= endi <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "Intervals",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Sorting",
            "description": "Sort and merge overlapping intervals.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function merge that takes intervals.",
                    "placeholderCode": "def merge(intervals):",
                    "validationRegex": "^def\\s+merge\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def merge(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals by start time.",
                    "placeholderCode": "    intervals.sort(key=lambda i: i[0])",
                    "validationRegex": "^\\s+intervals\\.sort\\(key=lambda\\s+i:\\s+i\\[0\\]\\)$",
                    "hint": "Sort the intervals based on the start time to process them in order.",
                    "solutionCode": "    intervals.sort(key=lambda i: i[0])"
                },
                {
                    "id": 3,
                    "instruction": "Iterate and merge.",
                    "placeholderCode": "    output = [intervals[0]]\n    for start, end in intervals[1:]:\n        lastEnd = output[-1][1]\n        if start <= lastEnd:\n            output[-1][1] = max(lastEnd, end)\n        else:\n            output.append([start, end])",
                    "validationRegex": "^\\s+output\\s*=\\s*\\[intervals\\[0\\]\\]\\s*for\\s+start,\\s*end\\s+in\\s+intervals\\[1:\\]:\\s*lastEnd\\s*=\\s*output\\[-1\\]\\[1\\]\\s*if\\s+start\\s*<=\\s*lastEnd:\\s*output\\[-1\\]\\[1\\]\\s*=\\s*max\\(lastEnd,\\s*end\\)\\s*else:\\s*output\\.append\\(\\[start,\\s*end\\]\\)$",
                    "hint": "Iterate through sorted intervals. If current interval overlaps with the last merged interval (start <= lastEnd), merge them by updating the end time. Otherwise, add the current interval to the output.",
                    "solutionCode": "    output = [intervals[0]]\n    for start, end in intervals[1:]:\n        lastEnd = output[-1][1]\n        if start <= lastEnd:\n            output[-1][1] = max(lastEnd, end)\n        else:\n            output.append([start, end])"
                },
                {
                    "id": 4,
                    "instruction": "Return output.",
                    "placeholderCode": "    return output",
                    "validationRegex": "^\\s+return\\s+output$",
                    "hint": "Return the list of merged intervals.",
                    "solutionCode": "    return output"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Sorting",
            "description": "Same as brute force, O(n log n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function merge that takes intervals.",
                    "placeholderCode": "def merge(intervals):",
                    "validationRegex": "^def\\s+merge\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def merge(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals by start time.",
                    "placeholderCode": "    intervals.sort(key=lambda i: i[0])",
                    "validationRegex": "^\\s+intervals\\.sort\\(key=lambda\\s+i:\\s+i\\[0\\]\\)$",
                    "hint": "Sort intervals by start time.",
                    "solutionCode": "    intervals.sort(key=lambda i: i[0])"
                },
                {
                    "id": 3,
                    "instruction": "Iterate and merge.",
                    "placeholderCode": "    output = [intervals[0]]\n    for start, end in intervals[1:]:\n        lastEnd = output[-1][1]\n        if start <= lastEnd:\n            output[-1][1] = max(lastEnd, end)\n        else:\n            output.append([start, end])",
                    "validationRegex": "^\\s+output\\s*=\\s*\\[intervals\\[0\\]\\]\\s*for\\s+start,\\s*end\\s+in\\s+intervals\\[1:\\]:\\s*lastEnd\\s*=\\s*output\\[-1\\]\\[1\\]\\s*if\\s+start\\s*<=\\s*lastEnd:\\s*output\\[-1\\]\\[1\\]\\s*=\\s*max\\(lastEnd,\\s*end\\)\\s*else:\\s*output\\.append\\(\\[start,\\s*end\\]\\)$",
                    "hint": "Merge overlapping intervals.",
                    "solutionCode": "    output = [intervals[0]]\n    for start, end in intervals[1:]:\n        lastEnd = output[-1][1]\n        if start <= lastEnd:\n            output[-1][1] = max(lastEnd, end)\n        else:\n            output.append([start, end])"
                },
                {
                    "id": 4,
                    "instruction": "Return output.",
                    "placeholderCode": "    return output",
                    "validationRegex": "^\\s+return\\s+output$",
                    "hint": "Return the result.",
                    "solutionCode": "    return output"
                }
            ]
        }
    }
}