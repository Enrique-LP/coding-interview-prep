{
    "id": "merge-intervals",
    "title": "Merge Intervals",
    "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "examples": [
        {
            "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
            "output": "[[1,6],[8,10],[15,18]]",
            "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
        },
        {
            "input": "intervals = [[1,4],[4,5]]",
            "output": "[[1,5]]",
            "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
        }
    ],
    "constraints": [
        "1 <= intervals.length <= 10^4",
        "intervals[i].length == 2",
        "0 <= starti <= endi <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "Intervals",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Sorting",
            "description": "Sort and merge overlapping intervals.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function merge that takes intervals.",
                    "placeholderCode": "def merge(intervals):",
                    "validationRegex": "^def\\s+merge\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def merge(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals by start time.",
                    "placeholderCode": "    intervals.sort(key=lambda i: i[0])",
                    "validationRegex": "^\\s+intervals\\.sort\\(key=lambda\\s+i:\\s+i\\[0\\]\\)$",
                    "hint": "Sort the intervals based on the start time to process them in order.",
                    "solutionCode": "    intervals.sort(key=lambda i: i[0])"
                },
                {
                    "id": 3,
                    "instruction": "Iterate and merge.",
                    "placeholderCode": "    output = [intervals[0]]\n    for start, end in intervals[1:]:\n        lastEnd = output[-1][1]\n        if start <= lastEnd:\n            output[-1][1] = max(lastEnd, end)\n        else:\n            output.append([start, end])",
                    "validationRegex": "^\\s+output\\s*=\\s*\\[intervals\\[0\\]\\]\\s*for\\s+start,\\s*end\\s+in\\s+intervals\\[1:\\]:\\s*lastEnd\\s*=\\s*output\\[-1\\]\\[1\\]\\s*if\\s+start\\s*<=\\s*lastEnd:\\s*output\\[-1\\]\\[1\\]\\s*=\\s*max\\(lastEnd,\\s*end\\)\\s*else:\\s*output\\.append\\(\\[start,\\s*end\\]\\)$",
                    "hint": "Iterate through sorted intervals. If current interval overlaps with the last merged interval (start <= lastEnd), merge them by updating the end time. Otherwise, add the current interval to the output.",
                    "solutionCode": "    output = [intervals[0]]\n    for start, end in intervals[1:]:\n        lastEnd = output[-1][1]\n        if start <= lastEnd:\n            output[-1][1] = max(lastEnd, end)\n        else:\n            output.append([start, end])"
                },
                {
                    "id": 4,
                    "instruction": "Return output.",
                    "placeholderCode": "    return output",
                    "validationRegex": "^\\s+return\\s+output$",
                    "hint": "Return the list of merged intervals.",
                    "solutionCode": "    return output"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Sorting",
            "description": "Same as brute force, O(n log n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function merge that takes intervals.",
                    "placeholderCode": "def merge(intervals):",
                    "validationRegex": "^def\\s+merge\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def merge(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals by start time.",
                    "placeholderCode": "    intervals.sort(key=lambda i: i[0])",
                    "validationRegex": "^\\s+intervals\\.sort\\(key=lambda\\s+i:\\s+i\\[0\\]\\)$",
                    "hint": "Sort intervals by start time.",
                    "solutionCode": "    intervals.sort(key=lambda i: i[0])"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the output list with the first interval.",
                    "placeholderCode": "    output = [intervals[0]]",
                    "validationRegex": "^\\s+output\\s*=\\s*\\[intervals\\[0\\]\\]$",
                    "hint": "Add the first interval to start the merging process.",
                    "solutionCode": "    output = [intervals[0]]"
                },
                {
                    "id": 4,
                    "instruction": "Iterate through the rest of the intervals.",
                    "placeholderCode": "    for start, end in intervals[1:]:",
                    "validationRegex": "^\\s+for\\s+start,\\s*end\\s+in\\s+intervals\\[1:\\]:$",
                    "hint": "Use a for loop to process intervals starting from the second one.",
                    "solutionCode": "    for start, end in intervals[1:]:"
                },
                {
                    "id": 5,
                    "instruction": "Get the end time of the last interval added to the output.",
                    "placeholderCode": "        lastEnd = output[-1][1]",
                    "validationRegex": "^\\s+lastEnd\\s*=\\s*output\\[-1\\]\\[1\\]$",
                    "hint": "Access the second element of the last interval in output.",
                    "solutionCode": "        lastEnd = output[-1][1]"
                },
                {
                    "id": 6,
                    "instruction": "Check if the current interval starts before or at the last interval's end.",
                    "placeholderCode": "        if start <= lastEnd:",
                    "validationRegex": "^\\s+if\\s+start\\s*<=\\s*lastEnd:$",
                    "hint": "Compare the current start with lastEnd.",
                    "solutionCode": "        if start <= lastEnd:"
                },
                {
                    "id": 7,
                    "instruction": "Merge the current interval by updating the end time of the last interval.",
                    "placeholderCode": "            output[-1][1] = max(lastEnd, end)",
                    "validationRegex": "^\\s+output\\[-1\\]\\[1\\]\\s*=\\s*max\\(lastEnd,\\s*end\\)$",
                    "hint": "Set the last end to the maximum of the two end times.",
                    "solutionCode": "            output[-1][1] = max(lastEnd, end)"
                },
                {
                    "id": 8,
                    "instruction": "Handle the case where there is no overlap.",
                    "placeholderCode": "        else:",
                    "validationRegex": "^\\s+else:$",
                    "hint": "Exceute this if start > lastEnd.",
                    "solutionCode": "        else:"
                },
                {
                    "id": 9,
                    "instruction": "Append the current interval to the output list.",
                    "placeholderCode": "            output.append([start, end])",
                    "validationRegex": "^\\s+output\\.append\\(\\[start,\\s*end\\]\\)$",
                    "hint": "Since there is no overlap, add the current interval as a new entry.",
                    "solutionCode": "            output.append([start, end])"
                },
                {
                    "id": 10,
                    "instruction": "Return the list of merged intervals.",
                    "placeholderCode": "    return output",
                    "validationRegex": "^\\s+return\\s+output$",
                    "hint": "Return the result.",
                    "solutionCode": "    return output"
                }
            ]
        }
    }
}