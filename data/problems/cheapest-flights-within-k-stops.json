{
    "id": "cheapest-flights-within-k-stops",
    "title": "Cheapest Flights Within K Stops",
    "description": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [from_i, to_i, price_i] indicates that there is a flight from city from_i to city to_i with cost price_i. You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.",
    "examples": [
        {
            "input": "n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1",
            "output": "700"
        },
        {
            "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
            "output": "200"
        },
        {
            "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0",
            "output": "500"
        }
    ],
    "constraints": [
        "1 <= n <= 100",
        "0 <= flights.length <= (n * (n - 1) / 2)",
        "flights[i].length == 3",
        "0 <= from_i, to_i < n",
        "from_i != to_i",
        "1 <= price_i <= 10^4",
        "There will not be any multiple flights between two cities.",
        "0 <= src, dst, k < n",
        "src != dst"
    ],
    "difficulty": "Medium",
    "topic": "Advanced Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Use Bellman-Ford algorithm.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define findCheapestPrice.",
                    "placeholderCode": "def findCheapestPrice(n, flights, src, dst, k):",
                    "validationRegex": "^def\\s+findCheapestPrice\\(n,\\s*flights,\\s*src,\\s*dst,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def findCheapestPrice(n, flights, src, dst, k):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize prices.",
                    "placeholderCode": "    prices = [float(\"inf\")] * n\n    prices[src] = 0",
                    "validationRegex": "^\\s+prices\\s*=\\s*\\[float\\(\"inf\"\\)\\]\\s*\\*\\s*n\\s*prices\\[src\\]\\s*=\\s*0$",
                    "hint": "Initialize an array to store the minimum price to reach each city. Set the source city's price to 0 and others to infinity.",
                    "solutionCode": "    prices = [float(\"inf\")] * n\n    prices[src] = 0"
                },
                {
                    "id": 3,
                    "instruction": "Run Bellman-Ford.",
                    "placeholderCode": "    for i in range(k + 1):\n        tmpPrices = prices.copy()\n        for s, d, p in flights:\n            if prices[s] == float(\"inf\"):\n                continue\n            if prices[s] + p < tmpPrices[d]:\n                tmpPrices[d] = prices[s] + p\n        prices = tmpPrices",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(k\\s*\\+\\s*1\\):\\s*tmpPrices\\s*=\\s*prices\\.copy\\(\\)\\s*for\\s+s,\\s*d,\\s*p\\s+in\\s+flights:\\s*if\\s+prices\\[s\\]\\s*==\\s*float\\(\"inf\"\\):\\s*continue\\s*if\\s+prices\\[s\\]\\s*\\+\\s*p\\s*<\\s*tmpPrices\\[d\\]:\\s*tmpPrices\\[d\\]\\s*=\\s*prices\\[s\\]\\s*\\+\\s*p\\s*prices\\s*=\\s*tmpPrices$",
                    "hint": "Relax edges k+1 times. Use a temporary array to store updates for the current iteration to ensure we only use values from the previous iteration (limiting stops).\\n\\nExample:\\nFlights=[[0,1,100], [1,2,100], [0,2,500]]. Src=0, K=1.\\nInit: Prices=[0, inf, inf].\\nIter 1 (K=0 stops): Relax 0->1. Prices=[0, 100, 500].\\nIter 2 (K=1 stop): Relax 1->2. Prices=[0, 100, 200].\\nResult: 200.",
                    "solutionCode": "    for i in range(k + 1):\n        tmpPrices = prices.copy()\n        for s, d, p in flights:\n            if prices[s] == float(\"inf\"):\n                continue\n            if prices[s] + p < tmpPrices[d]:\n                tmpPrices[d] = prices[s] + p\n        prices = tmpPrices"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return -1 if prices[dst] == float(\"inf\") else prices[dst]",
                    "validationRegex": "^\\s+return\\s*-1\\s+if\\s+prices\\[dst\\]\\s*==\\s*float\\(\"inf\"\\)\\s+else\\s+prices\\[dst\\]$",
                    "hint": "If the destination price is still infinity, return -1. Otherwise, return the price.",
                    "solutionCode": "    return -1 if prices[dst] == float(\"inf\") else prices[dst]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define findCheapestPrice.",
                    "placeholderCode": "def findCheapestPrice(n, flights, src, dst, k):",
                    "validationRegex": "^def\\s+findCheapestPrice\\(n,\\s*flights,\\s*src,\\s*dst,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def findCheapestPrice(n, flights, src, dst, k):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the 'prices' array with infinity for all nodes.",
                    "placeholderCode": "    prices = [float(\"inf\")] * n",
                    "validationRegex": "^\\s+prices\\s*=\\s*\\[float\\(\"inf\"\\)\\]\\s*\\*\\s*n$",
                    "hint": "We start assuming all paths are infinitely expensive.",
                    "solutionCode": "    prices = [float(\"inf\")] * n"
                },
                {
                    "id": 3,
                    "instruction": "Set the price for the starting city 'src' to 0.",
                    "placeholderCode": "    prices[src] = 0",
                    "validationRegex": "^\\s+prices\\[src\\]\\s*=\\s*0$",
                    "hint": "The cost to reach the source from the source is always zero.",
                    "solutionCode": "    prices[src] = 0"
                },
                {
                    "id": 4,
                    "instruction": "Initiate a loop to relax edges up to k+1 times.",
                    "placeholderCode": "    for i in range(k + 1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(k\\s*\\+\\s*1\\):$",
                    "hint": "We need k+1 iterations to allow for up to k stops.",
                    "solutionCode": "    for i in range(k + 1):"
                },
                {
                    "id": 5,
                    "instruction": "Create a temporary copy of the current prices.",
                    "placeholderCode": "        tmpPrices = prices.copy()",
                    "validationRegex": "^\\s+tmpPrices\\s*=\\s*prices\\.copy\\(\\)$",
                    "hint": "This ensures we only use prices from the previous iteration, enforcing the 'at most k stops' constraint.",
                    "solutionCode": "        tmpPrices = prices.copy()"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through each flight in the 'flights' array.",
                    "placeholderCode": "        for s, d, p in flights:",
                    "validationRegex": "^\\s+for\\s+s,\\s*d,\\s*p\\s+in\\s+flights:$",
                    "hint": "Unpack source 's', destination 'd', and price 'p'.",
                    "solutionCode": "        for s, d, p in flights:"
                },
                {
                    "id": 7,
                    "instruction": "Check if the source city 's' has been reached yet.",
                    "placeholderCode": "            if prices[s] == float(\"inf\"): ",
                    "validationRegex": "^\\s+if\\s+prices\\[s\\]\\s*==\\s*float\\(\"inf\"\\):$",
                    "hint": "If the price is infinity, we cannot use this flight yet.",
                    "solutionCode": "            if prices[s] == float(\"inf\"): "
                },
                {
                    "id": 8,
                    "instruction": "Skip the current flight if the source is unreachable.",
                    "placeholderCode": "                continue",
                    "validationRegex": "^\\s+continue$",
                    "hint": "Ignore flights starting from cities we haven't found a path to.",
                    "solutionCode": "                continue"
                },
                {
                    "id": 9,
                    "instruction": "Check if the new path to 'd' is cheaper than the known path.",
                    "placeholderCode": "            if prices[s] + p < tmpPrices[d]:",
                    "validationRegex": "^\\s+if\\s+prices\\[s\\]\\s*\\+\\s*p\\s*<\\s*tmpPrices\\[d\\]:$",
                    "hint": "Compare the current total price through 's' with the minimum price stored in 'tmpPrices'.",
                    "solutionCode": "            if prices[s] + p < tmpPrices[d]:"
                },
                {
                    "id": 10,
                    "instruction": "Update the temporary price for destination 'd'.",
                    "placeholderCode": "                tmpPrices[d] = prices[s] + p",
                    "validationRegex": "^\\s+tmpPrices\\[d\\]\\s*=\\s*prices\\[s\\]\\s*\\+\\s*p$",
                    "hint": "Store the new found minimum price for this iteration.",
                    "solutionCode": "                tmpPrices[d] = prices[s] + p"
                },
                {
                    "id": 11,
                    "instruction": "Update the official 'prices' array with the temporary values.",
                    "placeholderCode": "        prices = tmpPrices",
                    "validationRegex": "^\\s+prices\\s*=\\s*tmpPrices$",
                    "hint": "Assign the results of this iteration to the main array for the next stop calculation.",
                    "solutionCode": "        prices = tmpPrices"
                },
                {
                    "id": 12,
                    "instruction": "Return the final price to destination or -1 if unreachable.",
                    "placeholderCode": "    return -1 if prices[dst] == float(\"inf\") else prices[dst]",
                    "validationRegex": "^\\s+return\\s*-1\\s+if\\s+prices\\[dst\\]\\s*==\\s*float\\(\"inf\"\\)\\s+else\\s+prices\\[dst\\]$",
                    "hint": "Final check to handle unreachable cases.",
                    "solutionCode": "    return -1 if prices[dst] == float(\"inf\") else prices[dst]"
                }
            ]
        }
    }
}