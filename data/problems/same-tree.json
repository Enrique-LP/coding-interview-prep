{
    "id": "same-tree",
    "title": "Same Tree",
    "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.",
    "examples": [
        {
            "input": "p = [1,2,3], q = [1,2,3]",
            "output": "true"
        },
        {
            "input": "p = [1,2], q = [1,null,2]",
            "output": "false"
        }
    ],
    "constraints": [
        "The number of nodes in both trees is in the range [0, 100].",
        "-10^4 <= Node.val <= 10^4"
    ],
    "difficulty": "Easy",
    "topic": "Trees",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Check if current nodes match and recurse.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function is_same_tree that takes p and q.",
                    "placeholderCode": "def is_same_tree(p, q):",
                    "validationRegex": "^def\\s+is_same_tree\\(p,\\s*q\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def is_same_tree(p, q):"
                },
                {
                    "id": 2,
                    "instruction": "Base case: if both are None, they are same.",
                    "placeholderCode": "    if not p and not q:\n        return True",
                    "validationRegex": "^\\s+if\\s+not\\s+p\\s+and\\s+not\\s+q:\\s*return\\s+True$",
                    "hint": "Return True if both trees are empty.",
                    "solutionCode": "    if not p and not q:\n        return True"
                },
                {
                    "id": 3,
                    "instruction": "Base case: if one is None or values differ, they are not same.",
                    "placeholderCode": "    if not p or not q or p.val != q.val:\n        return False",
                    "validationRegex": "^\\s+if\\s+not\\s+p\\s+or\\s+not\\s+q\\s+or\\s+p\\.val\\s*!=\\s*q\\.val:\\s*return\\s+False$",
                    "hint": "Return False if one is empty or values don't match.\\n\\nExample:\\nP=1, Q=1. Match.\\nP.left=2, Q.left=null. Mismatch! Return False.",
                    "solutionCode": "    if not p or not q or p.val != q.val:\n        return False"
                },
                {
                    "id": 4,
                    "instruction": "Recursively check left and right subtrees.",
                    "placeholderCode": "    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)",
                    "validationRegex": "^\\s+return\\s+is_same_tree\\(p\\.left,\\s*q\\.left\\)\\s+and\\s+is_same_tree\\(p\\.right,\\s*q\\.right\\)$",
                    "hint": "Check if left subtrees and right subtrees are the same.",
                    "solutionCode": "    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force, O(n) is optimal.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function is_same_tree that takes p and q.",
                    "placeholderCode": "def is_same_tree(p, q):",
                    "validationRegex": "^def\\s+is_same_tree\\(p,\\s*q\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def is_same_tree(p, q):"
                },
                {
                    "id": 2,
                    "instruction": "Handle the case where both nodes are None.",
                    "placeholderCode": "    if not p and not q:\n        return True",
                    "validationRegex": "^\\s+if\\s+not\\s+p\\s+and\\s+not\\s+q:\\s*return\\s+True$",
                    "hint": "If both reach None at the same time, this branch is identical.",
                    "solutionCode": "    if not p and not q:\n        return True"
                },
                {
                    "id": 3,
                    "instruction": "Check if one node exists and the other doesn't.",
                    "placeholderCode": "    if not p or not q:",
                    "validationRegex": "^\\s+if\\s+not\\s+p\\s+or\\s+not\\s+q:$",
                    "hint": "Since we already checked if BOTH are None, if this condition is True, it means only ONE is None.",
                    "solutionCode": "    if not p or not q:"
                },
                {
                    "id": 4,
                    "instruction": "Return False if the structural comparison fails.",
                    "placeholderCode": "        return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "Mismatching structures mean the trees are not the same.",
                    "solutionCode": "        return False"
                },
                {
                    "id": 5,
                    "instruction": "Check if the values of the current nodes are different.",
                    "placeholderCode": "    if p.val != q.val:\n        return False",
                    "validationRegex": "^\\s+if\\s+p\\.val\\s*!=\\s*q\\.val:\\s*return\\s+False$",
                    "hint": "Even if structure matches, values must be equal for the trees to be the same.",
                    "solutionCode": "    if p.val != q.val:\n        return False"
                },
                {
                    "id": 6,
                    "instruction": "Recursively check if both the left and right subtrees are identical.",
                    "placeholderCode": "    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)",
                    "validationRegex": "^\\s+return\\s+is_same_tree\\(p\\.left,\\s*q\\.left\\)\\s+and\\s+is_same_tree\\(p\\.right,\\s*q\\.right\\)$",
                    "hint": "The combined result must be True for all nodes in the tree.",
                    "solutionCode": "    return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)"
                }
            ]
        }
    }
}