{
    "id": "find-the-duplicate-number",
    "title": "Find the Duplicate Number",
    "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space.",
    "examples": [
        {
            "input": "nums = [1,3,4,2,2]",
            "output": "2"
        },
        {
            "input": "nums = [3,1,3,4,2]",
            "output": "3"
        }
    ],
    "constraints": [
        "1 <= n <= 10^5",
        "nums.length == n + 1",
        "1 <= nums[i] <= n",
        "All the integers in nums appear only once except for precisely one integer which appears two or more times."
    ],
    "difficulty": "Medium",
    "topic": "Linked List",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Sorting (Not Allowed)",
            "description": "Sort and check adjacent. (Violates constraints)",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'find_duplicate' that takes 'nums' as an argument.",
                    "placeholderCode": "def find_duplicate(nums):",
                    "validationRegex": "^def\\s+find_duplicate\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_duplicate(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Sort the array in-place.",
                    "placeholderCode": "    nums.sort()",
                    "validationRegex": "^\\s+nums\\.sort\\(\\)$",
                    "hint": "Sorting makes duplicate elements adjacent.",
                    "solutionCode": "    nums.sort()"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through the sorted array to find adjacent duplicates.",
                    "placeholderCode": "    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return nums[i]",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(1,\\s*len\\(nums\\)\\):\\s*if\\s+nums\\[i\\]\\s*==\\s*nums\\[i\\s*-\\s*1\\]:\\s*return\\s+nums\\[i\\]$",
                    "hint": "Check if a number is equal to its previous neighbor.",
                    "solutionCode": "    for i in range(1, len(nums)):\n        if nums[i] == nums[i - 1]:\n            return nums[i]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Floyd's Cycle-Finding Algorithm (Tortoise and Hare)",
            "description": "Treat the array as a linked list where indices point to values, and find the start of the resulting cycle.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'find_duplicate' that takes 'nums' as an argument.",
                    "placeholderCode": "def find_duplicate(nums):",
                    "validationRegex": "^def\\s+find_duplicate\\(nums\\):$",
                    "hint": "The input is an array containing n+1 integers.",
                    "solutionCode": "def find_duplicate(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize 'slow' and 'fast' pointers at the first index.",
                    "placeholderCode": "    slow, fast = 0, 0",
                    "validationRegex": "^\\s+slow,\\s*fast\\s*=\\s*0,\\s*0$",
                    "hint": "We treat indices as node addresses and values as next pointers.",
                    "solutionCode": "    slow, fast = 0, 0"
                },
                {
                    "id": 3,
                    "instruction": "Start a loop to find the intersection point within the cycle.",
                    "placeholderCode": "    while True:",
                    "validationRegex": "^\\s+while\\s+True:$",
                    "hint": "Phase 1: Detect that a cycle exists.",
                    "solutionCode": "    while True:"
                },
                {
                    "id": 4,
                    "instruction": "Advance the 'slow' pointer by one step.",
                    "placeholderCode": "        slow = nums[slow]",
                    "validationRegex": "^\\s+slow\\s*=\\s*nums\\[slow\\]$",
                    "hint": "Slow moves to the value at its current index.",
                    "solutionCode": "        slow = nums[slow]"
                },
                {
                    "id": 5,
                    "instruction": "Advance the 'fast' pointer by two steps.",
                    "placeholderCode": "        fast = nums[nums[fast]]",
                    "validationRegex": "^\\s+fast\\s*=\\s*nums\\[nums\\[fast\\]\\]$",
                    "hint": "Fast jumps twice by following the values as indices.",
                    "solutionCode": "        fast = nums[nums[fast]]"
                },
                {
                    "id": 6,
                    "instruction": "Break the loop if the pointers meet.",
                    "placeholderCode": "        if slow == fast:\n            break",
                    "validationRegex": "^\\s+if\\s+slow\\s*==\\s*fast:\\s*break$",
                    "hint": "Collision detected! We've found the intersection point.",
                    "solutionCode": "        if slow == fast:\n            break"
                },
                {
                    "id": 7,
                    "instruction": "Initialize a second 'slow' pointer (slow2) at the start of the array.",
                    "placeholderCode": "    slow2 = 0",
                    "validationRegex": "^\\s+slow2\\s*=\\s*0$",
                    "hint": "Phase 2: Find the distance to the entrance of the cycle.",
                    "solutionCode": "    slow2 = 0"
                },
                {
                    "id": 8,
                    "instruction": "Loop until 'slow' and 'slow2' meet.",
                    "placeholderCode": "    while True:",
                    "validationRegex": "^\\s+while\\s+True:$",
                    "hint": "Both pointers will move at the same speed (1 step).",
                    "solutionCode": "    while True:"
                },
                {
                    "id": 9,
                    "instruction": "Move the first 'slow' pointer by one step.",
                    "placeholderCode": "        slow = nums[slow]",
                    "validationRegex": "^\\s+slow\\s*=\\s*nums\\[slow\\]$",
                    "hint": "Maintain the same movement logic as before.",
                    "solutionCode": "        slow = nums[slow]"
                },
                {
                    "id": 10,
                    "instruction": "Move the 'slow2' pointer by one step.",
                    "placeholderCode": "        slow2 = nums[slow2]",
                    "validationRegex": "^\\s+slow2\\s*=\\s*nums\\[slow2\\]$",
                    "hint": "Slow2 starts at the beginning and moves 1 step.",
                    "solutionCode": "        slow2 = nums[slow2]"
                },
                {
                    "id": 11,
                    "instruction": "Check if they meet; return the value as the duplicate number.",
                    "placeholderCode": "        if slow == slow2:\n            return slow",
                    "validationRegex": "^\\s+if\\s+slow\\s*==\\s*slow2:\\s*return\\s+slow$",
                    "hint": "According to Floyd's math, they will meet exactly at the cycle entrance.",
                    "solutionCode": "        if slow == slow2:\n            return slow"
                }
            ]
        }
    }
}