{
    "id": "counting-bits",
    "title": "Counting Bits",
    "description": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.",
    "examples": [
        {
            "input": "n = 2",
            "output": "[0,1,1]",
            "explanation": "0 --> 0\n1 --> 1\n2 --> 10"
        },
        {
            "input": "n = 5",
            "output": "[0,1,1,2,1,2]",
            "explanation": "0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101"
        }
    ],
    "constraints": [
        "0 <= n <= 10^5"
    ],
    "difficulty": "Easy",
    "topic": "Bit Manipulation",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Count bits for each number.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function count_bits that takes n.",
                    "placeholderCode": "def count_bits(n):",
                    "validationRegex": "^def\\s+count_bits\\(n\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def count_bits(n):"
                },
                {
                    "id": 2,
                    "instruction": "Loop through 0 to n.",
                    "placeholderCode": "    res = []\n    for i in range(n + 1):\n        count = 0\n        while i:\n            i &= (i - 1)\n            count += 1\n        res.append(count)",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*for\\s+i\\s+in\\s+range\\(n\\s*\\+\\s*1\\):\\s*count\\s*=\\s*0\\s*while\\s+i:\\s*i\\s*&=\\s*\\(i\\s*-\\s*1\\)\\s*count\\s*\\+=\\s*1\\s*res\\.append\\(count\\)$",
                    "hint": "Iterate from 0 to n. For each number, count the set bits using `i & (i - 1)`.",
                    "solutionCode": "    res = []\n    for i in range(n + 1):\n        count = 0\n        while i:\n            i &= (i - 1)\n            count += 1\n        res.append(count)"
                },
                {
                    "id": 3,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result list.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Use previous results to compute current.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function count_bits that takes n.",
                    "placeholderCode": "def count_bits(n):",
                    "validationRegex": "^def\\s+count_bits\\(n\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def count_bits(n):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize DP array.",
                    "placeholderCode": "    dp = [0] * (n + 1)",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[0\\]\\s*\\*\\s*\\(n\\s*\\+\\s*1\\)$",
                    "hint": "Initialize a DP array of size n + 1 with zeros.",
                    "solutionCode": "    dp = [0] * (n + 1)"
                },
                {
                    "id": 3,
                    "instruction": "Initialize offset variable.",
                    "placeholderCode": "    offset = 1",
                    "validationRegex": "^\\s+offset\\s*=\\s*1$",
                    "hint": "Offset tracks the most significant bit.",
                    "solutionCode": "    offset = 1"
                },
                {
                    "id": 4,
                    "instruction": "Initiate loop from 1 to n.",
                    "placeholderCode": "    for i in range(1, n + 1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(1,\\s*n\\s*\\+\\s*1\\):$",
                    "hint": "Loop through numbers.",
                    "solutionCode": "    for i in range(1, n + 1):"
                },
                {
                    "id": 5,
                    "instruction": "Check if current number is a power of 2.",
                    "placeholderCode": "        if offset * 2 == i:",
                    "validationRegex": "^\\s+if\\s+offset\\s*\\*\\s*2\\s*==\\s*i:$",
                    "hint": "If `offset * 2 == i`, we found a new power of 2.",
                    "solutionCode": "        if offset * 2 == i:"
                },
                {
                    "id": 6,
                    "instruction": "Update offset.",
                    "placeholderCode": "            offset = i",
                    "validationRegex": "^\\s+offset\\s*=\\s*i$",
                    "hint": "Set `offset` to `i`.",
                    "solutionCode": "            offset = i"
                },
                {
                    "id": 7,
                    "instruction": "Calculate bits using DP relation.",
                    "placeholderCode": "        dp[i] = 1 + dp[i - offset]",
                    "validationRegex": "^\\s+dp\\[i\\]\\s*=\\s*1\\s*\\+\\s*dp\\[i\\s*-\\s*offset\\]$",
                    "hint": "Current bits = 1 + bits of `i - offset`.",
                    "solutionCode": "        dp[i] = 1 + dp[i - offset]"
                },
                {
                    "id": 8,
                    "instruction": "Return result.",
                    "placeholderCode": "    return dp",
                    "validationRegex": "^\\s+return\\s+dp$",
                    "hint": "Return the DP array.",
                    "solutionCode": "    return dp"
                }
            ]
        }
    }
}