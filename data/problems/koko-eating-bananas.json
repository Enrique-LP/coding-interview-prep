{
    "id": "koko-eating-bananas",
    "title": "Koko Eating Bananas",
    "description": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Return the minimum integer k such that she can eat all the bananas within h hours.",
    "examples": [
        {
            "input": "piles = [3,6,7,11], h = 8",
            "output": "4"
        },
        {
            "input": "piles = [30,11,23,4,20], h = 5",
            "output": "30"
        }
    ],
    "constraints": [
        "1 <= piles.length <= 10^4",
        "piles.length <= h <= 10^9",
        "1 <= piles[i] <= 10^9"
    ],
    "difficulty": "Medium",
    "topic": "Binary Search",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Linear Search",
            "description": "Try every speed from 1 to max(piles).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_eating_speed that takes piles and h.",
                    "placeholderCode": "def min_eating_speed(piles, h):",
                    "validationRegex": "^def\\s+min_eating_speed\\(piles,\\s*h\\):$",
                    "hint": "Use `def` to define the function signature.",
                    "solutionCode": "def min_eating_speed(piles, h):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate through every possible speed k starting from 1.",
                    "placeholderCode": "    for k in range(1, max(piles) + 1):",
                    "validationRegex": "^\\s+for\\s+k\\s+in\\s+range\\(1,\\s*max\\(piles\\)\\s*\\+\\s*1\\):$",
                    "hint": "Test every speed until we find one that works.",
                    "solutionCode": "    for k in range(1, max(piles) + 1):"
                },
                {
                    "id": 3,
                    "instruction": "Calculate total hours needed for current speed k.",
                    "placeholderCode": "        total_time = 0\n        for p in piles:\n            total_time += (p + k - 1) // k",
                    "validationRegex": "^\\s+total_time\\s*=\\s*0\\s*for\\s+p\\s+in\\s+piles:\\s*total_time\\s*\\+=\\s*\\(p\\s*\\+\\s*k\\s*-\\s*1\\)\\s*//\\s*k$",
                    "hint": "Use `(p + k - 1) // k` as a native way to calculate `ceil(p / k)`.",
                    "solutionCode": "        total_time = 0\n        for p in piles:\n            total_time += (p + k - 1) // k"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Binary Search",
            "description": "Binary search for the minimum speed k.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_eating_speed that takes piles and h.",
                    "placeholderCode": "def min_eating_speed(piles, h):",
                    "validationRegex": "^def\\s+min_eating_speed\\(piles,\\s*h\\):$",
                    "hint": "Start the problem by defining the function signature.",
                    "solutionCode": "def min_eating_speed(piles, h):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the binary search range [1, max(piles)].",
                    "placeholderCode": "    l, r = 1, max(piles)",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*1,\\s*max\\(piles\\)$",
                    "hint": "Speed can't be less than 1, and there's no point eating faster than the largest pile.",
                    "solutionCode": "    l, r = 1, max(piles)"
                },
                {
                    "id": 3,
                    "instruction": "Initialize a variable to store the best valid speed found.",
                    "placeholderCode": "    res = r",
                    "validationRegex": "^\\s+res\\s*=\\s*r$",
                    "hint": "Assume the maximum speed works and then try to minimize it.",
                    "solutionCode": "    res = r"
                },
                {
                    "id": 4,
                    "instruction": "Start the binary search loop (while l <= r).",
                    "placeholderCode": "    while l <= r:",
                    "validationRegex": "^\\s+while\\s+l\\s*<=\\s*r:$",
                    "hint": "Loop until the pointers cross.",
                    "solutionCode": "    while l <= r:"
                },
                {
                    "id": 5,
                    "instruction": "Calculate the middle speed k to test.",
                    "placeholderCode": "        k = (l + r) // 2",
                    "validationRegex": "^\\s+k\\s*=\\s*\\(l\\s*\\+\\s*r\\)\\s*//\\s*2$",
                    "hint": "Find the average speed of the current range.",
                    "solutionCode": "        k = (l + r) // 2"
                },
                {
                    "id": 6,
                    "instruction": "Initialize a counter for the total hours needed.",
                    "placeholderCode": "        hours = 0",
                    "validationRegex": "^\\s+hours\\s*=\\s*0$",
                    "hint": "Reset the hours count for the speed being tested.",
                    "solutionCode": "        hours = 0"
                },
                {
                    "id": 7,
                    "instruction": "Iterate through each pile.",
                    "placeholderCode": "        for p in piles:",
                    "validationRegex": "^\\s+for\\s+p\\s+in\\s+piles:$",
                    "hint": "Sum up the time spent on each pile.",
                    "solutionCode": "        for p in piles:"
                },
                {
                    "id": 8,
                    "instruction": "Calculate hours for the current pile using integer ceiling division.",
                    "placeholderCode": "            hours += (p + k - 1) // k",
                    "validationRegex": "^\\s+hours\\s*\\+=\\s*\\(p\\s*\\+\\s*k\\s*-\\s*1\\)\\s*//\\s*k$",
                    "hint": "A math trick for `ceil(p / k)` in Python for integers is `(p + k - 1) // k`.",
                    "solutionCode": "            hours += (p + k - 1) // k"
                },
                {
                    "id": 9,
                    "instruction": "Check if the current speed allows Koko to finish on time.",
                    "placeholderCode": "        if hours <= h:",
                    "validationRegex": "^\\s+if\\s+hours\\s*<=\\s*h:$",
                    "hint": "If total time is within the limit `h`, this speed works.",
                    "solutionCode": "        if hours <= h:"
                },
                {
                    "id": 10,
                    "instruction": "Update the result and try to find a smaller speed.",
                    "placeholderCode": "            res = min(res, k)\n            r = k - 1",
                    "validationRegex": "^\\s+res\\s*=\\s*min\\(res,\\s*k\\)\\s*r\\s*=\\s*k\\s*-\\s*1$",
                    "hint": "Save this speed and search for even lower speeds to the left.",
                    "solutionCode": "            res = min(res, k)\n            r = k - 1"
                },
                {
                    "id": 11,
                    "instruction": "Otherwise, increase the speed by moving the left pointer.",
                    "placeholderCode": "        else:\n            l = k + 1",
                    "validationRegex": "^\\s+else:\\s*l\\s*=\\s*k\\s*\\+\\s*1$",
                    "hint": "Koko is too slow, move the left pointer to test faster speeds.",
                    "solutionCode": "        else:\n            l = k + 1"
                },
                {
                    "id": 12,
                    "instruction": "Finally, return the minimum calculated speed.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "After the search, `res` contains the minimum possible speed.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}