{
    "id": "container-with-most-water",
    "title": "Container With Most Water",
    "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
    "examples": [
        {
            "input": "height = [1,8,6,2,5,4,8,3,7]",
            "output": "49",
            "explanation": "The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."
        },
        {
            "input": "height = [1,1]",
            "output": "1"
        }
    ],
    "constraints": [
        "n == height.length",
        "2 <= n <= 10^5",
        "0 <= height[i] <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "Two Pointers",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Nested Loops",
            "description": "Check all pairs of lines.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_area that takes height.",
                    "placeholderCode": "def max_area(height):",
                    "validationRegex": "^def\\s+max_area\\(height\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_area(height):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate through all pairs.",
                    "placeholderCode": "    res = 0\n    for l in range(len(height)):\n        for r in range(l + 1, len(height)):\n            area = (r - l) * min(height[l], height[r])\n            res = max(res, area)",
                    "validationRegex": "^\\s+res\\s*=\\s*0\\s*for\\s+l\\s+in\\s+range\\(len\\(height\\)\\):\\s*for\\s+r\\s+in\\s+range\\(l\\s*\\+\\s*1,\\s*len\\(height\\)\\):\\s*area\\s*=\\s*\\(r\\s*-\\s*l\\)\\s*\\*\\s*min\\(height\\[l\\],\\s*height\\[r\\]\\)\\s*res\\s*=\\s*max\\(res,\\s*area\\)$",
                    "hint": "Use nested loops to calculate area for every pair `(l, r)`.",
                    "solutionCode": "    res = 0\n    for l in range(len(height)):\n        for r in range(l + 1, len(height)):\n            area = (r - l) * min(height[l], height[r])\n            res = max(res, area)"
                },
                {
                    "id": 3,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the maximum area found.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Two Pointers",
            "description": "Move pointers inward from ends.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_area that takes height.",
                    "placeholderCode": "def max_area(height):",
                    "validationRegex": "^def\\s+max_area\\(height\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_area(height):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize pointers.",
                    "placeholderCode": "    l, r = 0, len(height) - 1\n    res = 0",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(height\\)\\s*-\\s*1\\s*res\\s*=\\s*0$",
                    "hint": "Set `l` to 0 and `r` to `len(height) - 1`.",
                    "solutionCode": "    l, r = 0, len(height) - 1\n    res = 0"
                },
                {
                    "id": 3,
                    "instruction": "Start the loop to check lines.",
                    "placeholderCode": "    while l < r:",
                    "validationRegex": "^\\s+while\\s+l\\s*<\\s*r:$",
                    "hint": "We continue as long as the left pointer is to the left of the right pointer.",
                    "solutionCode": "    while l < r:"
                },
                {
                    "id": 4,
                    "instruction": "Calculate the area formed by the current lines.",
                    "placeholderCode": "        area = (r - l) * min(height[l], height[r])",
                    "validationRegex": "^\\s+area\\s*=\\s*\\(r\\s*-\\s*l\\)\\s*\\*\\s*min\\(height\\[l\\],\\s*height\\[r\\]\\)$",
                    "hint": "FORMULA: Area = Width * Height.\nWidth = `r - l`.\nHeight = `min(left, right)` because water spills over the shorter wall.\nExample: l=0 (val 1), r=8 (val 7). Width=8. Height=min(1,7)=1. Area = 8 * 1 = 8.",
                    "solutionCode": "        area = (r - l) * min(height[l], height[r])"
                },
                {
                    "id": 5,
                    "instruction": "Update the maximum area found so far.",
                    "placeholderCode": "        res = max(res, area)",
                    "validationRegex": "^\\s+res\\s*=\\s*max\\(res,\\s*area\\)$",
                    "hint": "We want the global maximum. Compare our current `area` (e.g., 8) with the best record so far `res` (e.g., 0). Keep the bigger number.",
                    "solutionCode": "        res = max(res, area)"
                },
                {
                    "id": 6,
                    "instruction": "Move the pointer of the shorter line inward.",
                    "placeholderCode": "        if height[l] < height[r]:\n            l += 1",
                    "validationRegex": "^\\s+if\\s+height\\[l\\]\\s*<\\s+height\\[r\\]:\\s*l\\s*\\+=\\s*1$",
                    "hint": "WHY? The shorter line limits our height. Keeping it useless because width is shrinking. We discard the shorter line (move `l` forward) hoping to find a taller line to support more water.",
                    "solutionCode": "        if height[l] < height[r]:\n            l += 1"
                },
                {
                    "id": 7,
                    "instruction": "Otherwise, move the right pointer.",
                    "placeholderCode": "        else:\n            r -= 1",
                    "validationRegex": "^\\s+else:\\s*r\\s*-=\\s*1$",
                    "hint": "If the right line is shorter (or equal), move the right pointer inward.",
                    "solutionCode": "        else:\n            r -= 1"
                },
                {
                    "id": 8,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the maximum area.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}