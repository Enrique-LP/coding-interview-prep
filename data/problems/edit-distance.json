{
    "id": "edit-distance",
    "title": "Edit Distance",
    "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character, Delete a character, Replace a character.",
    "examples": [
        {
            "input": "word1 = \"horse\", word2 = \"ros\"",
            "output": "3",
            "explanation": "horse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')"
        },
        {
            "input": "word1 = \"intention\", word2 = \"execution\"",
            "output": "5",
            "explanation": "intention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
        }
    ],
    "constraints": [
        "0 <= word1.length, word2.length <= 500",
        "word1 and word2 consist of lowercase English letters."
    ],
    "difficulty": "Medium",
    "topic": "2-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively try insert, delete, and replace operations with memoization to find the minimum edit distance.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_distance that takes strings word1 and word2.",
                    "placeholderCode": "def min_distance(word1, word2):",
                    "validationRegex": "^def\\s+min_distance\\(word1,\\s*word2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_distance(word1, word2):"
                },
                {
                    "id": 2,
                    "instruction": "Define a recursive helper function with a memoization dictionary to store intermediate results.",
                    "placeholderCode": "    memo = {}\n    def dfs(i, j):\n        if i == len(word1): return len(word2) - j\n        if j == len(word2): return len(word1) - i\n        if (i, j) in memo: return memo[(i, j)]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i,\\s*j\\):\\s*if\\s+i\\s*==\\s*len\\(word1\\):\\s*return\\s+len\\(word2\\)\\s*-\\s*j\\s*if\\s+j\\s*==\\s*len\\(word2\\):\\s*return\\s+len\\(word1\\)\\s*-\\s*i\\s*if\\s*\\(i,\\s*j\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(i,\\s*j\\)\\]$",
                    "hint": "Recursive function `dfs(i, j)` returns min ops to convert word1[i:] to word2[j:].",
                    "solutionCode": "    memo = {}\n    def dfs(i, j):\n        if i == len(word1): return len(word2) - j\n        if j == len(word2): return len(word1) - i\n        if (i, j) in memo: return memo[(i, j)]"
                },
                {
                    "id": 3,
                    "instruction": "If the current characters match, no operation is required; simply proceed to the next pair of characters.",
                    "placeholderCode": "        if word1[i] == word2[j]:\n            res = dfs(i + 1, j + 1)",
                    "validationRegex": "^\\s+if\\s+word1\\[i\\]\\s*==\\s+word2\\[j\\]:\\s*res\\s*=\\s*dfs\\(i\\s*\\+\\s*1,\\s*j\\s*\\+\\s*1\\)$",
                    "hint": "If characters match, move both pointers forward.",
                    "solutionCode": "        if word1[i] == word2[j]:\n            res = dfs(i + 1, j + 1)"
                },
                {
                    "id": 4,
                    "instruction": "If characters do not match, recursively calculate the cost for all three possible operations (insert, delete, replace) and take the minimum plus one.",
                    "placeholderCode": "        else:\n            res = 1 + min(dfs(i + 1, j),    # delete\n                          dfs(i, j + 1),    # insert\n                          dfs(i + 1, j + 1)) # replace",
                    "validationRegex": "^\\s+else:\\s*res\\s*=\\s*1\\s*\\+\\s*min\\(dfs\\(i\\s*\\+\\s*1,\\s*j\\),\\s*dfs\\(i,\\s*j\\s*\\+\\s*1\\),\\s*dfs\\(i\\s*\\+\\s*1,\\s*j\\s*\\+\\s*1\\)\\)$",
                    "hint": "Try delete (skip i), insert (skip j), or replace (skip both). Take min + 1.",
                    "solutionCode": "        else:\n            res = 1 + min(dfs(i + 1, j),    # delete\n                          dfs(i, j + 1),    # insert\n                          dfs(i + 1, j + 1)) # replace"
                },
                {
                    "id": 5,
                    "instruction": "Store the computed result in the memoization dictionary and return it.",
                    "placeholderCode": "        memo[(i, j)] = res\n        return res",
                    "validationRegex": "^\\s+memo\\[\\(i,\\s*j\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in memo and return.",
                    "solutionCode": "        memo[(i, j)] = res\n        return res"
                },
                {
                    "id": 6,
                    "instruction": "Initiate the recursive process by calling the helper function from indices (0, 0).",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start recursion from beginning.",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Use 2D bottom-up dynamic programming to find the minimum edit distance in O(m*n) time and space complexity.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_distance that takes strings word1 and word2.",
                    "placeholderCode": "def min_distance(word1, word2):",
                    "validationRegex": "^def\\s+min_distance\\(word1,\\s*word2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_distance(word1, word2):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP grid with 'inf' values for dimensions (len(word1)+1) by (len(word2)+1).",
                    "placeholderCode": "    dp = [[float('inf')] * (len(word2) + 1) for _ in range(len(word1) + 1)]",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[\\[float\\('inf'\\)\\]\\s*\\*\\s*\\(len\\(word2\\)\\s*\\+\\s*1\\)\\s+for\\s+_\\s+in\\s+range\\(len\\(word1\\)\\s*\\+\\s*1\\)\\]$",
                    "hint": "dp[i][j] stores the min operations to convert word1[i:] to word2[j:].",
                    "solutionCode": "    dp = [[float('inf')] * (len(word2) + 1) for _ in range(len(word1) + 1)]"
                },
                {
                    "id": 3,
                    "instruction": "Populate the bottom row of the DP table as the base case for an empty suffix of word1.",
                    "placeholderCode": "    for j in range(len(word2) + 1): dp[len(word1)][j] = len(word2) - j",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(len\\(word2\\)\\s*\\+\\s*1\\):\\s*dp\\[len\\(word1\\)\\]\\[j\\]\\s*=\\s*len\\(word2\\)\\s*-\\s*j$",
                    "hint": "If word1 is empty, we must insert all remaining characters of word2.",
                    "solutionCode": "    for j in range(len(word2) + 1): dp[len(word1)][j] = len(word2) - j"
                },
                {
                    "id": 4,
                    "instruction": "Populate the rightmost column of the DP table as the base case for an empty suffix of word2.",
                    "placeholderCode": "    for i in range(len(word1) + 1): dp[i][len(word2)] = len(word1) - i",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(word1\\)\\s*\\+\\s*1\\):\\s*dp\\[i\\]\\[len\\(word2\\)\\]\\s*=\\s*len\\(word1\\)\\s*-\\s*i$",
                    "hint": "If word2 is empty, we must delete all remaining characters of word1.",
                    "solutionCode": "    for i in range(len(word1) + 1): dp[i][len(word2)] = len(word1) - i"
                },
                {
                    "id": 5,
                    "instruction": "Iterate backwards through both strings and fill the DP table based on character matches and operations.",
                    "placeholderCode": "    for i in range(len(word1) - 1, -1, -1):\n        for j in range(len(word2) - 1, -1, -1):\n            if word1[i] == word2[j]:\n                dp[i][j] = dp[i + 1][j + 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(word1\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):\\s*for\\s+j\\s+in\\s+range\\(len\\(word2\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):\\s*if\\s+word1\\[i\\]\\s*==\\s+word2\\[j\\]:\\s*dp\\[i\\]\\[j\\]\\s*=\\s*dp\\[i\\s*\\+\\s*1\\]\\[j\\s*\\+\\s*1\\]\\s*else:\\s*dp\\[i\\]\\[j\\]\\s*=\\s*1\\s*\\+\\s*min\\(dp\\[i\\s*\\+\\s*1\\]\\[j\\],\\s*dp\\[i\\]\\[j\\s*\\+\\s*1\\],\\s*dp\\[i\\s*\\+\\s*1\\]\\[j\\s*\\+\\s*1\\]\\)$",
                    "hint": "If characters match, take the diagonal result. Else, take 1 + the minimum of delete, insert, or replace.",
                    "solutionCode": "    for i in range(len(word1) - 1, -1, -1):\n        for j in range(len(word2) - 1, -1, -1):\n            if word1[i] == word2[j]:\n                dp[i][j] = dp[i + 1][j + 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])"
                },
                {
                    "id": 6,
                    "instruction": "Return the final edit distance from the top-left of the DP table.",
                    "placeholderCode": "    return dp[0][0]",
                    "validationRegex": "^\\s+return\\s+dp\\[0\\]\\[0\\]$",
                    "hint": "The result dp[0][0] represents the minimum operations for the full strings.",
                    "solutionCode": "    return dp[0][0]"
                }
            ]
        }
    }
}