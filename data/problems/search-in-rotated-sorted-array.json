{
    "id": "search-in-rotated-sorted-array",
    "title": "Search in Rotated Sorted Array",
    "description": "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.",
    "examples": [
        {
            "input": "nums = [4,5,6,7,0,1,2], target = 0",
            "output": "4"
        },
        {
            "input": "nums = [4,5,6,7,0,1,2], target = 3",
            "output": "-1"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 5000",
        "-10^4 <= nums[i] <= 10^4",
        "All values of nums are unique.",
        "nums is an ascending array that is possibly rotated."
    ],
    "difficulty": "Medium",
    "topic": "Binary Search",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Linear Search",
            "description": "Check every element. (O(n))",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'search' that takes 'nums' and 'target' as arguments.",
                    "placeholderCode": "def search(nums, target):",
                    "validationRegex": "^def\\s+search\\(nums,\\s*target\\):$",
                    "hint": "Use `def` to define the function named `search`.",
                    "solutionCode": "def search(nums, target):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate through the array.",
                    "placeholderCode": "    for i, n in enumerate(nums):",
                    "validationRegex": "^\\s+for\\s+i,\\s*n\\s+in\\s+enumerate\\(nums\\):$",
                    "hint": "Iterate using `enumerate`.",
                    "solutionCode": "    for i, n in enumerate(nums):"
                },
                {
                    "id": 3,
                    "instruction": "If element equals target, return index.",
                    "placeholderCode": "        if n == target:\n            return i",
                    "validationRegex": "^\\s+if\\s+n\\s*==\\s*target:\\s*return\\s+i$",
                    "hint": "Check if current element matches target.",
                    "solutionCode": "        if n == target:\n            return i"
                },
                {
                    "id": 4,
                    "instruction": "Return -1 if not found.",
                    "placeholderCode": "    return -1",
                    "validationRegex": "^\\s+return\\s+-1$",
                    "hint": "Return -1 if not found.",
                    "solutionCode": "    return -1"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Binary Search",
            "description": "Handle the two sorted halves. (O(log n))",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'search' that takes 'nums' and 'target' as arguments.",
                    "placeholderCode": "def search(nums, target):",
                    "validationRegex": "^def\\s+search\\(nums,\\s*target\\):$",
                    "hint": "Use `def` to define the function named `search`.",
                    "solutionCode": "def search(nums, target):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize pointers.",
                    "placeholderCode": "    l, r = 0, len(nums) - 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(nums\\)\\s*-\\s*1$",
                    "hint": "Init `l` and `r`.",
                    "solutionCode": "    l, r = 0, len(nums) - 1"
                },
                {
                    "id": 3,
                    "instruction": "Loop while l <= r.",
                    "placeholderCode": "    while l <= r:",
                    "validationRegex": "^\\s+while\\s+l\\s*<=\\s*r:$",
                    "hint": "Binary search loop.",
                    "solutionCode": "    while l <= r:"
                },
                {
                    "id": 4,
                    "instruction": "Calculate the middle index.",
                    "placeholderCode": "        mid = (l + r) // 2",
                    "validationRegex": "^\\s+mid\\s*=\\s*\\(l\\s*\\+\\s*r\\)\\s*//\\s*2$",
                    "hint": "Find the average of `l` and `r`.",
                    "solutionCode": "        mid = (l + r) // 2"
                },
                {
                    "id": 5,
                    "instruction": "If the middle element is the target, return its index.",
                    "placeholderCode": "        if nums[mid] == target:\n            return mid",
                    "validationRegex": "^\\s+if\\s+nums\\[mid\\]\\s*==\\s*target:\\s*return\\s+mid$",
                    "hint": "Check if we found the target right away.",
                    "solutionCode": "        if nums[mid] == target:\n            return mid"
                },
                {
                    "id": 6,
                    "instruction": "Check if the left half is sorted.",
                    "placeholderCode": "        if nums[l] <= nums[mid]:",
                    "validationRegex": "^\\s+if\\s+nums\\[l\\]\\s*<=\\s+nums\\[mid\\]:$",
                    "hint": "If `nums[l] <= nums[mid]`, the pivot must be in the right half.",
                    "solutionCode": "        if nums[l] <= nums[mid]:"
                },
                {
                    "id": 7,
                    "instruction": "If the target is outside the sorted left half range, look in the right half.",
                    "placeholderCode": "            if target > nums[mid] or target < nums[l]:\n                l = mid + 1",
                    "validationRegex": "^\\s+if\\s+target\\s*>\\s+nums\\[mid\\]\\s+or\\s+target\\s*<\\s+nums\\[l\\]:\\s*l\\s*=\\s*mid\\s*\\+\\s*1$",
                    "hint": "If it's not in the left range, search the right half.",
                    "solutionCode": "            if target > nums[mid] or target < nums[l]:\n                l = mid + 1"
                },
                {
                    "id": 8,
                    "instruction": "Otherwise, the target must be in the left half, so move the right pointer.",
                    "placeholderCode": "            else:\n                r = mid - 1",
                    "validationRegex": "^\\s+else:\\s*r\\s*=\\s*mid\\s*-\\s*1$",
                    "hint": "If it is in the left range, search the left half.",
                    "solutionCode": "            else:\n                r = mid - 1"
                },
                {
                    "id": 9,
                    "instruction": "If the left half was not sorted, the right half must be sorted.",
                    "placeholderCode": "        else:",
                    "validationRegex": "^\\s+else:$",
                    "hint": "If the left side is broken, the right side must be continuous.",
                    "solutionCode": "        else:"
                },
                {
                    "id": 10,
                    "instruction": "Check if target is outside the sorted right half range.",
                    "placeholderCode": "            if target < nums[mid] or target > nums[r]:\n                r = mid - 1",
                    "validationRegex": "^\\s+if\\s+target\\s*<\\s+nums\\[mid\\]\\s+or\\s+target\\s*>\\s+nums\\[r\\]:\\s*r\\s*=\\s*mid\\s*-\\s*1$",
                    "hint": "Check if the target lies within the sorted right section.",
                    "solutionCode": "            if target < nums[mid] or target > nums[r]:\n                r = mid - 1"
                },
                {
                    "id": 11,
                    "instruction": "Otherwise, the target must be in the right half, so move the left pointer.",
                    "placeholderCode": "            else:\n                l = mid + 1",
                    "validationRegex": "^\\s+else:\\s*l\\s*=\\s*mid\\s*\\+\\s*1$",
                    "hint": "Target is in the right half, move the left pointer.",
                    "solutionCode": "            else:\n                l = mid + 1"
                },
                {
                    "id": 12,
                    "instruction": "Return -1 if the target was never found.",
                    "placeholderCode": "    return -1",
                    "validationRegex": "^\\s+return\\s+-1$",
                    "hint": "Final return if target not found in loop.",
                    "solutionCode": "    return -1"
                }
            ]
        }
    }
}