{
    "id": "pacific-atlantic-water-flow",
    "title": "Pacific Atlantic Water Flow",
    "description": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). Rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
    "examples": [
        {
            "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
            "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
        },
        {
            "input": "heights = [[2,1],[1,2]]",
            "output": "[[0,0],[0,1],[1,0],[1,1]]"
        }
    ],
    "constraints": [
        "m == heights.length",
        "n == heights[r].length",
        "1 <= m, n <= 200",
        "0 <= heights[r][c] <= 10^5"
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS from Oceans",
            "description": "Start DFS from ocean borders and find reachable cells.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function pacific_atlantic that takes heights.",
                    "placeholderCode": "def pacific_atlantic(heights):",
                    "validationRegex": "^def\\s+pacific_atlantic\\(heights\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def pacific_atlantic(heights):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions and reachable sets.",
                    "placeholderCode": "    rows, cols = len(heights), len(heights[0])\n    pac, atl = set(), set()",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(heights\\),\\s*len\\(heights\\[0\\]\\)\\s*pac,\\s*atl\\s*=\\s*set\\(\\),\\s*set\\(\\)$",
                    "hint": "Get dimensions and initialize two sets for Pacific and Atlantic reachable cells.",
                    "solutionCode": "    rows, cols = len(heights), len(heights[0])\n    pac, atl = set(), set()"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper.",
                    "placeholderCode": "    def dfs(r, c, visit, prevHeight):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*visit,\\s*prevHeight\\):\\s*if\\s*\\(r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*==\\s*cols\\s+or\\s*\\(r,\\s*c\\)\\s+in\\s+visit\\s+or\\s+heights\\[r\\]\\[c\\]\\s*<\\s+prevHeight\\):\\s*return\\s*visit\\.add\\(\\(r,\\s*c\\)\\)\\s*dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r\\s*-\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*-\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Recursive DFS. Check bounds, visited status, and height condition (must be >= prevHeight to flow FROM ocean).\\n\\nExample:\\nHeights=[[1, 2], [2, 3]]. Pacific touches top/left.\\nDFS from (0,0) [Height 1]: Reachable.\\nCheck (0,1) [Height 2]: 2 >= 1. Reachable.\\nCheck (1,0) [Height 2]: 2 >= 1. Reachable.\\nCheck (1,1) [Height 3]: 3 >= 2. Reachable.",
                    "solutionCode": "    def dfs(r, c, visit, prevHeight):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])"
                },
                {
                    "id": 4,
                    "instruction": "Run DFS from all borders.",
                    "placeholderCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):\\s*dfs\\(0,\\s*c,\\s*pac,\\s*heights\\[0\\]\\[c\\]\\)\\s*dfs\\(rows\\s*-\\s*1,\\s*c,\\s*atl,\\s*heights\\[rows\\s*-\\s*1\\]\\[c\\]\\)\\s*for\\s+r\\s+in\\s+range\\(rows\\):\\s*dfs\\(r,\\s*0,\\s*pac,\\s*heights\\[r\\]\\[0\\]\\)\\s*dfs\\(r,\\s*cols\\s*-\\s*1,\\s*atl,\\s*heights\\[r\\]\\[cols\\s*-\\s*1\\]\\)$",
                    "hint": "Start DFS from top/left (Pacific) and bottom/right (Atlantic) borders.",
                    "solutionCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])"
                },
                {
                    "id": 5,
                    "instruction": "Return intersection of reachable sets.",
                    "placeholderCode": "    return list(pac.intersection(atl))",
                    "validationRegex": "^\\s+return\\s+list\\(pac\\.intersection\\(atl\\)\\)$",
                    "hint": "Return the list of coordinates reachable from both oceans.",
                    "solutionCode": "    return list(pac.intersection(atl))"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "DFS from Oceans",
            "description": "Same as brute force, O(m*n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function pacific_atlantic that takes heights.",
                    "placeholderCode": "def pacific_atlantic(heights):",
                    "validationRegex": "^def\\s+pacific_atlantic\\(heights\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def pacific_atlantic(heights):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions and reachable sets.",
                    "placeholderCode": "    rows, cols = len(heights), len(heights[0])\n    pac, atl = set(), set()",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(heights\\),\\s*len\\(heights\\[0\\]\\)\\s*pac,\\s*atl\\s*=\\s*set\\(\\),\\s*set\\(\\)$",
                    "hint": "Get dimensions and initialize two sets for Pacific and Atlantic reachable cells.",
                    "solutionCode": "    rows, cols = len(heights), len(heights[0])\n    pac, atl = set(), set()"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper.",
                    "placeholderCode": "    def dfs(r, c, visit, prevHeight):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*visit,\\s*prevHeight\\):\\s*if\\s*\\(r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*==\\s*cols\\s+or\\s*\\(r,\\s*c\\)\\s+in\\s+visit\\s+or\\s+heights\\[r\\]\\[c\\]\\s*<\\s+prevHeight\\):\\s*return\\s*visit\\.add\\(\\(r,\\s*c\\)\\)\\s*dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r\\s*-\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*-\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Recursive DFS. Check bounds, visited status, and height condition (must be >= prevHeight to flow FROM ocean).\\n\\nExample:\\nHeights=[[1, 2], [2, 3]]. Pacific touches top/left.\\nDFS from (0,0) [Height 1]: Reachable.\\nCheck (0,1) [Height 2]: 2 >= 1. Reachable.\\nCheck (1,0) [Height 2]: 2 >= 1. Reachable.\\nCheck (1,1) [Height 3]: 3 >= 2. Reachable.",
                    "solutionCode": "    def dfs(r, c, visit, prevHeight):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])"
                },
                {
                    "id": 4,
                    "instruction": "Run DFS from all borders.",
                    "placeholderCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):\\s*dfs\\(0,\\s*c,\\s*pac,\\s*heights\\[0\\]\\[c\\]\\)\\s*dfs\\(rows\\s*-\\s*1,\\s*c,\\s*atl,\\s*heights\\[rows\\s*-\\s*1\\]\\[c\\]\\)\\s*for\\s+r\\s+in\\s+range\\(rows\\):\\s*dfs\\(r,\\s*0,\\s*pac,\\s*heights\\[r\\]\\[0\\]\\)\\s*dfs\\(r,\\s*cols\\s*-\\s*1,\\s*atl,\\s*heights\\[r\\]\\[cols\\s*-\\s*1\\]\\)$",
                    "hint": "Start DFS from top/left (Pacific) and bottom/right (Atlantic) borders.",
                    "solutionCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])"
                },
                {
                    "id": 5,
                    "instruction": "Return intersection of reachable sets.",
                    "placeholderCode": "    return list(pac.intersection(atl))",
                    "validationRegex": "^\\s+return\\s+list\\(pac\\.intersection\\(atl\\)\\)$",
                    "hint": "Return the list of coordinates reachable from both oceans.",
                    "solutionCode": "    return list(pac.intersection(atl))"
                }
            ]
        }
    }
}