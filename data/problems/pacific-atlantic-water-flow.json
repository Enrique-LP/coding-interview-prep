{
    "id": "pacific-atlantic-water-flow",
    "title": "Pacific Atlantic Water Flow",
    "description": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). Rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
    "examples": [
        {
            "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
            "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
        },
        {
            "input": "heights = [[2,1],[1,2]]",
            "output": "[[0,0],[0,1],[1,0],[1,1]]"
        }
    ],
    "constraints": [
        "m == heights.length",
        "n == heights[r].length",
        "1 <= m, n <= 200",
        "0 <= heights[r][c] <= 10^5"
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Start DFS from ocean borders and find reachable cells.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function pacific_atlantic that takes heights.",
                    "placeholderCode": "def pacific_atlantic(heights):",
                    "validationRegex": "^def\\s+pacific_atlantic\\(heights\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def pacific_atlantic(heights):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions and reachable sets.",
                    "placeholderCode": "    rows, cols = len(heights), len(heights[0])\n    pac, atl = set(), set()",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(heights\\),\\s*len\\(heights\\[0\\]\\)\\s*pac,\\s*atl\\s*=\\s*set\\(\\),\\s*set\\(\\)$",
                    "hint": "Get dimensions and initialize two sets for Pacific and Atlantic reachable cells.",
                    "solutionCode": "    rows, cols = len(heights), len(heights[0])\n    pac, atl = set(), set()"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper.",
                    "placeholderCode": "    def dfs(r, c, visit, prevHeight):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*visit,\\s*prevHeight\\):\\s*if\\s*\\(r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*==\\s*cols\\s+or\\s*\\(r,\\s*c\\)\\s+in\\s+visit\\s+or\\s+heights\\[r\\]\\[c\\]\\s*<\\s+prevHeight\\):\\s*return\\s*visit\\.add\\(\\(r,\\s*c\\)\\)\\s*dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r\\s*-\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*-\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Recursive DFS. Check bounds, visited status, and height condition (must be >= prevHeight to flow FROM ocean).\\n\\nExample:\\nHeights=[[1, 2], [2, 3]]. Pacific touches top/left.\\nDFS from (0,0) [Height 1]: Reachable.\\nCheck (0,1) [Height 2]: 2 >= 1. Reachable.\\nCheck (1,0) [Height 2]: 2 >= 1. Reachable.\\nCheck (1,1) [Height 3]: 3 >= 2. Reachable.",
                    "solutionCode": "    def dfs(r, c, visit, prevHeight):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])"
                },
                {
                    "id": 4,
                    "instruction": "Run DFS from all borders.",
                    "placeholderCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):\\s*dfs\\(0,\\s*c,\\s*pac,\\s*heights\\[0\\]\\[c\\]\\)\\s*dfs\\(rows\\s*-\\s*1,\\s*c,\\s*atl,\\s*heights\\[rows\\s*-\\s*1\\]\\[c\\]\\)\\s*for\\s+r\\s+in\\s+range\\(rows\\):\\s*dfs\\(r,\\s*0,\\s*pac,\\s*heights\\[r\\]\\[0\\]\\)\\s*dfs\\(r,\\s*cols\\s*-\\s*1,\\s*atl,\\s*heights\\[r\\]\\[cols\\s*-\\s*1\\]\\)$",
                    "hint": "Start DFS from top/left (Pacific) and bottom/right (Atlantic) borders.",
                    "solutionCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])"
                },
                {
                    "id": 5,
                    "instruction": "Return intersection of reachable sets.",
                    "placeholderCode": "    return list(pac.intersection(atl))",
                    "validationRegex": "^\\s+return\\s+list\\(pac\\.intersection\\(atl\\)\\)$",
                    "hint": "Return the list of coordinates reachable from both oceans.",
                    "solutionCode": "    return list(pac.intersection(atl))"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force, O(m*n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function pacific_atlantic that takes heights.",
                    "placeholderCode": "def pacific_atlantic(heights):",
                    "validationRegex": "^def\\s+pacific_atlantic\\(heights\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def pacific_atlantic(heights):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions (rows and cols).",
                    "placeholderCode": "    rows, cols = len(heights), len(heights[0])",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(heights\\),\\s*len\\(heights\\[0\\]\\)$",
                    "hint": "Get the number of rows and columns from the heights grid.",
                    "solutionCode": "    rows, cols = len(heights), len(heights[0])"
                },
                {
                    "id": 3,
                    "instruction": "Initialize sets to track reachable cells for Pacific and Atlantic oceans.",
                    "placeholderCode": "    pac, atl = set(), set()",
                    "validationRegex": "^\\s+pac,\\s*atl\\s*=\\s*set\\(\\),\\s*set\\(\\)$",
                    "hint": "Create two empty sets: one for Pacific and one for Atlantic reachable coordinates.",
                    "solutionCode": "    pac, atl = set(), set()"
                },
                {
                    "id": 4,
                    "instruction": "Define DFS helper function header.",
                    "placeholderCode": "    def dfs(r, c, visit, prevHeight):",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*visit,\\s*prevHeight\\):$",
                    "hint": "Define the DFS function with row, col, the visit set, and the height of the previous cell.",
                    "solutionCode": "    def dfs(r, c, visit, prevHeight):"
                },
                {
                    "id": 5,
                    "instruction": "Check base cases: out-of-bounds, already visited, or height condition.",
                    "placeholderCode": "        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):",
                    "validationRegex": "^\\s+if\\s*\\(r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*==\\s*cols\\s+or\\s*\\(r,\\s*c\\)\\s+in\\s+visit\\s+or\\s+heights\\[r\\]\\[c\\]\\s*<\\s+prevHeight\\):$",
                    "hint": "Return if the cell is invalid, already visited, or its height is lower than the previous cell's height.",
                    "solutionCode": "        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):"
                },
                {
                    "id": 6,
                    "instruction": "Return if base cases are met.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "Stop the current DFS recursion if the conditions are true.",
                    "solutionCode": "            return"
                },
                {
                    "id": 7,
                    "instruction": "Mark the current cell as visited in the appropriate ocean set.",
                    "placeholderCode": "        visit.add((r, c))",
                    "validationRegex": "^\\s+visit\\.add\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Add the row and column tuple to the current visit set.",
                    "solutionCode": "        visit.add((r, c))"
                },
                {
                    "id": 8,
                    "instruction": "Recursively call DFS for the cell to the South.",
                    "placeholderCode": "        dfs(r + 1, c, visit, heights[r][c])",
                    "validationRegex": "^\\s+dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Move down in the grid.",
                    "solutionCode": "        dfs(r + 1, c, visit, heights[r][c])"
                },
                {
                    "id": 9,
                    "instruction": "Recursively call DFS for the cell to the North.",
                    "placeholderCode": "        dfs(r - 1, c, visit, heights[r][c])",
                    "validationRegex": "^\\s+dfs\\(r\\s*-\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Move up in the grid.",
                    "solutionCode": "        dfs(r - 1, c, visit, heights[r][c])"
                },
                {
                    "id": 10,
                    "instruction": "Recursively call DFS for the cell to the East.",
                    "placeholderCode": "        dfs(r, c + 1, visit, heights[r][c])",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Move right in the grid.",
                    "solutionCode": "        dfs(r, c + 1, visit, heights[r][c])"
                },
                {
                    "id": 11,
                    "instruction": "Recursively call DFS for the cell to the West.",
                    "placeholderCode": "        dfs(r, c - 1, visit, heights[r][c])",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c\\s*-\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Move left in the grid.",
                    "solutionCode": "        dfs(r, c - 1, visit, heights[r][c])"
                },
                {
                    "id": 12,
                    "instruction": "Iterate through every column in the grid.",
                    "placeholderCode": "    for c in range(cols):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):$",
                    "hint": "Use a for loop to iterate from 0 to cols - 1.",
                    "solutionCode": "    for c in range(cols):"
                },
                {
                    "id": 13,
                    "instruction": "Start DFS from the top border (Pacific Ocean) for each column.",
                    "placeholderCode": "        dfs(0, c, pac, heights[0][c])",
                    "validationRegex": "^\\s+dfs\\(0,\\s*c,\\s*pac,\\s*heights\\[0\\]\\[c\\]\\)$",
                    "hint": "Call the DFS helper starting at row 0.",
                    "solutionCode": "        dfs(0, c, pac, heights[0][c])"
                },
                {
                    "id": 14,
                    "instruction": "Start DFS from the bottom border (Atlantic Ocean) for each column.",
                    "placeholderCode": "        dfs(rows - 1, c, atl, heights[rows - 1][c])",
                    "validationRegex": "^\\s+dfs\\(rows\\s*-\\s*1,\\s*c,\\s*atl,\\s*heights\\[rows\\s*-\\s*1\\]\\[c\\]\\)$",
                    "hint": "Call the DFS helper starting at the last row.",
                    "solutionCode": "        dfs(rows - 1, c, atl, heights[rows - 1][c])"
                },
                {
                    "id": 15,
                    "instruction": "Iterate through every row in the grid.",
                    "placeholderCode": "    for r in range(rows):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):$",
                    "hint": "Use a for loop to iterate from 0 to rows - 1.",
                    "solutionCode": "    for r in range(rows):"
                },
                {
                    "id": 16,
                    "instruction": "Start DFS from the left border (Pacific Ocean) for each row.",
                    "placeholderCode": "        dfs(r, 0, pac, heights[r][0])",
                    "validationRegex": "^\\s+dfs\\(r,\\s*0,\\s*pac,\\s*heights\\[r\\]\\[0\\]\\)$",
                    "hint": "Call the DFS helper starting at column 0.",
                    "solutionCode": "        dfs(r, 0, pac, heights[r][0])"
                },
                {
                    "id": 17,
                    "instruction": "Start DFS from the right border (Atlantic Ocean) for each row.",
                    "placeholderCode": "        dfs(r, cols - 1, atl, heights[r][cols - 1])",
                    "validationRegex": "^\\s+dfs\\(r,\\s*cols\\s*-\\s*1,\\s*atl,\\s*heights\\[r\\]\\[cols\\s*-\\s*1\\]\\)$",
                    "hint": "Call the DFS helper starting at the last column.",
                    "solutionCode": "        dfs(r, cols - 1, atl, heights[r][cols - 1])"
                },
                {
                    "id": 18,
                    "instruction": "Return intersection of reachable sets.",
                    "placeholderCode": "    return list(pac.intersection(atl))",
                    "validationRegex": "^\\s+return\\s+list\\(pac\\.intersection\\(atl\\)\\)$",
                    "hint": "Return the list of coordinates reachable from both oceans.",
                    "solutionCode": "    return list(pac.intersection(atl))"
                }
            ]
        }
    }
}