{
    "id": "pacific-atlantic-water-flow",
    "title": "Pacific Atlantic Water Flow",
    "description": "There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c). Rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean. Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.",
    "examples": [
        {
            "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
            "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
        },
        {
            "input": "heights = [[2,1],[1,2]]",
            "output": "[[0,0],[0,1],[1,0],[1,1]]"
        }
    ],
    "constraints": [
        "m == heights.length",
        "n == heights[r].length",
        "1 <= m, n <= 200",
        "0 <= heights[r][c] <= 10^5"
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS from Oceans",
            "description": "Start DFS from ocean borders and find reachable cells.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function pacific_atlantic that takes heights.",
                    "placeholderCode": "def pacific_atlantic(heights):",
                    "validationRegex": "^def\\s+pacific_atlantic\\(heights\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def pacific_atlantic(heights):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions and reachable sets.",
                    "placeholderCode": "    rows, cols = len(heights), len(heights[0])\n    pac, atl = set(), set()",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(heights\\),\\s*len\\(heights\\[0\\]\\)\\s*pac,\\s*atl\\s*=\\s*set\\(\\),\\s*set\\(\\)$",
                    "hint": "Get dimensions and initialize two sets for Pacific and Atlantic reachable cells.",
                    "solutionCode": "    rows, cols = len(heights), len(heights[0])\n    pac, atl = set(), set()"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper.",
                    "placeholderCode": "    def dfs(r, c, visit, prevHeight):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*visit,\\s*prevHeight\\):\\s*if\\s*\\(r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*==\\s*cols\\s+or\\s*\\(r,\\s*c\\)\\s+in\\s+visit\\s+or\\s+heights\\[r\\]\\[c\\]\\s*<\\s+prevHeight\\):\\s*return\\s*visit\\.add\\(\\(r,\\s*c\\)\\)\\s*dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r\\s*-\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*-\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Recursive DFS. Check bounds, visited status, and height condition (must be >= prevHeight to flow FROM ocean).\\n\\nExample:\\nHeights=[[1, 2], [2, 3]]. Pacific touches top/left.\\nDFS from (0,0) [Height 1]: Reachable.\\nCheck (0,1) [Height 2]: 2 >= 1. Reachable.\\nCheck (1,0) [Height 2]: 2 >= 1. Reachable.\\nCheck (1,1) [Height 3]: 3 >= 2. Reachable.",
                    "solutionCode": "    def dfs(r, c, visit, prevHeight):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            (r, c) in visit or heights[r][c] < prevHeight):\n            return\n        visit.add((r, c))\n        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])\n        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])"
                },
                {
                    "id": 4,
                    "instruction": "Run DFS from all borders.",
                    "placeholderCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):\\s*dfs\\(0,\\s*c,\\s*pac,\\s*heights\\[0\\]\\[c\\]\\)\\s*dfs\\(rows\\s*-\\s*1,\\s*c,\\s*atl,\\s*heights\\[rows\\s*-\\s*1\\]\\[c\\]\\)\\s*for\\s+r\\s+in\\s+range\\(rows\\):\\s*dfs\\(r,\\s*0,\\s*pac,\\s*heights\\[r\\]\\[0\\]\\)\\s*dfs\\(r,\\s*cols\\s*-\\s*1,\\s*atl,\\s*heights\\[r\\]\\[cols\\s*-\\s*1\\]\\)$",
                    "hint": "Start DFS from top/left (Pacific) and bottom/right (Atlantic) borders.",
                    "solutionCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])"
                },
                {
                    "id": 5,
                    "instruction": "Return intersection of reachable sets.",
                    "placeholderCode": "    return list(pac.intersection(atl))",
                    "validationRegex": "^\\s+return\\s+list\\(pac\\.intersection\\(atl\\)\\)$",
                    "hint": "Return the list of coordinates reachable from both oceans.",
                    "solutionCode": "    return list(pac.intersection(atl))"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "DFS from Oceans",
            "description": "Same as brute force, O(m*n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function pacific_atlantic that takes heights.",
                    "placeholderCode": "def pacific_atlantic(heights):",
                    "validationRegex": "^def\\s+pacific_atlantic\\(heights\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def pacific_atlantic(heights):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions (rows and cols).",
                    "placeholderCode": "    rows, cols = len(heights), len(heights[0])",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(heights\\),\\s*len\\(heights\\[0\\]\\)$",
                    "hint": "Get the number of rows and columns from the heights grid.",
                    "solutionCode": "    rows, cols = len(heights), len(heights[0])"
                },
                {
                    "id": 3,
                    "instruction": "Initialize sets to track reachable cells for Pacific and Atlantic oceans.",
                    "placeholderCode": "    pac, atl = set(), set()",
                    "validationRegex": "^\\s+pac,\\s*atl\\s*=\\s*set\\(\\),\\s*set\\(\\)$",
                    "hint": "Create two empty sets: one for Pacific and one for Atlantic reachable coordinates.",
                    "solutionCode": "    pac, atl = set(), set()"
                },
                {
                    "id": 4,
                    "instruction": "Define DFS helper function header.",
                    "placeholderCode": "    def dfs(r, c, visit, prevHeight):",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*visit,\\s*prevHeight\\):$",
                    "hint": "Define the DFS function with row, col, the visit set, and the height of the previous cell.",
                    "solutionCode": "    def dfs(r, c, visit, prevHeight):"
                },
                {
                    "id": 5,
                    "instruction": "Add base cases for out-of-bounds cells.",
                    "placeholderCode": "        if (r < 0 or c < 0 or r == rows or c == cols or",
                    "validationRegex": "^\\s+if\\s*\\(r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*==\\s*cols\\s+or$",
                    "hint": "Check if the current row or column is outside the grid dimensions.",
                    "solutionCode": "        if (r < 0 or c < 0 or r == rows or c == cols or"
                },
                {
                    "id": 6,
                    "instruction": "Add base cases for visited cells or height condition.",
                    "placeholderCode": "            (r, c) in visit or heights[r][c] < prevHeight):",
                    "validationRegex": "^\\s+\\(r,\\s*c\\)\\s+in\\s+visit\\s+or\\s+heights\\[r\\]\\[c\\]\\s*<\\s+prevHeight\\):$",
                    "hint": "The water can only flow to a cell if its height is greater than or equal to the previous cell's height (since we are moving from ocean to land).",
                    "solutionCode": "            (r, c) in visit or heights[r][c] < prevHeight):"
                },
                {
                    "id": 7,
                    "instruction": "Return if base cases are met.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "If any base case is true, we stop the current DFS path.",
                    "solutionCode": "            return"
                },
                {
                    "id": 8,
                    "instruction": "Mark the current cell as visited in the appropriate ocean set.",
                    "placeholderCode": "        visit.add((r, c))",
                    "validationRegex": "^\\s+visit\\.add\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Add the row and column tuple to the set passed as an argument.",
                    "solutionCode": "        visit.add((r, c))"
                },
                {
                    "id": 9,
                    "instruction": "Recursively call DFS for South and North neighbors.",
                    "placeholderCode": "        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])",
                    "validationRegex": "^\\s+dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r\\s*-\\s*1,\\s*c,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Check the cells below and above the current one.",
                    "solutionCode": "        dfs(r + 1, c, visit, heights[r][c])\n        dfs(r - 1, c, visit, heights[r][c])"
                },
                {
                    "id": 10,
                    "instruction": "Recursively call DFS for East and West neighbors.",
                    "placeholderCode": "        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)\\s*dfs\\(r,\\s*c\\s*-\\s*1,\\s*visit,\\s*heights\\[r\\]\\[c\\]\\)$",
                    "hint": "Check the cells to the right and left of the current one.",
                    "solutionCode": "        dfs(r, c + 1, visit, heights[r][c])\n        dfs(r, c - 1, visit, heights[r][c])"
                },
                {
                    "id": 11,
                    "instruction": "Run DFS from all borders.",
                    "placeholderCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):\\s*dfs\\(0,\\s*c,\\s*pac,\\s*heights\\[0\\]\\[c\\]\\)\\s*dfs\\(rows\\s*-\\s*1,\\s*c,\\s*atl,\\s*heights\\[rows\\s*-\\s*1\\]\\[c\\]\\)\\s*for\\s+r\\s+in\\s+range\\(rows\\):\\s*dfs\\(r,\\s*0,\\s*pac,\\s*heights\\[r\\]\\[0\\]\\)\\s*dfs\\(r,\\s*cols\\s*-\\s*1,\\s*atl,\\s*heights\\[r\\]\\[cols\\s*-\\s*1\\]\\)$",
                    "hint": "Start DFS from top/left (Pacific) and bottom/right (Atlantic) borders.",
                    "solutionCode": "    for c in range(cols):\n        dfs(0, c, pac, heights[0][c])\n        dfs(rows - 1, c, atl, heights[rows - 1][c])\n    for r in range(rows):\n        dfs(r, 0, pac, heights[r][0])\n        dfs(r, cols - 1, atl, heights[r][cols - 1])"
                },
                {
                    "id": 12,
                    "instruction": "Return intersection of reachable sets.",
                    "placeholderCode": "    return list(pac.intersection(atl))",
                    "validationRegex": "^\\s+return\\s+list\\(pac\\.intersection\\(atl\\)\\)$",
                    "hint": "Return the list of coordinates reachable from both oceans.",
                    "solutionCode": "    return list(pac.intersection(atl))"
                }
            ]
        }
    }
}