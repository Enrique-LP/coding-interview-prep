{
    "id": "surrounded-regions",
    "title": "Surrounded Regions",
    "description": "Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region.",
    "examples": [
        {
            "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
            "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]"
        },
        {
            "input": "board = [[\"X\"]]",
            "output": "[[\"X\"]]"
        }
    ],
    "constraints": [
        "m == board.length",
        "n == board[i].length",
        "1 <= m, n <= 200",
        "board[i][j] is 'X' or 'O'."
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Mark 'O's connected to border as safe, capture others.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function solve that takes board.",
                    "placeholderCode": "def solve(board):",
                    "validationRegex": "^def\\s+solve\\(board\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def solve(board):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions.",
                    "placeholderCode": "    rows, cols = len(board), len(board[0])",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(board\\),\\s*len\\(board\\[0\\]\\)$",
                    "hint": "Get the number of rows and columns.",
                    "solutionCode": "    rows, cols = len(board), len(board[0])"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper to mark safe 'O's as 'T'.",
                    "placeholderCode": "    def capture(r, c):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            board[r][c] != 'O'):\n            return\n        board[r][c] = 'T'\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)",
                    "validationRegex": "^\\s+def\\s+capture\\(r,\\s*c\\):\\s*if\\s*\\(r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*==\\s*cols\\s+or\\s+board\\[r\\]\\[c\\]\\s*!=\\s*'O'\\):\\s*return\\s*board\\[r\\]\\[c\\]\\s*=\\s*'T'\\s*capture\\(r\\s*\\+\\s*1,\\s*c\\)\\s*capture\\(r\\s*-\\s*1,\\s*c\\)\\s*capture\\(r,\\s*c\\s*\\+\\s*1\\)\\s*capture\\(r,\\s*c\\s*-\\s*1\\)$",
                    "hint": "Recursive DFS. If out of bounds or not 'O', return. Mark current 'O' as 'T' (temporary safe) and recurse.",
                    "solutionCode": "    def capture(r, c):\n        if (r < 0 or c < 0 or r == rows or c == cols or\n            board[r][c] != 'O'):\n            return\n        board[r][c] = 'T'\n        capture(r + 1, c)\n        capture(r - 1, c)\n        capture(r, c + 1)\n        capture(r, c - 1)"
                },
                {
                    "id": 4,
                    "instruction": "Run DFS on border 'O's.",
                    "placeholderCode": "    for r in range(rows):\n        for c in range(cols):\n            if (board[r][c] == 'O' and\n                (r in [0, rows - 1] or c in [0, cols - 1])):\n                capture(r, c)",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):\\s*for\\s+c\\s+in\\s+range\\(cols\\):\\s*if\\s*\\(board\\[r\\]\\[c\\]\\s*==\\s*'O'\\s+and\\s*\\(r\\s+in\\s+\\[0,\\s*rows\\s*-\\s*1\\]\\s+or\\s+c\\s+in\\s+\\[0,\\s*cols\\s*-\\s*1\\]\\)\\):\\s*capture\\(r,\\s*c\\)$",
                    "hint": "Iterate through the board. If a cell is 'O' and on the border, start DFS to mark it and its connected 'O's as safe.",
                    "solutionCode": "    for r in range(rows):\n        for c in range(cols):\n            if (board[r][c] == 'O' and\n                (r in [0, rows - 1] or c in [0, cols - 1])):\n                capture(r, c)"
                },
                {
                    "id": 5,
                    "instruction": "Flip 'O' to 'X' and 'T' back to 'O'.",
                    "placeholderCode": "    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == 'O':\n                board[r][c] = 'X'\n            elif board[r][c] == 'T':\n                board[r][c] = 'O'",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):\\s*for\\s+c\\s+in\\s+range\\(cols\\):\\s*if\\s+board\\[r\\]\\[c\\]\\s*==\\s*'O':\\s*board\\[r\\]\\[c\\]\\s*=\\s*'X'\\s*elif\\s+board\\[r\\]\\[c\\]\\s*==\\s*'T':\\s*board\\[r\\]\\[c\\]\\s*=\\s*'O'$",
                    "hint": "Final pass: change remaining 'O's (surrounded) to 'X', and revert 'T's (safe) back to 'O'.",
                    "solutionCode": "    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == 'O':\n                board[r][c] = 'X'\n            elif board[r][c] == 'T':\n                board[r][c] = 'O'"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force, O(m*n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function solve that takes board.",
                    "placeholderCode": "def solve(board):",
                    "validationRegex": "^def\\s+solve\\(board\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def solve(board):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions.",
                    "placeholderCode": "    rows, cols = len(board), len(board[0])",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(board\\),\\s*len\\(board\\[0\\]\\)$",
                    "hint": "Get the number of rows and columns.",
                    "solutionCode": "    rows, cols = len(board), len(board[0])"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper to mark safe 'O's as 'T'.",
                    "placeholderCode": "    def capture(r, c):",
                    "validationRegex": "^\\s+def\\s+capture\\(r,\\s*c\\):$",
                    "hint": "Start the capture helper function.",
                    "solutionCode": "    def capture(r, c):"
                },
                {
                    "id": 4,
                    "instruction": "Base case: return if row or column is out of bounds.",
                    "placeholderCode": "        if r < 0 or r == rows or c < 0 or c == cols:",
                    "validationRegex": "^\\s+if\\s+r\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*<\\s*0\\s+or\\s+c\\s*==\\s*cols:$",
                    "hint": "Check if the current coordinates are outside the board.",
                    "solutionCode": "        if r < 0 or r == rows or c < 0 or c == cols:"
                },
                {
                    "id": 5,
                    "instruction": "Base case: return if cell is not an 'O'.",
                    "placeholderCode": "        if board[r][c] != 'O':",
                    "validationRegex": "^\\s+if\\s+board\\[r\\]\\[c\\]\\s*!=\\s*'O':$",
                    "hint": "We only continue if the cell is an 'O'.",
                    "solutionCode": "        if board[r][c] != 'O':"
                },
                {
                    "id": 6,
                    "instruction": "Return if base cases are met.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "Exit the recursion if any of the above conditions apply.",
                    "solutionCode": "            return"
                },
                {
                    "id": 7,
                    "instruction": "Mark the cell as temporarily safe ('T').",
                    "placeholderCode": "        board[r][c] = 'T'",
                    "validationRegex": "^\\s+board\\[r\\]\\[c\\]\\s*=\\s*'T'$",
                    "hint": "Set the current board cell to 'T'.",
                    "solutionCode": "        board[r][c] = 'T'"
                },
                {
                    "id": 8,
                    "instruction": "Recursively call capture for the South neighbor.",
                    "placeholderCode": "        capture(r + 1, c)",
                    "validationRegex": "^\\s+capture\\(r\\s*\\+\\s*1,\\s*c\\)$",
                    "hint": "Check the cell below.",
                    "solutionCode": "        capture(r + 1, c)"
                },
                {
                    "id": 9,
                    "instruction": "Recursively call capture for the North neighbor.",
                    "placeholderCode": "        capture(r - 1, c)",
                    "validationRegex": "^\\s+capture\\(r\\s*-\\s*1,\\s*c\\)$",
                    "hint": "Check the cell above.",
                    "solutionCode": "        capture(r - 1, c)"
                },
                {
                    "id": 10,
                    "instruction": "Recursively call capture for the East neighbor.",
                    "placeholderCode": "        capture(r, c + 1)",
                    "validationRegex": "^\\s+capture\\(r,\\s*c\\s*\\+\\s*1\\)$",
                    "hint": "Check the cell to the right.",
                    "solutionCode": "        capture(r, c + 1)"
                },
                {
                    "id": 11,
                    "instruction": "Recursively call capture for the West neighbor.",
                    "placeholderCode": "        capture(r, c - 1)",
                    "validationRegex": "^\\s+capture\\(r,\\s*c\\s*-\\s*1\\)$",
                    "hint": "Check the cell to the left.",
                    "solutionCode": "        capture(r, c - 1)"
                },
                {
                    "id": 12,
                    "instruction": "Iterate through every row of the board.",
                    "placeholderCode": "    for r in range(rows):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):$",
                    "hint": "Use a for loop to iterate from 0 to rows - 1.",
                    "solutionCode": "    for r in range(rows):"
                },
                {
                    "id": 13,
                    "instruction": "Iterate through every column of the board.",
                    "placeholderCode": "        for c in range(cols):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):$",
                    "hint": "Use a nested for loop to iterate from 0 to cols - 1.",
                    "solutionCode": "        for c in range(cols):"
                },
                {
                    "id": 14,
                    "instruction": "Check if the current cell contains an 'O'.",
                    "placeholderCode": "            if board[r][c] == 'O':",
                    "validationRegex": "^\\s+if\\s+board\\[r\\]\\[c\\]\\s*==\\s*'O':$",
                    "hint": "We only care about 'O' cells that are on the border.",
                    "solutionCode": "            if board[r][c] == 'O':"
                },
                {
                    "id": 15,
                    "instruction": "Check if the cell is located on any of the four borders.",
                    "placeholderCode": "                if (r == 0 or r == rows - 1 or c == 0 or c == cols - 1):",
                    "validationRegex": "^\\s+if\\s*\\(r\\s*==\\s*0\\s+or\\s+r\\s*==\\s*rows\\s*-\\s*1\\s+or\\s+c\\s*==\\s*0\\s+or\\s+c\\s*==\\s*cols\\s*-\\s*1\\):$",
                    "hint": "A cell is on the border if its row is 0 or rows-1, or its column is 0 or cols-1.",
                    "solutionCode": "                if (r == 0 or r == rows - 1 or c == 0 or c == cols - 1):"
                },
                {
                    "id": 16,
                    "instruction": "Call the capture helper function for the border 'O'.",
                    "placeholderCode": "                    capture(r, c)",
                    "validationRegex": "^\\s+capture\\(r,\\s*c\\)$",
                    "hint": "Start the DFS/recursion from this cell to mark all connected 'O's as safe.",
                    "solutionCode": "                    capture(r, c)"
                },
                {
                    "id": 17,
                    "instruction": "Iterate through every row once more.",
                    "placeholderCode": "    for r in range(rows):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):$",
                    "hint": "Start a final pass through the grid rows.",
                    "solutionCode": "    for r in range(rows):"
                },
                {
                    "id": 18,
                    "instruction": "Iterate through every column index.",
                    "placeholderCode": "        for c in range(cols):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):$",
                    "hint": "Use a nested loop to access each cell index.",
                    "solutionCode": "        for c in range(cols):"
                },
                {
                    "id": 19,
                    "instruction": "Check if the current cell is still an 'O'.",
                    "placeholderCode": "            if board[r][c] == 'O':",
                    "validationRegex": "^\\s+if\\s+board\\[r\\]\\[c\\]\\s*==\\s*'O':$",
                    "hint": "Any 'O' remaining at this stage is surrounded by 'X's.",
                    "solutionCode": "            if board[r][c] == 'O':"
                },
                {
                    "id": 20,
                    "instruction": "Capture the surrounded region by flipping 'O' to 'X'.",
                    "placeholderCode": "                board[r][c] = 'X'",
                    "validationRegex": "^\\s+board\\[r\\]\\[c\\]\\s*=\\s*'X'$",
                    "hint": "Assign the character 'X' to the current board position.",
                    "solutionCode": "                board[r][c] = 'X'"
                },
                {
                    "id": 21,
                    "instruction": "Check if the current cell is marked as temporarily safe ('T').",
                    "placeholderCode": "            elif board[r][c] == 'T':",
                    "validationRegex": "^\\s+elif\\s+board\\[r\\]\\[c\\]\\s*==\\s*'T':$",
                    "hint": "These were the cells connected to the border.",
                    "solutionCode": "            elif board[r][c] == 'T':"
                },
                {
                    "id": 22,
                    "instruction": "Revert the safe cell back from 'T' to 'O'.",
                    "placeholderCode": "                board[r][c] = 'O'",
                    "validationRegex": "^\\s+board\\[r\\]\\[c\\]\\s*=\\s*'O'$",
                    "hint": "Restore the original 'O' value for safe regions.",
                    "solutionCode": "                board[r][c] = 'O'"
                }
            ]
        }
    }
}