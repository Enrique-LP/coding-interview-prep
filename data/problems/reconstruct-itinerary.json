{
    "id": "reconstruct-itinerary",
    "title": "Reconstruct Itinerary",
    "description": "You are given a list of airline tickets where tickets[i] = [from_i, to_i] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from \"JFK\", thus, the itinerary must begin with \"JFK\". If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"]. You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.",
    "examples": [
        {
            "input": "tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
            "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]"
        },
        {
            "input": "tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]",
            "output": "[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]",
            "explanation": "Another possible reconstruction is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it is larger in lexical order."
        }
    ],
    "constraints": [
        "1 <= tickets.length <= 300",
        "tickets[i].length == 2",
        "from_i.length == 3",
        "to_i.length == 3",
        "from_i and to_i consist of uppercase English letters.",
        "from_i != to_i"
    ],
    "difficulty": "Hard",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "DFS with backtracking.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define findItinerary.",
                    "placeholderCode": "def findItinerary(tickets):",
                    "validationRegex": "^def\\s+findItinerary\\(tickets\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def findItinerary(tickets):"
                },
                {
                    "id": 2,
                    "instruction": "Build graph.",
                    "placeholderCode": "    adj = collections.defaultdict(list)\n    for src, dst in sorted(tickets):\n        adj[src].append(dst)",
                    "validationRegex": "^\\s+adj\\s*=\\s*collections\\.defaultdict\\(list\\)\\s*for\\s+src,\\s*dst\\s+in\\s+sorted\\(tickets\\):\\s*adj\\[src\\]\\.append\\(dst\\)$",
                    "hint": "Create adjacency list. Sort tickets to ensure lexical order.",
                    "solutionCode": "    adj = collections.defaultdict(list)\n    for src, dst in sorted(tickets):\n        adj[src].append(dst)"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS.",
                    "placeholderCode": "    res = [\"JFK\"]\n    def dfs(src):\n        if len(res) == len(tickets) + 1:\n            return True\n        if src not in adj:\n            return False\n        temp = list(adj[src])\n        for i, v in enumerate(temp):\n            adj[src].pop(i)\n            res.append(v)\n            if dfs(v):\n                return True\n            adj[src].insert(i, v)\n            res.pop()\n        return False",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\"JFK\"\\]\\s*def\\s+dfs\\(src\\):\\s*if\\s+len\\(res\\)\\s*==\\s*len\\(tickets\\)\\s*\\+\\s*1:\\s*return\\s+True\\s*if\\s+src\\s+not\\s+in\\s+adj:\\s*return\\s+False\\s*temp\\s*=\\s*list\\(adj\\[src\\]\\)\\s*for\\s+i,\\s*v\\s+in\\s+enumerate\\(temp\\):\\s*adj\\[src\\]\\.pop\\(i\\)\\s*res\\.append\\(v\\)\\s*if\\s+dfs\\(v\\):\\s*return\\s+True\\s*adj\\[src\\]\\.insert\\(i,\\s*v\\)\\s*res\\.pop\\(\\)\\s*return\\s+False$",
                    "hint": "Backtracking DFS. Try each edge, if it leads to solution return True. Else backtrack (restore edge).\\n\\nExample:\\nTickets=[[JFK, SFO], [JFK, ATL], [SFO, ATL], [ATL, JFK], [ATL, SFO]].\\nDFS(JFK). Try JFK->ATL. Recurse(ATL).\\n  Try ATL->JFK. Recurse(JFK).\\n    Try JFK->SFO. Recurse(SFO).\\n      Try SFO->ATL. Recurse(ATL).\\n        Try ATL->SFO. Recurse(SFO). Done.",
                    "solutionCode": "    res = [\"JFK\"]\n    def dfs(src):\n        if len(res) == len(tickets) + 1:\n            return True\n        if src not in adj:\n            return False\n        temp = list(adj[src])\n        for i, v in enumerate(temp):\n            adj[src].pop(i)\n            res.append(v)\n            if dfs(v):\n                return True\n            adj[src].insert(i, v)\n            res.pop()\n        return False"
                },
                {
                    "id": 4,
                    "instruction": "Call DFS.",
                    "placeholderCode": "    dfs(\"JFK\")\n    return res",
                    "validationRegex": "^\\s+dfs\\(\"JFK\"\\)\\s*return\\s+res$",
                    "hint": "Start DFS from JFK.",
                    "solutionCode": "    dfs(\"JFK\")\n    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Find Eulerian path.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define findItinerary.",
                    "placeholderCode": "def findItinerary(tickets):",
                    "validationRegex": "^def\\s+findItinerary\\(tickets\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def findItinerary(tickets):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the adjacency list as a defaultdict of lists.",
                    "placeholderCode": "    adj = collections.defaultdict(list)",
                    "validationRegex": "^\\s+adj\\s*=\\s*collections\\.defaultdict\\(list\\)$",
                    "hint": "Using defaultdict prevents errors when accessing missing keys.",
                    "solutionCode": "    adj = collections.defaultdict(list)"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through sorted tickets in reverse order.",
                    "placeholderCode": "    for src, dst in sorted(tickets, reverse=True):",
                    "validationRegex": "^\\s+for\\s+src,\\s*dst\\s+in\\s+sorted\\(tickets,\\s*reverse=True\\):$",
                    "hint": "Reverse sorting allows O(1) popping from the end to get the smallest lexical destination first.",
                    "solutionCode": "    for src, dst in sorted(tickets, reverse=True):"
                },
                {
                    "id": 4,
                    "instruction": "Add each destination to the source's list in the adjacency map.",
                    "placeholderCode": "        adj[src].append(dst)",
                    "validationRegex": "^\\s+adj\\[src\\]\\.append\\(dst\\)$",
                    "hint": "Build the graph connections.",
                    "solutionCode": "        adj[src].append(dst)"
                },
                {
                    "id": 5,
                    "instruction": "Initialize the result list to store the itinerary in reverse.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "We use a list that we will fill from end to start.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 6,
                    "instruction": "Define the helper function 'dfs(src)'.",
                    "placeholderCode": "    def dfs(src):",
                    "validationRegex": "^\\s+def\\s+dfs\\(src\\):$",
                    "hint": "This function will visit all edges using Hierholzer's algorithm.",
                    "solutionCode": "    def dfs(src):"
                },
                {
                    "id": 7,
                    "instruction": "While there are outgoing flights from the current airport 'src'.",
                    "placeholderCode": "        while adj[src]:",
                    "validationRegex": "^\\s+while\\s+adj\\[src\\]:$",
                    "hint": "This loop continues as long as the airport has unvisited tickets.",
                    "solutionCode": "        while adj[src]:"
                },
                {
                    "id": 8,
                    "instruction": "Pop the next lexically smallest airport 'dst' from the adjacency list.",
                    "placeholderCode": "            dst = adj[src].pop()",
                    "validationRegex": "^\\s+dst\\s*=\\s*adj\\[src\\]\\.pop\\(\\)$",
                    "hint": "Because we sorted in reverse, .pop() gives the smallest destination efficiently.",
                    "solutionCode": "            dst = adj[src].pop()"
                },
                {
                    "id": 9,
                    "instruction": "Recursively call 'dfs' with the destination airport 'dst'.",
                    "placeholderCode": "            dfs(dst)",
                    "validationRegex": "^\\s+dfs\\(dst\\)$",
                    "hint": "Explore the path until we hit a dead end.",
                    "solutionCode": "            dfs(dst)"
                },
                {
                    "id": 10,
                    "instruction": "Once stuck, append the current airport 'src' to the result 'res'.",
                    "placeholderCode": "        res.append(src)",
                    "validationRegex": "^\\s+res\\.append\\(src\\)$",
                    "hint": "This is the 'post-order' step that builds the itinerary in reverse.",
                    "solutionCode": "        res.append(src)"
                },
                {
                    "id": 11,
                    "instruction": "Call DFS starting from 'JFK' and return the reversed itinerary.",
                    "placeholderCode": "    dfs(\"JFK\")\n    return res[::-1]",
                    "validationRegex": "^\\s+dfs\\(\"JFK\"\\)\\s*return\\s+res\\[::-1\\]$",
                    "hint": "All itineraries must start from JFK. We reverse 'res' because we built it backwards.",
                    "solutionCode": "    dfs(\"JFK\")\n    return res[::-1]"
                }
            ]
        }
    }
}