{
    "id": "partition-labels",
    "title": "Partition Labels",
    "description": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.",
    "examples": [
        {
            "input": "s = \"ababcbacadefegdehijhklij\"",
            "output": "[9,7,8]",
            "explanation": "The partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts."
        },
        {
            "input": "s = \"eccbbbbdec\"",
            "output": "[10]"
        }
    ],
    "constraints": [
        "1 <= s.length <= 500",
        "s consists of lowercase English letters."
    ],
    "difficulty": "Medium",
    "topic": "Greedy",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Identify the last occurrence of each character and use a greedy approach to find the smallest partitions that satisfy the condition.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function partition_labels that takes the input string s.",
                    "placeholderCode": "def partition_labels(s):",
                    "validationRegex": "^def\\s+partition_labels\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def partition_labels(s):"
                },
                {
                    "id": 2,
                    "instruction": "Create a frequency dictionary or map to store the last index where each character appears in the string.",
                    "placeholderCode": "    lastIndex = {}\n    for i, c in enumerate(s):\n        lastIndex[c] = i",
                    "validationRegex": "^\\s+lastIndex\\s*=\\s*\\{\\}\\s*for\\s+i,\\s*c\\s+in\\s+enumerate\\(s\\):\\s*lastIndex\\[c\\]\\s*=\\s*i$",
                    "hint": "Iterate through the string once to map each character to its final position.",
                    "solutionCode": "    lastIndex = {}\n    for i, c in enumerate(s):\n        lastIndex[c] = i"
                },
                {
                    "id": 3,
                    "instruction": "Use a sliding window or greedy approach to iterate through the string, maintaining the current partition's end and appending sizes to the result list.",
                    "placeholderCode": "    res = []\n    size, end = 0, 0\n    for i, c in enumerate(s):\n        size += 1\n        end = max(end, lastIndex[c])\n        if i == end:\n            res.append(size)\n            size = 0",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*size,\\s*end\\s*=\\s*0,\\s*0\\s*for\\s+i,\\s*c\\s+in\\s+enumerate\\(s\\):\\s*size\\s*\\+=\\s*1\\s*end\\s*=\\s*max\\(end,\\s*lastIndex\\[c\\]\\)\\s*if\\s+i\\s*==\\s*end:\\s*res\\.append\\(size\\)\\s*size\\s*=\\s*0$",
                    "hint": "Track the furthest 'last index' reached so far. When the current index matches this furthest point, you've found a valid partition.",
                    "solutionCode": "    res = []\n    size, end = 0, 0\n    for i, c in enumerate(s):\n        size += 1\n        end = max(end, lastIndex[c])\n        if i == end:\n            res.append(size)\n            size = 0"
                },
                {
                    "id": 4,
                    "instruction": "Return the list containing the sizes of each partition.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Solve in a single pass O(n) after pre-calculating the last indices of each character using a hash map.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function partition_labels that takes s.",
                    "placeholderCode": "def partition_labels(s):",
                    "validationRegex": "^def\\s+partition_labels\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def partition_labels(s):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize an empty dictionary 'lastIndex' to record the final appearance of each character.",
                    "placeholderCode": "    lastIndex = {}",
                    "validationRegex": "^\\s+lastIndex\\s*=\\s*\\{\\}$",
                    "hint": "This will map characters to their highest index.",
                    "solutionCode": "    lastIndex = {}"
                },
                {
                    "id": 3,
                    "instruction": "Initiate a loop to iterate through the string and capture the index of each character.",
                    "placeholderCode": "    for i, c in enumerate(s):",
                    "validationRegex": "^\\s+for\\s+i,\\s*c\\s+in\\s+enumerate\\(s\\):$",
                    "hint": "Use enumerate to get both index and character.",
                    "solutionCode": "    for i, c in enumerate(s):"
                },
                {
                    "id": 4,
                    "instruction": "Record or update the last seen index for the current character in 'lastIndex'.",
                    "placeholderCode": "        lastIndex[c] = i",
                    "validationRegex": "^\\s+lastIndex\\[c\\]\\s*=\\s*i$",
                    "hint": "Set key 'c' to value 'i'.",
                    "solutionCode": "        lastIndex[c] = i"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through the string again, extending the partition's end based on 'lastIndex' and recording the size once the end is reached.",
                    "placeholderCode": "    res = []\n    size, end = 0, 0\n    for i, c in enumerate(s):\n        size += 1\n        end = max(end, lastIndex[c])\n        if i == end:\n            res.append(size)\n            size = 0",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*size,\\s*end\\s*=\\s*0,\\s*0\\s*for\\s+i,\\s*c\\s+in\\s+enumerate\\(s\\):\\s*size\\s*\\+=\\s*1\\s*end\\s*=\\s*max\\(end,\\s*lastIndex\\[c\\]\\)\\s*if\\s+i\\s*==\\s*end:\\s*res\\.append\\(size\\)\\s*size\\s*=\\s*0$",
                    "hint": "Maintain the current window end.",
                    "solutionCode": "    res = []\n    size, end = 0, 0\n    for i, c in enumerate(s):\n        size += 1\n        end = max(end, lastIndex[c])\n        if i == end:\n            res.append(size)\n            size = 0"
                },
                {
                    "id": 6,
                    "instruction": "Return the list of partition sizes.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}