{
    "id": "partition-labels",
    "title": "Partition Labels",
    "description": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts.",
    "examples": [
        {
            "input": "s = \"ababcbacadefegdehijhklij\"",
            "output": "[9,7,8]",
            "explanation": "The partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts."
        },
        {
            "input": "s = \"eccbbbbdec\"",
            "output": "[10]"
        }
    ],
    "constraints": [
        "1 <= s.length <= 500",
        "s consists of lowercase English letters."
    ],
    "difficulty": "Medium",
    "topic": "Greedy",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Identify the last occurrence of each character and use a greedy approach to find the smallest partitions that satisfy the condition.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function partition_labels that takes the input string s.",
                    "placeholderCode": "def partition_labels(s):",
                    "validationRegex": "^def\\s+partition_labels\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def partition_labels(s):"
                },
                {
                    "id": 2,
                    "instruction": "Create a frequency dictionary or map to store the last index where each character appears in the string.",
                    "placeholderCode": "    lastIndex = {}\n    for i, c in enumerate(s):\n        lastIndex[c] = i",
                    "validationRegex": "^\\s+lastIndex\\s*=\\s*\\{\\}\\s*for\\s+i,\\s*c\\s+in\\s+enumerate\\(s\\):\\s*lastIndex\\[c\\]\\s*=\\s*i$",
                    "hint": "Iterate through the string once to map each character to its final position.",
                    "solutionCode": "    lastIndex = {}\n    for i, c in enumerate(s):\n        lastIndex[c] = i"
                },
                {
                    "id": 3,
                    "instruction": "Use a sliding window or greedy approach to iterate through the string, maintaining the current partition's end and appending sizes to the result list.",
                    "placeholderCode": "    res = []\n    size, end = 0, 0\n    for i, c in enumerate(s):\n        size += 1\n        end = max(end, lastIndex[c])\n        if i == end:\n            res.append(size)\n            size = 0",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*size,\\s*end\\s*=\\s*0,\\s*0\\s*for\\s+i,\\s*c\\s+in\\s+enumerate\\(s\\):\\s*size\\s*\\+=\\s*1\\s*end\\s*=\\s*max\\(end,\\s*lastIndex\\[c\\]\\)\\s*if\\s+i\\s*==\\s*end:\\s*res\\.append\\(size\\)\\s*size\\s*=\\s*0$",
                    "hint": "Track the furthest 'last index' reached so far. When the current index matches this furthest point, you've found a valid partition.",
                    "solutionCode": "    res = []\n    size, end = 0, 0\n    for i, c in enumerate(s):\n        size += 1\n        end = max(end, lastIndex[c])\n        if i == end:\n            res.append(size)\n            size = 0"
                },
                {
                    "id": 4,
                    "instruction": "Return the list containing the sizes of each partition.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Solve in a single pass O(n) after pre-calculating the last indices of each character using a hash map.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function partition_labels that takes s.",
                    "placeholderCode": "def partition_labels(s):",
                    "validationRegex": "^def\\s+partition_labels\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def partition_labels(s):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize an empty dictionary 'lastIndex' to record the final appearance of each character.",
                    "placeholderCode": "    lastIndex = {}",
                    "validationRegex": "^\\s+lastIndex\\s*=\\s*\\{\\}$",
                    "hint": "This will map characters to their highest index.",
                    "solutionCode": "    lastIndex = {}"
                },
                {
                    "id": 3,
                    "instruction": "Initiate a loop to iterate through the string and capture the index of each character.",
                    "placeholderCode": "    for i, c in enumerate(s):",
                    "validationRegex": "^\\s+for\\s+i,\\s*c\\s+in\\s+enumerate\\(s\\):$",
                    "hint": "Use enumerate to get both index and character.",
                    "solutionCode": "    for i, c in enumerate(s):"
                },
                {
                    "id": 4,
                    "instruction": "Record or update the last seen index for the current character in 'lastIndex'.",
                    "placeholderCode": "        lastIndex[c] = i",
                    "validationRegex": "^\\s+lastIndex\\[c\\]\\s*=\\s*i$",
                    "hint": "Set key 'c' to value 'i'.",
                    "solutionCode": "        lastIndex[c] = i"
                },
                {
                    "id": 5,
                    "instruction": "Initialize an empty list 'res' to store the sizes of the partitions.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "This list will be our final output.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 6,
                    "instruction": "Initialize 'size' and 'end' variables to 0 to track the current partition.",
                    "placeholderCode": "    size, end = 0, 0",
                    "validationRegex": "^\\s+size,\\s*end\\s*=\\s*0,\\s*0$",
                    "hint": "'size' tracks the length of the current part, and 'end' tracks its furthest point.",
                    "solutionCode": "    size, end = 0, 0"
                },
                {
                    "id": 7,
                    "instruction": "Initiate a second loop to iterate through the string to perform the partitioning.",
                    "placeholderCode": "    for i, c in enumerate(s):",
                    "validationRegex": "^\\s+for\\s+i,\\s*c\\s+in\\s+enumerate\\(s\\):$",
                    "hint": "We'll use index and character to decide where to cut.",
                    "solutionCode": "    for i, c in enumerate(s):"
                },
                {
                    "id": 8,
                    "instruction": "Increment the current partition 'size' for the current character.",
                    "placeholderCode": "        size += 1",
                    "validationRegex": "^\\s+size\\s*\\+=\\s*1$",
                    "hint": "Each character increases the length of the potential part.",
                    "solutionCode": "        size += 1"
                },
                {
                    "id": 9,
                    "instruction": "Update the partition 'end' by choosing the maximum between the current end and the last index of the current character.",
                    "placeholderCode": "        end = max(end, lastIndex[c])",
                    "validationRegex": "^\\s+end\\s*=\\s*max\\(end,\\s*lastIndex\\[c\\]\\)$",
                    "hint": "This greedy step ensures every character within the partition appears only in this part.",
                    "solutionCode": "        end = max(end, lastIndex[c])"
                },
                {
                    "id": 10,
                    "instruction": "Check if the current index has reached the furthest point of the current partition.",
                    "placeholderCode": "        if i == end:",
                    "validationRegex": "^\\s+if\\s+i\\s*==\\s*end:$",
                    "hint": "When i == end, we've reached a point where all characters seen so far won't appear later.",
                    "solutionCode": "        if i == end:"
                },
                {
                    "id": 11,
                    "instruction": "Append the calculated 'size' of the completed partition to the 'res' list.",
                    "placeholderCode": "            res.append(size)",
                    "validationRegex": "^\\s+res\\.append\\(size\\)$",
                    "hint": "Save the partition length.",
                    "solutionCode": "            res.append(size)"
                },
                {
                    "id": 12,
                    "instruction": "Reset the 'size' to 0 to begin tracking the next partition.",
                    "placeholderCode": "            size = 0",
                    "validationRegex": "^\\s+size\\s*=\\s*0$",
                    "hint": "Start fresh for the new part.",
                    "solutionCode": "            size = 0"
                },
                {
                    "id": 13,
                    "instruction": "Return the list of partition sizes.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}