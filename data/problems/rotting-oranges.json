{
    "id": "rotting-oranges",
    "title": "Rotting Oranges",
    "description": "You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.",
    "examples": [
        {
            "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
            "output": "4"
        },
        {
            "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
            "output": "-1"
        }
    ],
    "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 10",
        "grid[i][j] is 0, 1, or 2."
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Multi-source BFS from all rotten oranges.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function oranges_rotting that takes grid.",
                    "placeholderCode": "def oranges_rotting(grid):",
                    "validationRegex": "^def\\s+oranges_rotting\\(grid\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def oranges_rotting(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize queue with rotten oranges and count fresh ones.",
                    "placeholderCode": "    q = []\n    time, fresh = 0, 0\n    rows, cols = len(grid), len(grid[0])\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1: fresh += 1\n            if grid[r][c] == 2: q.append((r, c))",
                    "validationRegex": "^\\s+q\\s*=\\s*\\[\\]\\s*time,\\s*fresh\\s*=\\s*0,\\s*0\\s*rows,\\s*cols\\s*=\\s*len\\(grid\\),\\s*len\\(grid\\[0\\]\\)\\s*for\\s+r\\s+in\\s+range\\(rows\\):\\s*for\\s+c\\s+in\\s+range\\(cols\\):\\s*if\\s+grid\\[r\\]\\[c\\]\\s*==\\s*1:\\s*fresh\\s*\\+=\\s*1\\s*if\\s+grid\\[r\\]\\[c\\]\\s*==\\s*2:\\s*q\\.append\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Scan the grid. Add all rotten oranges to the queue and count fresh oranges.",
                    "solutionCode": "    q = []\n    time, fresh = 0, 0\n    rows, cols = len(grid), len(grid[0])\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1: fresh += 1\n            if grid[r][c] == 2: q.append((r, c))"
                },
                {
                    "id": 3,
                    "instruction": "Run BFS while queue and fresh oranges exist.",
                    "placeholderCode": "    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    while q and fresh > 0:\n        for i in range(len(q)):\n            r, c = q.pop(0)\n            for dr, dc in directions:\n                row, col = r + dr, c + dc\n                if (row < 0 or row == rows or col < 0 or\n                    col == cols or grid[row][col] != 1):\n                    continue\n                grid[row][col] = 2\n                q.append((row, col))\n                fresh -= 1\n        time += 1",
                    "validationRegex": "^\\s+directions\\s*=\\s*\\[\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\],\\s*\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\]\\]\\s*while\\s+q\\s+and\\s+fresh\\s*>\\s*0:\\s*for\\s+i\\s+in\\s+range\\(len\\(q\\)\\):\\s*r,\\s*c\\s*=\\s*q\\.pop\\(0\\)\\s*for\\s+dr,\\s*dc\\s+in\\s+directions:\\s*row,\\s*col\\s*=\\s*r\\s*\\+\\s*dr,\\s*c\\s*\\+\\s*dc\\s*if\\s*\\(row\\s*<\\s*0\\s+or\\s+row\\s*==\\s*rows\\s+or\\s+col\\s*<\\s*0\\s+or\\s+col\\s*==\\s*cols\\s+or\\s+grid\\[row\\]\\[col\\]\\s*!=\\s*1\\):\\s*continue\\s*grid\\[row\\]\\[col\\]\\s*=\\s*2\\s*q\\.append\\(\\(row,\\s*col\\)\\)\\s*fresh\\s*-=\\s*1\\s*time\\s*\\+=\\s*1$",
                    "hint": "BFS level by level. For each rotten orange, infect adjacent fresh oranges, add them to queue, and decrement fresh count. Increment time after each level.",
                    "solutionCode": "    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    while q and fresh > 0:\n        for i in range(len(q)):\n            r, c = q.pop(0)\n            for dr, dc in directions:\n                row, col = r + dr, c + dc\n                if (row < 0 or row == rows or col < 0 or\n                    col == cols or grid[row][col] != 1):\n                    continue\n                grid[row][col] = 2\n                q.append((row, col))\n                fresh -= 1\n        time += 1"
                },
                {
                    "id": 4,
                    "instruction": "Return time if no fresh oranges left, else -1.",
                    "placeholderCode": "    return time if fresh == 0 else -1",
                    "validationRegex": "^\\s+return\\s+time\\s+if\\s+fresh\\s*==\\s*0\\s+else\\s+-1$",
                    "hint": "If fresh oranges remain, return -1. Otherwise return the time elapsed.",
                    "solutionCode": "    return time if fresh == 0 else -1"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force, O(m*n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function oranges_rotting that takes grid.",
                    "placeholderCode": "def oranges_rotting(grid):",
                    "validationRegex": "^def\\s+oranges_rotting\\(grid\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def oranges_rotting(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the queue to store rotten oranges.",
                    "placeholderCode": "    q = []",
                    "validationRegex": "^\\s+q\\s*=\\s*\\[\\]$",
                    "hint": "Create an empty list (or deque) for BFS.",
                    "solutionCode": "    q = []"
                },
                {
                    "id": 3,
                    "instruction": "Initialize variables for time and fresh orange count.",
                    "placeholderCode": "    time, fresh = 0, 0",
                    "validationRegex": "^\\s+time,\\s*fresh\\s*=\\s*0,\\s*0$",
                    "hint": "Both should start at zero.",
                    "solutionCode": "    time, fresh = 0, 0"
                },
                {
                    "id": 4,
                    "instruction": "Get the dimensions of the grid.",
                    "placeholderCode": "    rows, cols = len(grid), len(grid[0])",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(grid\\),\\s*len\\(grid\\[0\\]\\)$",
                    "hint": "Store the number of rows and columns.",
                    "solutionCode": "    rows, cols = len(grid), len(grid[0])"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through each row of the grid.",
                    "placeholderCode": "    for r in range(rows):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):$",
                    "hint": "Use a standard for loop for rows.",
                    "solutionCode": "    for r in range(rows):"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through each column of the grid.",
                    "placeholderCode": "        for c in range(cols):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):$",
                    "hint": "Nested loop for columns.",
                    "solutionCode": "        for c in range(cols):"
                },
                {
                    "id": 7,
                    "instruction": "If the orange is fresh, increment the fresh count.",
                    "placeholderCode": "            if grid[r][c] == 1: fresh += 1",
                    "validationRegex": "^\\s+if\\s+grid\\[r\\]\\[c\\]\\s*==\\s*1:\\s*fresh\\s*\\+=\\s*1$",
                    "hint": "Check if the cell value is 1.",
                    "solutionCode": "            if grid[r][c] == 1: fresh += 1"
                },
                {
                    "id": 8,
                    "instruction": "If the orange is rotten, add its coordinates to the queue.",
                    "placeholderCode": "            if grid[r][c] == 2: q.append((r, c))",
                    "validationRegex": "^\\s+if\\s+grid\\[r\\]\\[c\\]\\s*==\\s*2:\\s*q\\.append\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Check if the cell value is 2 and store it in q.",
                    "solutionCode": "            if grid[r][c] == 2: q.append((r, c))"
                },
                {
                    "id": 9,
                    "instruction": "Initialize the list of four directions for neighbors.",
                    "placeholderCode": "    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
                    "validationRegex": "^\\s+directions\\s*=\\s*\\[\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\],\\s*\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\]\\]$",
                    "hint": "Define North, South, East, and West movement offsets.",
                    "solutionCode": "    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]"
                },
                {
                    "id": 10,
                    "instruction": "Execute while the queue is not empty and fresh oranges remain.",
                    "placeholderCode": "    while q and fresh > 0:",
                    "validationRegex": "^\\s+while\\s+q\\s+and\\s+fresh\\s*>\\s*0:$",
                    "hint": "The BFS continues as long as there's something to rot and someone to infect.",
                    "solutionCode": "    while q and fresh > 0:"
                },
                {
                    "id": 11,
                    "instruction": "Iterate through the oranges currently in the queue for the current level.",
                    "placeholderCode": "        for i in range(len(q)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(q\\)\\):$",
                    "hint": "This ensures we process the BFS level by level (minute by minute).",
                    "solutionCode": "        for i in range(len(q)):"
                },
                {
                    "id": 12,
                    "instruction": "Pop the coordinates of a rotten orange from the queue.",
                    "placeholderCode": "            r, c = q.pop(0)",
                    "validationRegex": "^\\s+r,\\s*c\\s*=\\s*q\\.pop\\(0\\)$",
                    "hint": "Retrieve the row and column of the next orange to process.",
                    "solutionCode": "            r, c = q.pop(0)"
                },
                {
                    "id": 13,
                    "instruction": "Check all four neighbor directions.",
                    "placeholderCode": "            for dr, dc in directions:",
                    "validationRegex": "^\\s+for\\s+dr,\\s*dc\\s+in\\s+directions:$",
                    "hint": "Iterate through the directions list defined earlier.",
                    "solutionCode": "            for dr, dc in directions:"
                },
                {
                    "id": 14,
                    "instruction": "Calculate the coordinates of the neighbor cell.",
                    "placeholderCode": "                row, col = r + dr, c + dc",
                    "validationRegex": "^\\s+row,\\s*col\\s*=\\s*r\\s*\\+\\s*dr,\\s*c\\s*\\+\\s*dc$",
                    "hint": "Add the direction offset to the current row and column.",
                    "solutionCode": "                row, col = r + dr, c + dc"
                },
                {
                    "id": 15,
                    "instruction": "Check if the neighbor row is out of bounds.",
                    "placeholderCode": "                if row < 0 or row == rows: continue",
                    "validationRegex": "^\\s+if\\s+row\\s*<\\s*0\\s+or\\s+row\\s*==\\s*rows:\\s*continue$",
                    "hint": "Skip the neighbor if the row index is invalid.",
                    "solutionCode": "                if row < 0 or row == rows: continue"
                },
                {
                    "id": 16,
                    "instruction": "Check if the neighbor column is out of bounds.",
                    "placeholderCode": "                if col < 0 or col == cols: continue",
                    "validationRegex": "^\\s+if\\s+col\\s*<\\s*0\\s+or\\s+col\\s*==\\s*cols:\\s*continue$",
                    "hint": "Skip the neighbor if the column index is invalid.",
                    "solutionCode": "                if col < 0 or col == cols: continue"
                },
                {
                    "id": 17,
                    "instruction": "Skip the neighbor if it is not a fresh orange.",
                    "placeholderCode": "                if grid[row][col] != 1: continue",
                    "validationRegex": "^\\s+if\\s+grid\\[row\\]\\[col\\]\\s*!=\\s*1:\\s*continue$",
                    "hint": "A rotten orange only infects fresh ones (value 1).",
                    "solutionCode": "                if grid[row][col] != 1: continue"
                },
                {
                    "id": 18,
                    "instruction": "Mark the fresh orange as rotten.",
                    "placeholderCode": "                grid[row][col] = 2",
                    "validationRegex": "^\\s+grid\\[row\\]\\[col\\]\\s*=\\s*2$",
                    "hint": "Change the grid value from 1 to 2.",
                    "solutionCode": "                grid[row][col] = 2"
                },
                {
                    "id": 19,
                    "instruction": "Add the newly rotten orange to the queue.",
                    "placeholderCode": "                q.append((row, col))",
                    "validationRegex": "^\\s+q\\.append\\(\\(row,\\s*col\\)\\)$",
                    "hint": "Push the new coordinates into our BFS queue.",
                    "solutionCode": "                q.append((row, col))"
                },
                {
                    "id": 20,
                    "instruction": "Decrement the count of fresh oranges remaining.",
                    "placeholderCode": "                fresh -= 1",
                    "validationRegex": "^\\s+fresh\\s*-=\\s*1$",
                    "hint": "One fresh orange has just turned rotten.",
                    "solutionCode": "                fresh -= 1"
                },
                {
                    "id": 21,
                    "instruction": "Increment the time counter after processing one full level.",
                    "placeholderCode": "        time += 1",
                    "validationRegex": "^\\s+time\\s*\\+=\\s*1$",
                    "hint": "Each level in the BFS represents one minute of time passing.",
                    "solutionCode": "        time += 1"
                },
                {
                    "id": 22,
                    "instruction": "Return time if no fresh oranges left, else -1.",
                    "placeholderCode": "    return time if fresh == 0 else -1",
                    "validationRegex": "^\\s+return\\s+time\\s+if\\s+fresh\\s*==\\s*0\\s+else\\s+-1$",
                    "hint": "If fresh oranges remain, return -1. Otherwise return the time elapsed.",
                    "solutionCode": "    return time if fresh == 0 else -1"
                }
            ]
        }
    }
}