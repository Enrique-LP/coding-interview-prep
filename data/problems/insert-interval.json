{
    "id": "insert-interval",
    "title": "Insert Interval",
    "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion.",
    "examples": [
        {
            "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
            "output": "[[1,5],[6,9]]"
        },
        {
            "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
            "output": "[[1,2],[3,10],[12,16]]",
            "explanation": "Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]."
        }
    ],
    "constraints": [
        "0 <= intervals.length <= 10^4",
        "intervals[i].length == 2",
        "0 <= starti <= endi <= 10^5",
        "intervals is sorted by starti in ascending order.",
        "newInterval.length == 2",
        "0 <= start <= end <= 10^5"
    ],
    "difficulty": "Medium",
    "topic": "Intervals",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Linear Scan",
            "description": "Iterate and merge intervals.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function insert that takes intervals and newInterval.",
                    "placeholderCode": "def insert(intervals, newInterval):",
                    "validationRegex": "^def\\s+insert\\(intervals,\\s*newInterval\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def insert(intervals, newInterval):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result list.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "Initialize an empty list for the result.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through intervals.",
                    "placeholderCode": "    for i in range(len(intervals)):\n        if newInterval[1] < intervals[i][0]:\n            res.append(newInterval)\n            return res + intervals[i:]\n        elif newInterval[0] > intervals[i][1]:\n            res.append(intervals[i])\n        else:\n            newInterval = [min(newInterval[0], intervals[i][0]),\n                           max(newInterval[1], intervals[i][1])]",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(intervals\\)\\):\\s*if\\s+newInterval\\[1\\]\\s*<\\s+intervals\\[i\\]\\[0\\]:\\s*res\\.append\\(newInterval\\)\\s*return\\s+res\\s*\\+\\s*intervals\\[i:\\]\\s*elif\\s+newInterval\\[0\\]\\s*>\\s+intervals\\[i\\]\\[1\\]:\\s*res\\.append\\(intervals\\[i\\]\\)\\s*else:\\s*newInterval\\s*=\\s*\\[min\\(newInterval\\[0\\],\\s*intervals\\[i\\]\\[0\\]\\),\\s*max\\(newInterval\\[1\\],\\s*intervals\\[i\\]\\[1\\]\\)\\]$",
                    "hint": "Iterate. If newInterval ends before current starts, insert newInterval and return rest. If newInterval starts after current ends, add current. Else (overlap), merge current into newInterval.",
                    "solutionCode": "    for i in range(len(intervals)):\n        if newInterval[1] < intervals[i][0]:\n            res.append(newInterval)\n            return res + intervals[i:]\n        elif newInterval[0] > intervals[i][1]:\n            res.append(intervals[i])\n        else:\n            newInterval = [min(newInterval[0], intervals[i][0]),\n                           max(newInterval[1], intervals[i][1])]"
                },
                {
                    "id": 4,
                    "instruction": "Append remaining newInterval.",
                    "placeholderCode": "    res.append(newInterval)\n    return res",
                    "validationRegex": "^\\s+res\\.append\\(newInterval\\)\\s*return\\s+res$",
                    "hint": "If loop finishes, append the (possibly merged) newInterval.",
                    "solutionCode": "    res.append(newInterval)\n    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Linear Scan",
            "description": "Same as brute force, O(n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function insert that takes intervals and newInterval.",
                    "placeholderCode": "def insert(intervals, newInterval):",
                    "validationRegex": "^def\\s+insert\\(intervals,\\s*newInterval\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def insert(intervals, newInterval):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result list.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "Initialize result list.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through the intervals using their index.",
                    "placeholderCode": "    for i in range(len(intervals)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(intervals\\)\\):$",
                    "hint": "Use a for loop with a range based on the length of intervals.",
                    "solutionCode": "    for i in range(len(intervals)):"
                },
                {
                    "id": 4,
                    "instruction": "Check if the new interval ends before the current interval starts.",
                    "placeholderCode": "        if newInterval[1] < intervals[i][0]:",
                    "validationRegex": "^\\s+if\\s+newInterval\\[1\\]\\s*<\\s+intervals\\[i\\]\\[0\\]:$",
                    "hint": "If the end of newInterval is less than the start of intervals[i], there's no overlap.",
                    "solutionCode": "        if newInterval[1] < intervals[i][0]:"
                },
                {
                    "id": 5,
                    "instruction": "Append the new interval to the result list.",
                    "placeholderCode": "            res.append(newInterval)",
                    "validationRegex": "^\\s+res\\.append\\(newInterval\\)$",
                    "hint": "Add newInterval to your res list.",
                    "solutionCode": "            res.append(newInterval)"
                },
                {
                    "id": 6,
                    "instruction": "Return the current result plus the remaining intervals.",
                    "placeholderCode": "            return res + intervals[i:]",
                    "validationRegex": "^\\s+return\\s+res\\s*\\+\\s*intervals\\[i:\\]$",
                    "hint": "Since intervals are sorted, we can return the result and the rest of the list.",
                    "solutionCode": "            return res + intervals[i:]"
                },
                {
                    "id": 7,
                    "instruction": "Check if the new interval starts after the current interval ends.",
                    "placeholderCode": "        elif newInterval[0] > intervals[i][1]:",
                    "validationRegex": "^\\s+elif\\s+newInterval\\[0\\]\\s*>\\s+intervals\\[i\\]\\[1\\]:$",
                    "hint": "If the start of newInterval is greater than the end of intervals[i], they don't overlap.",
                    "solutionCode": "        elif newInterval[0] > intervals[i][1]:"
                },
                {
                    "id": 8,
                    "instruction": "Append the current interval to the result list.",
                    "placeholderCode": "            res.append(intervals[i])",
                    "validationRegex": "^\\s+res\\.append\\(intervals\\[i\\]\\)$",
                    "hint": "Add the current interval to the results list.",
                    "solutionCode": "            res.append(intervals[i])"
                },
                {
                    "id": 9,
                    "instruction": "Handle the case where the intervals overlap.",
                    "placeholderCode": "        else:",
                    "validationRegex": "^\\s+else:$",
                    "hint": "If neither previous condition is met, the intervals must overlap.",
                    "solutionCode": "        else:"
                },
                {
                    "id": 10,
                    "instruction": "Update the new interval by merging it with the current interval.",
                    "placeholderCode": "            newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]",
                    "validationRegex": "^\\s+newInterval\\s*=\\s*\\[min\\(newInterval\\[0\\],\\s*intervals\\[i\\]\\[0\\]\\),\\s*max\\(newInterval\\[1\\],\\s*intervals\\[i\\]\\[1\\]\\)\\]$",
                    "hint": "Set newInterval to [min of starts, max of ends].",
                    "solutionCode": "            newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]"
                },
                {
                    "id": 11,
                    "instruction": "Append the (possibly merged) new interval to result.",
                    "placeholderCode": "    res.append(newInterval)",
                    "validationRegex": "^\\s+res\\.append\\(newInterval\\)$",
                    "hint": "Add the final state of newInterval to the results list.",
                    "solutionCode": "    res.append(newInterval)"
                },
                {
                    "id": 12,
                    "instruction": "Return the result list.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the final list of intervals.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}