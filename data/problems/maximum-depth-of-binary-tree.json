{
    "id": "maximum-depth-of-binary-tree",
    "title": "Maximum Depth of Binary Tree",
    "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    "examples": [
        {
            "input": "root = [3,9,20,null,null,15,7]",
            "output": "3"
        },
        {
            "input": "root = [1,null,2]",
            "output": "2"
        }
    ],
    "constraints": [
        "The number of nodes in the tree is in the range [0, 10^4].",
        "-100 <= Node.val <= 100"
    ],
    "difficulty": "Easy",
    "topic": "Trees",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Compute depth of left and right subtrees recursively.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_depth that takes root.",
                    "placeholderCode": "def max_depth(root):",
                    "validationRegex": "^def\\s+max_depth\\(root\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_depth(root):"
                },
                {
                    "id": 2,
                    "instruction": "Base case: if root is None, return 0.",
                    "placeholderCode": "    if not root:\n        return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+root:\\s*return\\s+0$",
                    "hint": "Return 0 if the tree is empty.",
                    "solutionCode": "    if not root:\n        return 0"
                },
                {
                    "id": 3,
                    "instruction": "Return 1 + max of left and right depths.",
                    "placeholderCode": "    return 1 + max(max_depth(root.left), max_depth(root.right))",
                    "validationRegex": "^\\s+return\\s+1\\s*\\+\\s*max\\(max_depth\\(root\\.left\\),\\s*max_depth\\(root\\.right\\)\\)$",
                    "hint": "Add 1 to the larger depth of the two subtrees.\\n\\nExample:\\nRoot=3. Left Depth=1 (Node 9). Right Depth=2 (Nodes 20->7).\\nMax(1, 2) = 2. Total Depth = 1 + 2 = 3.",
                    "solutionCode": "    return 1 + max(max_depth(root.left), max_depth(root.right))"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Count levels using a queue.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_depth that takes root.",
                    "placeholderCode": "def max_depth(root):",
                    "validationRegex": "^def\\s+max_depth\\(root\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_depth(root):"
                },
                {
                    "id": 2,
                    "instruction": "If root is None, return 0.",
                    "placeholderCode": "    if not root:\n        return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+root:\\s*return\\s+0$",
                    "hint": "Return 0 if the tree is empty.",
                    "solutionCode": "    if not root:\n        return 0"
                },
                {
                    "id": 3,
                    "instruction": "Initialize queue with root and level count.",
                    "placeholderCode": "    queue = [root]\n    level = 0",
                    "validationRegex": "^\\s+queue\\s*=\\s*\\[root\\]\\s*level\\s*=\\s*0$",
                    "hint": "Start with the root in the queue and level 0.",
                    "solutionCode": "    queue = [root]\n    level = 0"
                },
                {
                    "id": 4,
                    "instruction": "Loop while queue is not empty.",
                    "placeholderCode": "    while queue:",
                    "validationRegex": "^\\s+while\\s+queue:$",
                    "hint": "Continue as long as there are nodes to process.",
                    "solutionCode": "    while queue:"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through each node in the current level.",
                    "placeholderCode": "        for i in range(len(queue)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(queue\\)\\):$",
                    "hint": "Take a snapshot of the queue length to process only current level nodes.",
                    "solutionCode": "        for i in range(len(queue)):"
                },
                {
                    "id": 6,
                    "instruction": "Pop the current node from the front of the queue.",
                    "placeholderCode": "            node = queue.pop(0)",
                    "validationRegex": "^\\s+node\\s*=\\s*queue\\.pop\\(0\\)$",
                    "hint": "Get the next node at this level.",
                    "solutionCode": "            node = queue.pop(0)"
                },
                {
                    "id": 7,
                    "instruction": "Add the left child to the queue if it exists.",
                    "placeholderCode": "            if node.left: queue.append(node.left)",
                    "validationRegex": "^\\s+if\\s+node\\.left:\\s*queue\\.append\\(node\\.left\\)$",
                    "hint": "Check the left child for the next level.",
                    "solutionCode": "            if node.left: queue.append(node.left)"
                },
                {
                    "id": 8,
                    "instruction": "Add the right child to the queue if it exists.",
                    "placeholderCode": "            if node.right: queue.append(node.right)",
                    "validationRegex": "^\\s+if\\s+node\\.right:\\s*queue\\.append\\(node\\.right\\)$",
                    "hint": "Check the right child for the next level.",
                    "solutionCode": "            if node.right: queue.append(node.right)"
                },
                {
                    "id": 9,
                    "instruction": "Increment the level count after processing all nodes at the current level.",
                    "placeholderCode": "        level += 1",
                    "validationRegex": "^\\s+level\\s*\\+=\\s*1$",
                    "hint": "Each BFS iteration processes one full depth level.",
                    "solutionCode": "        level += 1"
                },
                {
                    "id": 10,
                    "instruction": "Return the final level count.",
                    "placeholderCode": "    return level",
                    "validationRegex": "^\\s+return\\s+level$",
                    "hint": "This value represents the maximum depth of the tree.",
                    "solutionCode": "    return level"
                }
            ]
        }
    }
}