{
    "id": "jump-game-ii",
    "title": "Jump Game II",
    "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: 0 <= j <= nums[i] and i + j < n. Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].",
    "examples": [
        {
            "input": "nums = [2,3,1,1,4]",
            "output": "2",
            "explanation": "The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index."
        },
        {
            "input": "nums = [2,3,0,1,4]",
            "output": "2"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 10^4",
        "0 <= nums[i] <= 1000",
        "It's guaranteed that you can reach nums[n - 1]."
    ],
    "difficulty": "Medium",
    "topic": "Greedy",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively find the minimum number of jumps to reach the destination using memoization to optimize overlapping subproblems.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function jump that takes nums.",
                    "placeholderCode": "def jump(nums):",
                    "validationRegex": "^def\\s+jump\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def jump(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Define a recursive helper function with memoization to store the minimum jumps needed from each index.",
                    "placeholderCode": "    memo = {}\n    def dfs(i):\n        if i >= len(nums) - 1: return 0\n        if i in memo: return memo[i]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i\\):\\s*if\\s+i\\s*>=\\s+len\\(nums\\)\\s*-\\s*1:\\s*return\\s+0\\s*if\\s+i\\s+in\\s+memo:\\s*return\\s+memo\\[i\\]$",
                    "hint": "Recursive function `dfs(i)` returns min jumps from `i` to end. Base case: i >= last index -> 0 jumps.",
                    "solutionCode": "    memo = {}\n    def dfs(i):\n        if i >= len(nums) - 1: return 0\n        if i in memo: return memo[i]"
                },
                {
                    "id": 3,
                    "instruction": "Try all possible jump lengths from the current index, recursively calculate the total jumps, and find the minimum.",
                    "placeholderCode": "        res = float('inf')\n        for j in range(1, nums[i] + 1):\n            res = min(res, 1 + dfs(i + j))",
                    "validationRegex": "^\\s+res\\s*=\\s*float\\('inf'\\)\\s*for\\s+j\\s+in\\s+range\\(1,\\s*nums\\[i\\]\\s*\\+\\s*1\\):\\s*res\\s*=\\s*min\\(res,\\s*1\\s*\\+\\s*dfs\\(i\\s*\\+\\s*j\\)\\)$",
                    "hint": "Iterate through all reachable indices from `i`. Take minimum of (1 + recursive call).",
                    "solutionCode": "        res = float('inf')\n        for j in range(1, nums[i] + 1):\n            res = min(res, 1 + dfs(i + j))"
                },
                {
                    "id": 4,
                    "instruction": "Store the result in the memoization dictionary and return it.",
                    "placeholderCode": "        memo[i] = res\n        return res",
                    "validationRegex": "^\\s+memo\\[i\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Memoize for efficiency.",
                    "solutionCode": "        memo[i] = res\n        return res"
                },
                {
                    "id": 5,
                    "instruction": "Initiate the recursive process from the starting index 0.",
                    "placeholderCode": "    return dfs(0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0\\)$",
                    "hint": "Start recursion from index 0.",
                    "solutionCode": "    return dfs(0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Use a greedy BFS-like approach to find the minimum jumps by expanding the reachable window at each step.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function jump that takes nums.",
                    "placeholderCode": "def jump(nums):",
                    "validationRegex": "^def\\s+jump\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def jump(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize 'res' to 0 to keep track of the total number of jumps.",
                    "placeholderCode": "    res = 0",
                    "validationRegex": "^\\s+res\\s*=\\s*0$",
                    "hint": "This variable will store our answer.",
                    "solutionCode": "    res = 0"
                },
                {
                    "id": 3,
                    "instruction": "Initialize 'l' and 'r' to 0 to define the current range of reachable indices.",
                    "placeholderCode": "    l, r = 0, 0",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*0$",
                    "hint": "Sliding window [l, r] represents indices reachable with 'res' jumps.",
                    "solutionCode": "    l, r = 0, 0"
                },
                {
                    "id": 4,
                    "instruction": "Initiate a loop that continues until the right boundary 'r' reaches or passes the last index.",
                    "placeholderCode": "    while r < len(nums) - 1:",
                    "validationRegex": "^\\s+while\\s+r\\s*<\\s+len\\(nums\\)\\s*-\\s*1:$",
                    "hint": "We keep jumping as long as we haven't reached the end.",
                    "solutionCode": "    while r < len(nums) - 1:"
                },
                {
                    "id": 5,
                    "instruction": "Initialize 'farthest' to 0 to keep track of the maximum reach from the current jump level.",
                    "placeholderCode": "        farthest = 0",
                    "validationRegex": "^\\s+farthest\\s*=\\s*0$",
                    "hint": "This will tell us how far we can go in the next jump.",
                    "solutionCode": "        farthest = 0"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through all indices in the current reachable range [l, r].",
                    "placeholderCode": "        for i in range(l, r + 1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(l,\\s*r\\s*\\+\\s*1\\):$",
                    "hint": "We check every position in our current 'level' to find the best next jump.",
                    "solutionCode": "        for i in range(l, r + 1):"
                },
                {
                    "id": 7,
                    "instruction": "Update 'farthest' with the maximum distance reachable from index 'i'.",
                    "placeholderCode": "            farthest = max(farthest, i + nums[i])",
                    "validationRegex": "^\\s+farthest\\s*=\\s*max\\(farthest,\\s*i\\s*\\+\\s*nums\\[i\\]\\)$",
                    "hint": "Try jumping from the current index 'i' and see if it goes further.",
                    "solutionCode": "            farthest = max(farthest, i + nums[i])"
                },
                {
                    "id": 8,
                    "instruction": "Update the left boundary 'l' to the index immediately following the current right boundary.",
                    "placeholderCode": "        l = r + 1",
                    "validationRegex": "^\\s+l\\s*=\\s*r\\s*\\+\\s*1$",
                    "hint": "The next level starts just after the current one.",
                    "solutionCode": "        l = r + 1"
                },
                {
                    "id": 9,
                    "instruction": "Update the right boundary 'r' to the overall farthest index reachable from the current level.",
                    "placeholderCode": "        r = farthest",
                    "validationRegex": "^\\s+r\\s*=\\s*farthest$",
                    "hint": "This marks the end of our new reachable range.",
                    "solutionCode": "        r = farthest"
                },
                {
                    "id": 10,
                    "instruction": "Increment the jump counter 'res' to record that another jump level has been completed.",
                    "placeholderCode": "        res += 1",
                    "validationRegex": "^\\s+res\\s*\\+=\\s*1$",
                    "hint": "Each expansion of our window counts as one jump.",
                    "solutionCode": "        res += 1"
                },
                {
                    "id": 11,
                    "instruction": "Return the total number of jumps stored in 'res'.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}