{
    "id": "jump-game-ii",
    "title": "Jump Game II",
    "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: 0 <= j <= nums[i] and i + j < n. Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].",
    "examples": [
        {
            "input": "nums = [2,3,1,1,4]",
            "output": "2",
            "explanation": "The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index."
        },
        {
            "input": "nums = [2,3,0,1,4]",
            "output": "2"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 10^4",
        "0 <= nums[i] <= 1000",
        "It's guaranteed that you can reach nums[n - 1]."
    ],
    "difficulty": "Medium",
    "topic": "Greedy",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Recursive",
            "description": "Recursively find min jumps.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function jump that takes nums.",
                    "placeholderCode": "def jump(nums):",
                    "validationRegex": "^def\\s+jump\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def jump(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(i):\n        if i >= len(nums) - 1: return 0\n        if i in memo: return memo[i]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i\\):\\s*if\\s+i\\s*>=\\s+len\\(nums\\)\\s*-\\s*1:\\s*return\\s+0\\s*if\\s+i\\s+in\\s+memo:\\s*return\\s+memo\\[i\\]$",
                    "hint": "Recursive function `dfs(i)` returns min jumps from `i` to end. Base case: i >= last index -> 0 jumps. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(i):\n        if i >= len(nums) - 1: return 0\n        if i in memo: return memo[i]"
                },
                {
                    "id": 3,
                    "instruction": "Try all jumps and find min.",
                    "placeholderCode": "        res = float('inf')\n        for j in range(1, nums[i] + 1):\n            res = min(res, 1 + dfs(i + j))",
                    "validationRegex": "^\\s+res\\s*=\\s*float\\('inf'\\)\\s*for\\s+j\\s+in\\s+range\\(1,\\s*nums\\[i\\]\\s*\\+\\s*1\\):\\s*res\\s*=\\s*min\\(res,\\s*1\\s*\\+\\s*dfs\\(i\\s*\\+\\s*j\\)\\)$",
                    "hint": "Iterate through all reachable indices from `i`. Take minimum of (1 + recursive call).\\n\\nExample:\\nNums=[2, 3, 1...]. i=0. Jumps: 1, 2.\nRes = Min(\\n  1 + DFS(1),\\n  1 + DFS(2)\\n).",
                    "solutionCode": "        res = float('inf')\n        for j in range(1, nums[i] + 1):\n            res = min(res, 1 + dfs(i + j))"
                },
                {
                    "id": 4,
                    "instruction": "Memoize and return.",
                    "placeholderCode": "        memo[i] = res\n        return res",
                    "validationRegex": "^\\s+memo\\[i\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in memo and return.",
                    "solutionCode": "        memo[i] = res\n        return res"
                },
                {
                    "id": 5,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0\\)$",
                    "hint": "Start recursion from index 0.",
                    "solutionCode": "    return dfs(0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Greedy (BFS)",
            "description": "Level-order traversal of reachable indices.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function jump that takes nums.",
                    "placeholderCode": "def jump(nums):",
                    "validationRegex": "^def\\s+jump\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def jump(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize jumps, current window ends.",
                    "placeholderCode": "    res = 0\n    l, r = 0, 0",
                    "validationRegex": "^\\s+res\\s*=\\s*0\\s*l,\\s*r\\s*=\\s*0,\\s*0$",
                    "hint": "Use a sliding window `[l, r]` to represent the range of indices reachable with `res` jumps. Initially `[0, 0]` with 0 jumps.",
                    "solutionCode": "    res = 0\n    l, r = 0, 0"
                },
                {
                    "id": 3,
                    "instruction": "Iterate while r < last index.",
                    "placeholderCode": "    while r < len(nums) - 1:\n        farthest = 0\n        for i in range(l, r + 1):\n            farthest = max(farthest, i + nums[i])\n        l = r + 1\n        r = farthest\n        res += 1",
                    "validationRegex": "^\\s+while\\s+r\\s*<\\s+len\\(nums\\)\\s*-\\s*1:\\s*farthest\\s*=\\s*0\\s*for\\s+i\\s+in\\s+range\\(l,\\s*r\\s*\\+\\s*1\\):\\s*farthest\\s*=\\s*max\\(farthest,\\s*i\\s*\\+\\s*nums\\[i\\]\\)\\s*l\\s*=\\s*r\\s*\\+\\s*1\\s*r\\s*=\\s*farthest\\s*res\\s*\\+=\\s*1$",
                    "hint": "Find the farthest index reachable from the current window. Update the window to `[r + 1, farthest]` and increment jumps.\\n\\nExample:\\nNums=[2, 3, 1, 1, 4].\\nInit: Res=0, L=0, R=0.\\nIter 1: Window [0, 0]. Farthest = 0+2 = 2. New Window [1, 2]. Res=1.\\nIter 2: Window [1, 2].\\n  i=1 (Val 3): Max(2, 1+3) = 4.\\n  i=2 (Val 1): Max(4, 2+1) = 4.\\n  Farthest=4. New Window [3, 4]. Res=2.\\nR=4 >= Last Idx. Stop.",
                    "solutionCode": "    while r < len(nums) - 1:\n        farthest = 0\n        for i in range(l, r + 1):\n            farthest = max(farthest, i + nums[i])\n        l = r + 1\n        r = farthest\n        res += 1"
                },
                {
                    "id": 4,
                    "instruction": "Return jumps.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the total number of jumps.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}