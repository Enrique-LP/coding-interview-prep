{
    "id": "jump-game",
    "title": "Jump Game",
    "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise.",
    "examples": [
        {
            "input": "nums = [2,3,1,1,4]",
            "output": "true",
            "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
        },
        {
            "input": "nums = [3,2,1,0,4]",
            "output": "false",
            "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
        }
    ],
    "constraints": [
        "1 <= nums.length <= 10^4",
        "0 <= nums[i] <= 10^5"
    ],
    "difficulty": "Medium",
    "topic": "Greedy",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively try all possible jump lengths from the current position using memoization to handle overlapping subproblems.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function can_jump that takes nums.",
                    "placeholderCode": "def can_jump(nums):",
                    "validationRegex": "^def\\s+can_jump\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def can_jump(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Define a recursive helper function with memoization to store whether each index can reach the end.",
                    "placeholderCode": "    memo = {}\n    def dfs(i):\n        if i >= len(nums) - 1: return True\n        if i in memo: return memo[i]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i\\):\\s*if\\s+i\\s*>=\\s+len\\(nums\\)\\s*-\\s*1:\\s*return\\s+True\\s*if\\s+i\\s+in\\s+memo:\\s*return\\s+memo\\[i\\]$",
                    "hint": "Base case: if we reach or exceed the last index, return True.",
                    "solutionCode": "    memo = {}\n    def dfs(i):\n        if i >= len(nums) - 1: return True\n        if i in memo: return memo[i]"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through all possible jump lengths from the current index `i` up to `nums[i]`, and return True if any jump leads to the destination.",
                    "placeholderCode": "        for j in range(1, nums[i] + 1):\n            if dfs(i + j):\n                memo[i] = True\n                return True",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(1,\\s*nums\\[i\\]\\s*\\+\\s*1\\):\\s*if\\s+dfs\\(i\\s*\\+\\s*j\\):\\s*memo\\[i\\]\\s*=\\s*True\\s*return\\s+True$",
                    "hint": "Try jumping from 1 to nums[i] steps.",
                    "solutionCode": "        for j in range(1, nums[i] + 1):\n            if dfs(i + j):\n                memo[i] = True\n                return True"
                },
                {
                    "id": 4,
                    "instruction": "If no jump from the current index leads to the destination, memoize the failure and return False.",
                    "placeholderCode": "        memo[i] = False\n        return False",
                    "validationRegex": "^\\s+memo\\[i\\]\\s*=\\s*False\\s*return\\s+False$",
                    "hint": "If no jumps work, store False in memo and return.",
                    "solutionCode": "        memo[i] = False\n        return False"
                },
                {
                    "id": 5,
                    "instruction": "Initiate the recursive process by calling the helper function for the starting index 0.",
                    "placeholderCode": "    return dfs(0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0\\)$",
                    "hint": "Start recursion from index 0.",
                    "solutionCode": "    return dfs(0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Use a greedy approach by tracking the leftmost index that can reach the end, moving the goal backwards from the end to the start.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function can_jump that takes nums.",
                    "placeholderCode": "def can_jump(nums):",
                    "validationRegex": "^def\\s+can_jump\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def can_jump(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the variable 'goal' to the last index of the array.",
                    "placeholderCode": "    goal = len(nums) - 1",
                    "validationRegex": "^\\s+goal\\s*=\\s*len\\(nums\\)\\s*-\\s*1$",
                    "hint": "The initial target is the very last element.",
                    "solutionCode": "    goal = len(nums) - 1"
                },
                {
                    "id": 3,
                    "instruction": "Initiate a loop to iterate through the array indices in reverse order.",
                    "placeholderCode": "    for i in range(len(nums) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "We check each index backwards to see if it can reach the current goal.",
                    "solutionCode": "    for i in range(len(nums) - 1, -1, -1):"
                },
                {
                    "id": 4,
                    "instruction": "Check if the current index plus its maximum jump length is enough to reach the current goal.",
                    "placeholderCode": "        if i + nums[i] >= goal:",
                    "validationRegex": "^\\s+if\\s+i\\s*\\+\\s*nums\\[i\\]\\s*>=\\s+goal:$",
                    "hint": "If we can reach the current goal from index i, then reaching i becomes the new objective.",
                    "solutionCode": "        if i + nums[i] >= goal:"
                },
                {
                    "id": 5,
                    "instruction": "If the goal is reachable from the current index, update 'goal' to the current index 'i'.",
                    "placeholderCode": "            goal = i",
                    "validationRegex": "^\\s+goal\\s*=\\s*i$",
                    "hint": "Since i can reach the goal, we now only need to find if we can reach i.",
                    "solutionCode": "            goal = i"
                },
                {
                    "id": 6,
                    "instruction": "Return True if the goal has been successfully moved back to the starting index 0.",
                    "placeholderCode": "    return goal == 0",
                    "validationRegex": "^\\s+return\\s+goal\\s*==\\s*0$",
                    "hint": "If the goal reaches index 0, the entire path is possible.",
                    "solutionCode": "    return goal == 0"
                }
            ]
        }
    }
}