{
    "id": "sliding-window-maximum",
    "title": "Sliding Window Maximum",
    "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
    "examples": [
        {
            "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
            "output": "[3,3,5,5,6,7]",
            "explanation": "Window position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7"
        },
        {
            "input": "nums = [1], k = 1",
            "output": "[1]"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 10^5",
        "-10^4 <= nums[i] <= 10^4",
        "1 <= k <= nums.length"
    ],
    "difficulty": "Hard",
    "topic": "Sliding Window",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Loop",
            "description": "Find max in each window.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_sliding_window that takes nums and k.",
                    "placeholderCode": "def max_sliding_window(nums, k):",
                    "validationRegex": "^def\\s+max_sliding_window\\(nums,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_sliding_window(nums, k):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate and find max.",
                    "placeholderCode": "    res = []\n    for i in range(len(nums) - k + 1):\n        res.append(max(nums[i : i + k]))",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\s*-\\s*k\\s*\\+\\s*1\\):\\s*res\\.append\\(max\\(nums\\[i\\s*:\\s*i\\s*\\+\\s*k\\]\\)\\)$",
                    "hint": "Iterate through valid start indices. Use `max()` on slice.",
                    "solutionCode": "    res = []\n    for i in range(len(nums) - k + 1):\n        res.append(max(nums[i : i + k]))"
                },
                {
                    "id": 3,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Monotonic Deque",
            "description": "Maintain decreasing order of elements in deque.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_sliding_window that takes nums and k.",
                    "placeholderCode": "def max_sliding_window(nums, k):",
                    "validationRegex": "^def\\s+max_sliding_window\\(nums,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_sliding_window(nums, k):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize deque and result.",
                    "placeholderCode": "    output = []\n    q = collections.deque()\n    l = r = 0",
                    "validationRegex": "^\\s+output\\s*=\\s*\\[\\]\\s*q\\s*=\\s*collections\\.deque\\(\\)\\s*l\\s*=\\s*r\\s*=\\s*0$",
                    "hint": "Initialize `output`, `q` (deque), `l`, `r`.",
                    "solutionCode": "    output = []\n    q = collections.deque()\n    l = r = 0"
                },
                {
                    "id": 3,
                    "instruction": "Process elements.",
                    "placeholderCode": "    while r < len(nums):\n        while q and nums[q[-1]] < nums[r]:\n            q.pop()\n        q.append(r)\n        if l > q[0]:\n            q.popleft()\n        if (r + 1) >= k:\n            output.append(nums[q[0]])\n            l += 1\n        r += 1",
                    "validationRegex": "^\\s+while\\s+r\\s*<\\s+len\\(nums\\):\\s*while\\s+q\\s+and\\s+nums\\[q\\[-1\\]\\]\\s*<\\s+nums\\[r\\]:\\s*q\\.pop\\(\\)\\s*q\\.append\\(r\\)\\s*if\\s+l\\s*>\\s+q\\[0\\]:\\s*q\\.popleft\\(\\)\\s*if\\s*\\(r\\s*\\+\\s*1\\)\\s*>=\\s*k:\\s*output\\.append\\(nums\\[q\\[0\\]\\]\\)\\s*l\\s*\\+=\\s*1\\s*r\\s*\\+=\\s*1$",
                    "hint": "Maintain monotonic decreasing deque. Remove indices out of window. Add max to output.",
                    "solutionCode": "    while r < len(nums):\n        while q and nums[q[-1]] < nums[r]:\n            q.pop()\n        q.append(r)\n        if l > q[0]:\n            q.popleft()\n        if (r + 1) >= k:\n            output.append(nums[q[0]])\n            l += 1\n        r += 1"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return output",
                    "validationRegex": "^\\s+return\\s+output$",
                    "hint": "Return the result.",
                    "solutionCode": "    return output"
                }
            ]
        }
    }
}