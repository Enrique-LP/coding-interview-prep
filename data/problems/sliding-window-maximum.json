{
    "id": "sliding-window-maximum",
    "title": "Sliding Window Maximum",
    "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.",
    "examples": [
        {
            "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
            "output": "[3,3,5,5,6,7]",
            "explanation": "Window position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7"
        },
        {
            "input": "nums = [1], k = 1",
            "output": "[1]"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 10^5",
        "-10^4 <= nums[i] <= 10^4",
        "1 <= k <= nums.length"
    ],
    "difficulty": "Hard",
    "topic": "Sliding Window",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Loop",
            "description": "Find max in each window.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_sliding_window that takes nums and k.",
                    "placeholderCode": "def max_sliding_window(nums, k):",
                    "validationRegex": "^def\\s+max_sliding_window\\(nums,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_sliding_window(nums, k):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate and find max.",
                    "placeholderCode": "    res = []\n    for i in range(len(nums) - k + 1):\n        res.append(max(nums[i : i + k]))",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\s*-\\s*k\\s*\\+\\s*1\\):\\s*res\\.append\\(max\\(nums\\[i\\s*:\\s*i\\s*\\+\\s*k\\]\\)\\)$",
                    "hint": "Iterate through valid start indices. Use `max()` on slice.",
                    "solutionCode": "    res = []\n    for i in range(len(nums) - k + 1):\n        res.append(max(nums[i : i + k]))"
                },
                {
                    "id": 3,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Monotonic Deque",
            "description": "Maintain decreasing order of elements in deque.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function max_sliding_window that takes nums and k.",
                    "placeholderCode": "def max_sliding_window(nums, k):",
                    "validationRegex": "^def\\s+max_sliding_window\\(nums,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def max_sliding_window(nums, k):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize deque and result.",
                    "placeholderCode": "    output = []\n    q = collections.deque()\n    l = r = 0",
                    "validationRegex": "^\\s+output\\s*=\\s*\\[\\]\\s*q\\s*=\\s*collections\\.deque\\(\\)\\s*l\\s*=\\s*r\\s*=\\s*0$",
                    "hint": "Initialize `output`, `q` (deque), `l`, `r`.",
                    "solutionCode": "    output = []\n    q = collections.deque()\n    l = r = 0"
                },
                {
                    "id": 3,
                    "instruction": "Start a while loop to iterate through the array until the right pointer r reaches the end.",
                    "placeholderCode": "    while r < len(nums):",
                    "validationRegex": "^\\s+while\\s+r\\s*<\\s+len\\(nums\\):$",
                    "hint": "The loop continues as long as `r` is within the bounds of `nums`.",
                    "solutionCode": "    while r < len(nums):"
                },
                {
                    "id": 4,
                    "instruction": "Inside the loop, check if the current value is larger than elements at the end of the deque.",
                    "placeholderCode": "        while q and nums[q[-1]] < nums[r]:",
                    "validationRegex": "^\\s+while\\s+q\\s+and\\s+nums\\[q\\[-1\\]\\]\\s*<\\s*nums\\[r\\]:$",
                    "hint": "To maintain a monotonic decreasing deque, we must remove all indices of elements smaller than the current `nums[r]`.",
                    "solutionCode": "        while q and nums[q[-1]] < nums[r]:"
                },
                {
                    "id": 5,
                    "instruction": "Pop the last element from the deque while it's smaller than the current element.",
                    "placeholderCode": "            q.pop()",
                    "validationRegex": "^\\s+q\\.pop\\(\\)$",
                    "hint": "Remove the index from the end of the deque since it can no longer be the maximum for any window containing `nums[r]`.",
                    "solutionCode": "            q.pop()"
                },
                {
                    "id": 6,
                    "instruction": "Append the current right pointer index r to the deque.",
                    "placeholderCode": "        q.append(r)",
                    "validationRegex": "^\\s+q\\.append\\(r\\)$",
                    "hint": "Now that smaller elements are gone, `r` is potentially the maximum for future windows.",
                    "solutionCode": "        q.append(r)"
                },
                {
                    "id": 7,
                    "instruction": "Check if the maximum element's index (at q[0]) is now out of the current window.",
                    "placeholderCode": "        if l > q[0]:",
                    "validationRegex": "^\\s+if\\s+l\\s*>\\s+q\\[0\\]:$",
                    "hint": "The left boundary `l` has moved, so we check if the largest element still belongs in the window.",
                    "solutionCode": "        if l > q[0]:"
                },
                {
                    "id": 8,
                    "instruction": "Remove the leftmost index from the deque if it's out of range.",
                    "placeholderCode": "            q.popleft()",
                    "validationRegex": "^\\s+q\\.popleft\\(\\)$",
                    "hint": "The index `q[0]` is no longer within `[l, r]`, so it can't be the maximum anymore.",
                    "solutionCode": "            q.popleft()"
                },
                {
                    "id": 9,
                    "instruction": "Check if the sliding window has reached the target size k.",
                    "placeholderCode": "        if (r + 1) >= k:",
                    "validationRegex": "^\\s+if\\s*\\(r\\s*\\+\\s*1\\)\\s*>=\\s*k:$",
                    "hint": "We only start recording maximums once the window has at least `k` elements.",
                    "solutionCode": "        if (r + 1) >= k:"
                },
                {
                    "id": 10,
                    "instruction": "Append the maximum value (at nums[q[0]]) to the output list.",
                    "placeholderCode": "            output.append(nums[q[0]])",
                    "validationRegex": "^\\s+output\\.append\\(nums\\[q\\[0\\]\\]\\)$",
                    "hint": "Because the deque is monotonic decreasing, `q[0]` always points to the maximum element index.",
                    "solutionCode": "            output.append(nums[q[0]])"
                },
                {
                    "id": 11,
                    "instruction": "Increment the left pointer l to shift the window.",
                    "placeholderCode": "            l += 1",
                    "validationRegex": "^\\s+l\\s*\\+=\\s*1$",
                    "hint": "Move the left boundary forward once the window is full.",
                    "solutionCode": "            l += 1"
                },
                {
                    "id": 12,
                    "instruction": "Increment the right pointer r to move to the next element.",
                    "placeholderCode": "        r += 1",
                    "validationRegex": "^\\s+r\\s*\\+=\\s*1$",
                    "hint": "Always expand the right boundary in each iteration.",
                    "solutionCode": "        r += 1"
                },
                {
                    "id": 13,
                    "instruction": "Return the final output list containing maximums for each window.",
                    "placeholderCode": "    return output",
                    "validationRegex": "^\\s+return\\s+output$",
                    "hint": "The loop is finished, return the result.",
                    "solutionCode": "    return output"
                }
            ]
        }
    }
}