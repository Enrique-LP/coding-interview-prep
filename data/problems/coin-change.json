{
    "id": "coin-change",
    "title": "Coin Change",
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.",
    "examples": [
        {
            "input": "coins = [1,2,5], amount = 11",
            "output": "3",
            "explanation": "11 = 5 + 5 + 1"
        },
        {
            "input": "coins = [2], amount = 3",
            "output": "-1"
        }
    ],
    "constraints": [
        "1 <= coins.length <= 12",
        "1 <= coins[i] <= 2^31 - 1",
        "0 <= amount <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively try all coins.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function coin_change that takes coins and amount.",
                    "placeholderCode": "def coin_change(coins, amount):",
                    "validationRegex": "^def\\s+coin_change\\(coins,\\s*amount\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def coin_change(coins, amount):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(rem):\n        if rem < 0: return -1\n        if rem == 0: return 0\n        if rem in memo: return memo[rem]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(rem\\):\\s*if\\s+rem\\s*<\\s*0:\\s*return\\s+-1\\s*if\\s+rem\\s*==\\s*0:\\s*return\\s+0\\s*if\\s+rem\\s+in\\s+memo:\\s*return\\s+memo\\[rem\\]$",
                    "hint": "Recursive function `dfs(rem)` returns min coins for remaining amount `rem`. Base cases: rem < 0 -> -1, rem == 0 -> 0. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(rem):\n        if rem < 0: return -1\n        if rem == 0: return 0\n        if rem in memo: return memo[rem]"
                },
                {
                    "id": 3,
                    "instruction": "Try all coins and find min.",
                    "placeholderCode": "        min_cost = float('inf')\n        for coin in coins:\n            res = dfs(rem - coin)\n            if res != -1:\n                min_cost = min(min_cost, res + 1)",
                    "validationRegex": "^\\s+min_cost\\s*=\\s*float\\('inf'\\)\\s*for\\s+coin\\s+in\\s+coins:\\s*res\\s*=\\s*dfs\\(rem\\s*-\\s*coin\\)\\s*if\\s+res\\s*!=\\s*-1:\\s*min_cost\\s*=\\s*min\\(min_cost,\\s*res\\s*\\+\\s*1\\)$",
                    "hint": "Iterate through coins. Recurse with `rem - coin`. If valid result, update `min_cost`.",
                    "solutionCode": "        min_cost = float('inf')\n        for coin in coins:\n            res = dfs(rem - coin)\n            if res != -1:\n                min_cost = min(min_cost, res + 1)"
                },
                {
                    "id": 4,
                    "instruction": "Memoize and return.",
                    "placeholderCode": "        memo[rem] = min_cost if min_cost != float('inf') else -1\n        return memo[rem]",
                    "validationRegex": "^\\s+memo\\[rem\\]\\s*=\\s*min_cost\\s+if\\s+min_cost\\s*!=\\s*float\\('inf'\\)\\s+else\\s+-1\\s*return\\s+memo\\[rem\\]$",
                    "hint": "Store result in memo. If min_cost is still infinity, store -1.",
                    "solutionCode": "        memo[rem] = min_cost if min_cost != float('inf') else -1\n        return memo[rem]"
                },
                {
                    "id": 5,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(amount)",
                    "validationRegex": "^\\s+return\\s+dfs\\(amount\\)$",
                    "hint": "Start recursion with full amount.",
                    "solutionCode": "    return dfs(amount)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Build up min coins for each amount from 1 to amount in O(n * amount) time.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function coin_change that takes coins and amount.",
                    "placeholderCode": "def coin_change(coins, amount):",
                    "validationRegex": "^def\\s+coin_change\\(coins,\\s*amount\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def coin_change(coins, amount):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP array with a value larger than the total amount.",
                    "placeholderCode": "    dp = [amount + 1] * (amount + 1)",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[amount\\s*\\+\\s*1\\]\\s*\\*\\s*\\(amount\\s*\\+\\s*1\\)$",
                    "hint": "Initialize DP array of size amount+1. Fill with value > amount (representing infinity).",
                    "solutionCode": "    dp = [amount + 1] * (amount + 1)"
                },
                {
                    "id": 3,
                    "instruction": "Set the base case: zero coins are required to make an amount of zero.",
                    "placeholderCode": "    dp[0] = 0",
                    "validationRegex": "^\\s+dp\\[0\\]\\s*=\\s*0$",
                    "hint": "The amount 0 is always reachable with 0 coins.",
                    "solutionCode": "    dp[0] = 0"
                },
                {
                    "id": 4,
                    "instruction": "Iterate through each amount from 1 up to the target amount.",
                    "placeholderCode": "    for a in range(1, amount + 1):",
                    "validationRegex": "^\\s+for\\s+a\\s+in\\s+range\\(1,\\s*amount\\s*\\+\\s*1\\):$",
                    "hint": "We build up the solution for every amount from 1 to the target.",
                    "solutionCode": "    for a in range(1, amount + 1):"
                },
                {
                    "id": 5,
                    "instruction": "For each amount, iterate through every available coin denomination.",
                    "placeholderCode": "        for c in coins:",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+coins:$",
                    "hint": "Try using each coin to see if it provides a smaller count of coins for the current amount.",
                    "solutionCode": "        for c in coins:"
                },
                {
                    "id": 6,
                    "instruction": "Check if the current coin denomination 'c' can be used for the current amount 'a'.",
                    "placeholderCode": "            if a - c >= 0:",
                    "validationRegex": "^\\s+if\\s+a\\s*-\\s*c\\s*>=\\s*0:$",
                    "hint": "We can only use a coin if its value is less than or equal to the amount we are trying to make.",
                    "solutionCode": "            if a - c >= 0:"
                },
                {
                    "id": 7,
                    "instruction": "Update the DP table with the minimum number of coins needed for amount 'a'.",
                    "placeholderCode": "                dp[a] = min(dp[a], 1 + dp[a - c])",
                    "validationRegex": "^\\s+dp\\[a\\]\\s*=\\s*min\\(dp\\[a\\],\\s*1\\s*\\+\\s*dp\\[a\\s*-\\s*c\\]\\)$",
                    "hint": "The number of coins for amount 'a' is either its current value or 1 (for the current coin) plus the minimum coins needed for the remaining amount (a - c).",
                    "solutionCode": "                dp[a] = min(dp[a], 1 + dp[a - c])"
                },
                {
                    "id": 8,
                    "instruction": "Return the final count if reachable, otherwise return -1.",
                    "placeholderCode": "    return dp[amount] if dp[amount] != amount + 1 else -1",
                    "validationRegex": "^\\s+return\\s+dp\\[amount\\]\\s+if\\s+dp\\[amount\\]\\s*!=\\s*amount\\s*\\+\\s*1\\s+else\\s+-1$",
                    "hint": "If dp[amount] is still the initial large value, it means the amount cannot be formed.",
                    "solutionCode": "    return dp[amount] if dp[amount] != amount + 1 else -1"
                }
            ]
        }
    }
}