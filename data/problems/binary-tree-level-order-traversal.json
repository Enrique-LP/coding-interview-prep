{
    "id": "binary-tree-level-order-traversal",
    "title": "Binary Tree Level Order Traversal",
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "examples": [
        {
            "input": "root = [3,9,20,null,null,15,7]",
            "output": "[[3],[9,20],[15,7]]"
        },
        {
            "input": "root = [1]",
            "output": "[[1]]"
        }
    ],
    "constraints": [
        "The number of nodes in the tree is in the range [0, 2000].",
        "-1000 <= Node.val <= 1000"
    ],
    "difficulty": "Medium",
    "topic": "Trees",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Use a queue to traverse level by level.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function level_order that takes root.",
                    "placeholderCode": "def level_order(root):",
                    "validationRegex": "^def\\s+level_order\\(root\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def level_order(root):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result list and queue.",
                    "placeholderCode": "    res = []\n    q = [root] if root else []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*q\\s*=\\s*\\[root\\]\\s*if\\s+root\\s+else\\s*\\[\\]$",
                    "hint": "Start with root in queue if it exists.",
                    "solutionCode": "    res = []\n    q = [root] if root else []"
                },
                {
                    "id": 3,
                    "instruction": "Loop while queue is not empty.",
                    "placeholderCode": "    while q:",
                    "validationRegex": "^\\s+while\\s+q:$",
                    "hint": "Continue while there are nodes to process.",
                    "solutionCode": "    while q:"
                },
                {
                    "id": 4,
                    "instruction": "Process current level.",
                    "placeholderCode": "        val = []\n        for i in range(len(q)):\n            node = q.pop(0)\n            val.append(node.val)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)",
                    "validationRegex": "^\\s+val\\s*=\\s*\\[\\]\\s*for\\s+i\\s+in\\s+range\\(len\\(q\\)\\):\\s*node\\s*=\\s*q\\.pop\\(0\\)\\s*val\\.append\\(node\\.val\\)\\s*if\\s+node\\.left:\\s*q\\.append\\(node\\.left\\)\\s*if\\s+node\\.right:\\s*q\\.append\\(node\\.right\\)$",
                    "hint": "Collect values of current level and add children to queue.\\n\\nExample:\\nQueue=[3]. Pop 3. Add 9, 20. Level=[3].\\nQueue=[9, 20]. Pop 9. Add children. Pop 20. Add 15, 7. Level=[9, 20].",
                    "solutionCode": "        val = []\n        for i in range(len(q)):\n            node = q.pop(0)\n            val.append(node.val)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)"
                },
                {
                    "id": 5,
                    "instruction": "Append level values to result.",
                    "placeholderCode": "        res.append(val)",
                    "validationRegex": "^\\s+res\\.append\\(val\\)$",
                    "hint": "Add the list of values for this level to the result.",
                    "solutionCode": "        res.append(val)"
                },
                {
                    "id": 6,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the list of levels.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force, O(n) is optimal.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function level_order that takes root.",
                    "placeholderCode": "def level_order(root):",
                    "validationRegex": "^def\\s+level_order\\(root\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def level_order(root):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize an empty list 'res' to store the level order traversal.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "This list will contain sub-lists for each level of the tree.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 3,
                    "instruction": "Initialize a queue 'q' with the root node if it exists.",
                    "placeholderCode": "    q = [root] if root else []",
                    "validationRegex": "^\\s+q\\s*=\\s*\\[root\\]\\s+if\\s+root\\s+else\\s*\\[\\]$",
                    "hint": "BFS uses a queue to process nodes level by level.",
                    "solutionCode": "    q = [root] if root else []"
                },
                {
                    "id": 4,
                    "instruction": "Loop while the queue is not empty.",
                    "placeholderCode": "    while q:",
                    "validationRegex": "^\\s+while\\s+q:$",
                    "hint": "Continue the process until all reachable nodes have been visited.",
                    "solutionCode": "    while q:"
                },
                {
                    "id": 5,
                    "instruction": "Initialize a list 'val' to store the values of nodes at the current level.",
                    "placeholderCode": "        val = []",
                    "validationRegex": "^\\s+val\\s*=\\s*\\[\\]$",
                    "hint": "This list will be cleared and refilled for every level of the tree.",
                    "solutionCode": "        val = []"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through each node currently in the queue.",
                    "placeholderCode": "        for i in range(len(q)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(q\\)\\):$",
                    "hint": "The length of the queue at this moment represents the number of nodes at the current level.",
                    "solutionCode": "        for i in range(len(q)):"
                },
                {
                    "id": 7,
                    "instruction": "Remove the node from the front of the queue.",
                    "placeholderCode": "            node = q.pop(0)",
                    "validationRegex": "^\\s+node\\s*=\\s*q\\.pop\\(0\\)$",
                    "hint": "Standard BFS pops from the beginning of the queue.",
                    "solutionCode": "            node = q.pop(0)"
                },
                {
                    "id": 8,
                    "instruction": "Add the value of the current node to the level list.",
                    "placeholderCode": "            val.append(node.val)",
                    "validationRegex": "^\\s+val\\.append\\(node\\.val\\)$",
                    "hint": "Accumulate values in the correct left-to-right order.",
                    "solutionCode": "            val.append(node.val)"
                },
                {
                    "id": 9,
                    "instruction": "Add the left child to the queue if it exists.",
                    "placeholderCode": "            if node.left: q.append(node.left)",
                    "validationRegex": "^\\s+if\\s+node\\.left:\\s*q\\.append\\(node\\.left\\)$",
                    "hint": "Children will be processed in the next level iteration.",
                    "solutionCode": "            if node.left: q.append(node.left)"
                },
                {
                    "id": 10,
                    "instruction": "Add the right child to the queue if it exists.",
                    "placeholderCode": "            if node.right: q.append(node.right)",
                    "validationRegex": "^\\s+if\\s+node\\.right:\\s*q\\.append\\(node\\.right\\)$",
                    "hint": "Always check for existence before adding children to the queue.",
                    "solutionCode": "            if node.right: q.append(node.right)"
                },
                {
                    "id": 11,
                    "instruction": "Append the list of current level values to the result.",
                    "placeholderCode": "        res.append(val)",
                    "validationRegex": "^\\s+res\\.append\\(val\\)$",
                    "hint": "Each entry in 'res' represents one level of the binary tree.",
                    "solutionCode": "        res.append(val)"
                },
                {
                    "id": 12,
                    "instruction": "Return the final result after traversing all levels.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "The result is a list of lists containing values level by level.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}