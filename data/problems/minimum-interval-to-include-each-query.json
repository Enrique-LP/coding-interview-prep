{
    "id": "minimum-interval-to-include-each-query",
    "title": "Minimum Interval to Include Each Query",
    "description": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\nReturn an array containing the answers to the queries.",
    "examples": [
        {
            "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
            "output": "[3,3,1,4]",
            "explanation": "The queries are processed as follows:\n- Query = 2: The interval [2,4] is the smallest interval containing 2. The size is 4 - 2 + 1 = 3.\n- Query = 3: The interval [2,4] is the smallest interval containing 3. The size is 4 - 2 + 1 = 3.\n- Query = 4: The interval [4,4] is the smallest interval containing 4. The size is 4 - 4 + 1 = 1.\n- Query = 5: The interval [3,6] is the smallest interval containing 5. The size is 6 - 3 + 1 = 4."
        },
        {
            "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
            "output": "[2,-1,4,6]",
            "explanation": "- Query = 2: The interval [2,3] is the smallest interval containing 2. The size is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval [2,5] is the smallest interval containing 5. The size is 5 - 2 + 1 = 4.\n- Query = 22: The interval [20,25] is the smallest interval containing 22. The size is 25 - 20 + 1 = 6."
        }
    ],
    "constraints": [
        "1 <= intervals.length <= 10^5",
        "1 <= queries.length <= 10^5",
        "intervals[i].length == 2",
        "1 <= lefti <= righti <= 10^7",
        "1 <= queries[j] <= 10^7"
    ],
    "difficulty": "Hard",
    "topic": "Intervals",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Linear Scan",
            "description": "Check every interval for every query.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_interval that takes intervals and queries.",
                    "placeholderCode": "def min_interval(intervals, queries):",
                    "validationRegex": "^def\\s+min_interval\\(intervals,\\s*queries\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_interval(intervals, queries):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result list.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "Initialize an empty list for results.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through queries.",
                    "placeholderCode": "    for q in queries:\n        min_size = float('inf')\n        found = False\n        for l, r in intervals:\n            if l <= q <= r:\n                min_size = min(min_size, r - l + 1)\n                found = True\n        res.append(min_size if found else -1)",
                    "validationRegex": "^\\s+for\\s+q\\s+in\\s+queries:\\s*min_size\\s*=\\s*float\\('inf'\\)\\s*found\\s*=\\s*False\\s*for\\s+l,\\s*r\\s+in\\s+intervals:\\s*if\\s+l\\s*<=\\s*q\\s*<=\\s*r:\\s*min_size\\s*=\\s*min\\(min_size,\\s*r\\s*-\\s*l\\s*\\+\\s*1\\)\\s*found\\s*=\\s*True\\s*res\\.append\\(min_size\\s+if\\s+found\\s+else\\s+-1\\)$",
                    "hint": "For each query, iterate through all intervals. If query is in interval, update min_size. Append result.",
                    "solutionCode": "    for q in queries:\n        min_size = float('inf')\n        found = False\n        for l, r in intervals:\n            if l <= q <= r:\n                min_size = min(min_size, r - l + 1)\n                found = True\n        res.append(min_size if found else -1)"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the list of results.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Min Heap + Sorting",
            "description": "Sort intervals and queries, use min heap for active intervals.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_interval that takes intervals and queries.",
                    "placeholderCode": "def min_interval(intervals, queries):",
                    "validationRegex": "^def\\s+min_interval\\(intervals,\\s*queries\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_interval(intervals, queries):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals.",
                    "placeholderCode": "    intervals.sort()",
                    "validationRegex": "^\\s+intervals\\.sort\\(\\)$",
                    "hint": "Sort the intervals in place by their start time.",
                    "solutionCode": "    intervals.sort()"
                },
                {
                    "id": 3,
                    "instruction": "Initialize minHeap.",
                    "placeholderCode": "    minHeap = []",
                    "validationRegex": "^\\s+minHeap\\s*=\\s*\\[\\]$",
                    "hint": "Create a list to be used as a min-heap.",
                    "solutionCode": "    minHeap = []"
                },
                {
                    "id": 4,
                    "instruction": "Initialize result dictionary.",
                    "placeholderCode": "    res = {}",
                    "validationRegex": "^\\s+res\\s*=\\s*\\{\\}$",
                    "hint": "Create a dictionary to store the result for each query.",
                    "solutionCode": "    res = {}"
                },
                {
                    "id": 5,
                    "instruction": "Initialize interval index.",
                    "placeholderCode": "    i = 0",
                    "validationRegex": "^\\s+i\\s*=\\s*0$",
                    "hint": "Initialize an index to iterate through the sorted intervals.",
                    "solutionCode": "    i = 0"
                },
                {
                    "id": 6,
                    "instruction": "Sort queries.",
                    "placeholderCode": "    sorted_queries = sorted(queries)",
                    "validationRegex": "^\\s+sorted_queries\\s*=\\s*sorted\\(queries\\)$",
                    "hint": "Create a new sorted list of the queries.",
                    "solutionCode": "    sorted_queries = sorted(queries)"
                },
                {
                    "id": 7,
                    "instruction": "Iterate through sorted queries.",
                    "placeholderCode": "    for q in sorted_queries:",
                    "validationRegex": "^\\s+for\\s+q\\s+in\\s+sorted_queries:$",
                    "hint": "Loop through each query in the sorted order.",
                    "solutionCode": "    for q in sorted_queries:"
                },
                {
                    "id": 8,
                    "instruction": "Check for new intervals starting before query.",
                    "placeholderCode": "        while i < len(intervals) and intervals[i][0] <= q:",
                    "validationRegex": "^\\s+while\\s+i\\s*<\\s+len\\(intervals\\)\\s+and\\s+intervals\\[i\\]\\[0\\]\\s*<=\\s*q:$",
                    "hint": "Loop while there are intervals that start before or at the current query `q`.",
                    "solutionCode": "        while i < len(intervals) and intervals[i][0] <= q:"
                },
                {
                    "id": 9,
                    "instruction": "Get interval bounds.",
                    "placeholderCode": "            l, r = intervals[i]",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*intervals\\[i\\]$",
                    "hint": "Unpack the start and end of the current interval.",
                    "solutionCode": "            l, r = intervals[i]"
                },
                {
                    "id": 10,
                    "instruction": "Add interval to minHeap.",
                    "placeholderCode": "            heapq.heappush(minHeap, (r - l + 1, r))",
                    "validationRegex": "^\\s+heapq\\.heappush\\(minHeap,\\s*\\(r\\s*-\\s*l\\s*\\+\\s*1,\\s*r\\)\\)$",
                    "hint": "Push a tuple containing the size of the interval and its end point onto the min-heap.",
                    "solutionCode": "            heapq.heappush(minHeap, (r - l + 1, r))"
                },
                {
                    "id": 11,
                    "instruction": "Increment interval index.",
                    "placeholderCode": "            i += 1",
                    "validationRegex": "^\\s+i\\s*\\+=\\s*1$",
                    "hint": "Move to the next interval.",
                    "solutionCode": "            i += 1"
                },
                {
                    "id": 12,
                    "instruction": "Remove invalid intervals from heap.",
                    "placeholderCode": "        while minHeap and minHeap[0][1] < q:",
                    "validationRegex": "^\\s+while\\s+minHeap\\s+and\\s+minHeap\\[0\\]\\[1\\]\\s*<\\s*q:$",
                    "hint": "Loop while the heap is not empty and the top interval ends before the current query `q`.",
                    "solutionCode": "        while minHeap and minHeap[0][1] < q:"
                },
                {
                    "id": 13,
                    "instruction": "Pop invalid interval.",
                    "placeholderCode": "            heapq.heappop(minHeap)",
                    "validationRegex": "^\\s+heapq\\.heappop\\(minHeap\\)$",
                    "hint": "Remove the invalid interval from the heap.",
                    "solutionCode": "            heapq.heappop(minHeap)"
                },
                {
                    "id": 14,
                    "instruction": "Store result for current query.",
                    "placeholderCode": "        res[q] = minHeap[0][0] if minHeap else -1",
                    "validationRegex": "^\\s+res\\[q\\]\\s*=\\s*minHeap\\[0\\]\\[0\\]\\s+if\\s+minHeap\\s+else\\s+-1$",
                    "hint": "If the heap is not empty, the top element has the smallest size. Otherwise store -1.",
                    "solutionCode": "        res[q] = minHeap[0][0] if minHeap else -1"
                },
                {
                    "id": 15,
                    "instruction": "Return result mapped to original queries.",
                    "placeholderCode": "    return [res[q] for q in queries]",
                    "validationRegex": "^\\s+return\\s+\\[res\\[q\\]\\s+for\\s+q\\s+in\\s+queries\\]$",
                    "hint": "Map the results back to the original order of queries.",
                    "solutionCode": "    return [res[q] for q in queries]"
                }
            ]
        }
    }
}