{
    "id": "minimum-interval-to-include-each-query",
    "title": "Minimum Interval to Include Each Query",
    "description": "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1.\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\nReturn an array containing the answers to the queries.",
    "examples": [
        {
            "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
            "output": "[3,3,1,4]",
            "explanation": "The queries are processed as follows:\n- Query = 2: The interval [2,4] is the smallest interval containing 2. The size is 4 - 2 + 1 = 3.\n- Query = 3: The interval [2,4] is the smallest interval containing 3. The size is 4 - 2 + 1 = 3.\n- Query = 4: The interval [4,4] is the smallest interval containing 4. The size is 4 - 4 + 1 = 1.\n- Query = 5: The interval [3,6] is the smallest interval containing 5. The size is 6 - 3 + 1 = 4."
        },
        {
            "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
            "output": "[2,-1,4,6]",
            "explanation": "- Query = 2: The interval [2,3] is the smallest interval containing 2. The size is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval [2,5] is the smallest interval containing 5. The size is 5 - 2 + 1 = 4.\n- Query = 22: The interval [20,25] is the smallest interval containing 22. The size is 25 - 20 + 1 = 6."
        }
    ],
    "constraints": [
        "1 <= intervals.length <= 10^5",
        "1 <= queries.length <= 10^5",
        "intervals[i].length == 2",
        "1 <= lefti <= righti <= 10^7",
        "1 <= queries[j] <= 10^7"
    ],
    "difficulty": "Hard",
    "topic": "Intervals",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Linear Scan",
            "description": "Check every interval for every query.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_interval that takes intervals and queries.",
                    "placeholderCode": "def min_interval(intervals, queries):",
                    "validationRegex": "^def\\s+min_interval\\(intervals,\\s*queries\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_interval(intervals, queries):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result list.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "Initialize an empty list for results.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through queries.",
                    "placeholderCode": "    for q in queries:\n        min_size = float('inf')\n        found = False\n        for l, r in intervals:\n            if l <= q <= r:\n                min_size = min(min_size, r - l + 1)\n                found = True\n        res.append(min_size if found else -1)",
                    "validationRegex": "^\\s+for\\s+q\\s+in\\s+queries:\\s*min_size\\s*=\\s*float\\('inf'\\)\\s*found\\s*=\\s*False\\s*for\\s+l,\\s*r\\s+in\\s+intervals:\\s*if\\s+l\\s*<=\\s*q\\s*<=\\s*r:\\s*min_size\\s*=\\s*min\\(min_size,\\s*r\\s*-\\s*l\\s*\\+\\s*1\\)\\s*found\\s*=\\s*True\\s*res\\.append\\(min_size\\s+if\\s+found\\s+else\\s+-1\\)$",
                    "hint": "For each query, iterate through all intervals. If query is in interval, update min_size. Append result.",
                    "solutionCode": "    for q in queries:\n        min_size = float('inf')\n        found = False\n        for l, r in intervals:\n            if l <= q <= r:\n                min_size = min(min_size, r - l + 1)\n                found = True\n        res.append(min_size if found else -1)"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the list of results.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Min Heap + Sorting",
            "description": "Sort intervals and queries, use min heap for active intervals.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_interval that takes intervals and queries.",
                    "placeholderCode": "def min_interval(intervals, queries):",
                    "validationRegex": "^def\\s+min_interval\\(intervals,\\s*queries\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_interval(intervals, queries):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals and queries.",
                    "placeholderCode": "    intervals.sort()\n    minHeap = []\n    res = {}\n    i = 0\n    sorted_queries = sorted(queries)",
                    "validationRegex": "^\\s+intervals\\.sort\\(\\)\\s*minHeap\\s*=\\s*\\[\\]\\s*res\\s*=\\s*\\{\\}\\s*i\\s*=\\s*0\\s*sorted_queries\\s*=\\s*sorted\\(queries\\)$",
                    "hint": "Sort intervals by start time. Sort queries to process in order. Use a min heap to store [size, end] of active intervals.",
                    "solutionCode": "    intervals.sort()\n    minHeap = []\n    res = {}\n    i = 0\n    sorted_queries = sorted(queries)"
                },
                {
                    "id": 3,
                    "instruction": "Process queries.",
                    "placeholderCode": "    for q in sorted_queries:\n        while i < len(intervals) and intervals[i][0] <= q:\n            l, r = intervals[i]\n            heapq.heappush(minHeap, (r - l + 1, r))\n            i += 1\n        while minHeap and minHeap[0][1] < q:\n            heapq.heappop(minHeap)\n        res[q] = minHeap[0][0] if minHeap else -1",
                    "validationRegex": "^\\s+for\\s+q\\s+in\\s+sorted_queries:\\s*while\\s+i\\s*<\\s+len\\(intervals\\)\\s+and\\s+intervals\\[i\\]\\[0\\]\\s*<=\\s*q:\\s*l,\\s*r\\s*=\\s*intervals\\[i\\]\\s*heapq\\.heappush\\(minHeap,\\s*\\(r\\s*-\\s*l\\s*\\+\\s*1,\\s*r\\)\\)\\s*i\\s*\\+=\\s*1\\s*while\\s+minHeap\\s+and\\s+minHeap\\[0\\]\\[1\\]\\s*<\\s*q:\\s*heapq\\.heappop\\(minHeap\\)\\s*res\\[q\\]\\s*=\\s*minHeap\\[0\\]\\[0\\]\\s+if\\s+minHeap\\s+else\\s+-1$",
                    "hint": "Add intervals starting before q to heap. Remove intervals ending before q from heap. Top of heap is the smallest valid interval.",
                    "solutionCode": "    for q in sorted_queries:\n        while i < len(intervals) and intervals[i][0] <= q:\n            l, r = intervals[i]\n            heapq.heappush(minHeap, (r - l + 1, r))\n            i += 1\n        while minHeap and minHeap[0][1] < q:\n            heapq.heappop(minHeap)\n        res[q] = minHeap[0][0] if minHeap else -1"
                },
                {
                    "id": 4,
                    "instruction": "Return result mapped to original queries.",
                    "placeholderCode": "    return [res[q] for q in queries]",
                    "validationRegex": "^\\s+return\\s+\\[res\\[q\\]\\s+for\\s+q\\s+in\\s+queries\\]$",
                    "hint": "Map the results back to the original order of queries.",
                    "solutionCode": "    return [res[q] for q in queries]"
                }
            ]
        }
    }
}