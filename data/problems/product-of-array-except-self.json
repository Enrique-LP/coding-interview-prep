{
    "id": "product-of-array-except-self",
    "title": "Product of Array Except Self",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
        {
            "input": "nums = [1,2,3,4]",
            "output": "[24,12,8,6]"
        },
        {
            "input": "nums = [-1,1,0,-3,3]",
            "output": "[0,0,9,0,0]"
        }
    ],
    "constraints": [
        "2 <= nums.length <= 10^5",
        "-30 <= nums[i] <= 30",
        "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
    ],
    "difficulty": "Medium",
    "topic": "Arrays & Hashing",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Nested Loops",
            "description": "Calculate product for each element.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function product_except_self that takes nums.",
                    "placeholderCode": "def product_except_self(nums):",
                    "validationRegex": "^def\\s+product_except_self\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def product_except_self(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate and calculate product.",
                    "placeholderCode": "    res = []\n    for i in range(len(nums)):\n        prod = 1\n        for j in range(len(nums)):\n            if i != j:\n                prod *= nums[j]\n        res.append(prod)",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\):\\s*prod\\s*=\\s*1\\s*for\\s+j\\s+in\\s+range\\(len\\(nums\\)\\):\\s*if\\s+i\\s*!=\\s*j:\\s*prod\\s*\\*=\\s*nums\\[j\\]\\s*res\\.append\\(prod\\)$",
                    "hint": "Use nested loops. Inner loop multiplies all `nums[j]` where `i != j`.",
                    "solutionCode": "    res = []\n    for i in range(len(nums)):\n        prod = 1\n        for j in range(len(nums)):\n            if i != j:\n                prod *= nums[j]\n        res.append(prod)"
                },
                {
                    "id": 3,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result list.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Prefix and Suffix Products",
            "description": "Use prefix and suffix arrays (or single array) to store products.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function product_except_self that takes nums.",
                    "placeholderCode": "def product_except_self(nums):",
                    "validationRegex": "^def\\s+product_except_self\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def product_except_self(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result array.",
                    "placeholderCode": "    res = [1] * len(nums)",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[1\\]\\s*\\*\\s*len\\(nums\\)$",
                    "hint": "Create a list of 1s with size `len(nums)`.",
                    "solutionCode": "    res = [1] * len(nums)"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the prefix product variable.",
                    "placeholderCode": "    prefix = 1",
                    "validationRegex": "^\\s+prefix\\s*=\\s*1$",
                    "hint": "Concept: Product Except Self = (Left Product) * (Right Product). `prefix` tracks the Left Product. Start at 1. Example nums=[1, 2, 3, 4]. At i=2 (value 3), `prefix` will eventually store 1*2 = 2.",
                    "solutionCode": "    prefix = 1"
                },
                {
                    "id": 4,
                    "instruction": "Iterate through the array to calculate prefix products.",
                    "placeholderCode": "    for i in range(len(nums)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\):$",
                    "hint": "We loop through every index `i` of the input array `nums`.",
                    "solutionCode": "    for i in range(len(nums)):"
                },
                {
                    "id": 5,
                    "instruction": "Store the current prefix product in the result.",
                    "placeholderCode": "        res[i] = prefix",
                    "validationRegex": "^\\s+res\\[i\\]\\s*=\\s*prefix$",
                    "hint": "Crucial Step: Before we multiply `nums[i]` into our prefix, `prefix` holds the product of everything to the LEFT of `i`. So `res[i]` becomes that product.",
                    "solutionCode": "        res[i] = prefix"
                },
                {
                    "id": 6,
                    "instruction": "Update the prefix product for the next iteration.",
                    "placeholderCode": "        prefix *= nums[i]",
                    "validationRegex": "^\\s+prefix\\s*\\*=\\s*nums\\[i\\]$",
                    "hint": "Now that we've used the old prefix for `i`, we include `nums[i]` in the prefix so it's ready for `i+1`.",
                    "solutionCode": "        prefix *= nums[i]"
                },
                {
                    "id": 7,
                    "instruction": "Initialize the suffix product variable.",
                    "placeholderCode": "    postfix = 1",
                    "validationRegex": "^\\s+postfix\\s*=\\s*1$",
                    "hint": "Now the Right Product! `postfix` tracks product of numbers to the RIGHT. Example nums=[1, 2, 3, 4]. At i=2 (value 3), `postfix` will capture 4. Final calculation: Prefix(2) * Postfix(4) = 8.",
                    "solutionCode": "    postfix = 1"
                },
                {
                    "id": 8,
                    "instruction": "Iterate backwards through the array.",
                    "placeholderCode": "    for i in range(len(nums) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "We loop from the last index down to 0 to calculate the products from the RIGHT side.",
                    "solutionCode": "    for i in range(len(nums) - 1, -1, -1):"
                },
                {
                    "id": 9,
                    "instruction": "Multiply the current result by the suffix product.",
                    "placeholderCode": "        res[i] *= postfix",
                    "validationRegex": "^\\s+res\\[i\\]\\s*\\*=\\s*postfix$",
                    "hint": "`res[i]` already has the PREFIX product. Initializing it with `*=` POSTFIX combines both sides: `prefix * suffix` = Product of Array Except Self!",
                    "solutionCode": "        res[i] *= postfix"
                },
                {
                    "id": 10,
                    "instruction": "Update the suffix product for the next iteration.",
                    "placeholderCode": "        postfix *= nums[i]",
                    "validationRegex": "^\\s+postfix\\s*\\*=\\s*nums\\[i\\]$",
                    "hint": "Include the current number `nums[i]` in the `postfix` so it's ready for the next index to the left (`i-1`).",
                    "solutionCode": "        postfix *= nums[i]"
                },
                {
                    "id": 11,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the result list.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}