{
    "id": "meeting-rooms",
    "title": "Meeting Rooms",
    "description": "Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.",
    "examples": [
        {
            "input": "intervals = [[0,30],[5,10],[15,20]]",
            "output": "false"
        },
        {
            "input": "intervals = [[7,10],[2,4]]",
            "output": "true"
        }
    ],
    "constraints": [
        "0 <= intervals.length <= 10^4",
        "intervals[i].length == 2",
        "0 <= starti < endi <= 10^6"
    ],
    "difficulty": "Easy",
    "topic": "Intervals",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Sort and check for overlap.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function can_attend_meetings that takes intervals.",
                    "placeholderCode": "def can_attend_meetings(intervals):",
                    "validationRegex": "^def\\s+can_attend_meetings\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def can_attend_meetings(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals.",
                    "placeholderCode": "    intervals.sort(key=lambda i: i[0])",
                    "validationRegex": "^\\s+intervals\\.sort\\(key=lambda\\s+i:\\s+i\\[0\\]\\)$",
                    "hint": "Sort intervals by start time.",
                    "solutionCode": "    intervals.sort(key=lambda i: i[0])"
                },
                {
                    "id": 3,
                    "instruction": "Check for overlaps.",
                    "placeholderCode": "    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(1,\\s*len\\(intervals\\)\\):\\s*if\\s+intervals\\[i\\]\\[0\\]\\s*<\\s+intervals\\[i\\s*-\\s*1\\]\\[1\\]:\\s*return\\s+False$",
                    "hint": "Iterate through sorted intervals. If current start time is less than previous end time, there is an overlap.",
                    "solutionCode": "    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False"
                },
                {
                    "id": 4,
                    "instruction": "Return True.",
                    "placeholderCode": "    return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "If no overlaps found, return True.",
                    "solutionCode": "    return True"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force, O(n log n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function can_attend_meetings that takes intervals.",
                    "placeholderCode": "def can_attend_meetings(intervals):",
                    "validationRegex": "^def\\s+can_attend_meetings\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def can_attend_meetings(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Sort intervals.",
                    "placeholderCode": "    intervals.sort(key=lambda i: i[0])",
                    "validationRegex": "^\\s+intervals\\.sort\\(key=lambda\\s+i:\\s+i\\[0\\]\\)$",
                    "hint": "Sort intervals.",
                    "solutionCode": "    intervals.sort(key=lambda i: i[0])"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through the sorted intervals starting from the second one.",
                    "placeholderCode": "    for i in range(1, len(intervals)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(1,\\s*len\\(intervals\\)\\):$",
                    "hint": "Use a for loop with range(1, len(intervals)).",
                    "solutionCode": "    for i in range(1, len(intervals)):"
                },
                {
                    "id": 4,
                    "instruction": "Check if the current meeting starts before the previous one ends.",
                    "placeholderCode": "        if intervals[i][0] < intervals[i - 1][1]:",
                    "validationRegex": "^\\s+if\\s+intervals\\[i\\]\\[0\\]\\s*<\\s+intervals\\[i\\s*-\\s*1\\]\\[1\\]:$",
                    "hint": "Compare intervals[i][0] with intervals[i-1][1].",
                    "solutionCode": "        if intervals[i][0] < intervals[i - 1][1]:"
                },
                {
                    "id": 5,
                    "instruction": "If an overlap is detected, return False.",
                    "placeholderCode": "            return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "Meeting rooms cannot overlap, so return False.",
                    "solutionCode": "            return False"
                },
                {
                    "id": 6,
                    "instruction": "If the loop finishes without finding any overlaps, return True.",
                    "placeholderCode": "    return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "Return True.",
                    "solutionCode": "    return True"
                }
            ]
        }
    }
}