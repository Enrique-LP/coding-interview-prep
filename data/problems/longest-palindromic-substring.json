{
    "id": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s.",
    "examples": [
        {
            "input": "s = \"babad\"",
            "output": "\"bab\"",
            "explanation": "\"aba\" is also a valid answer."
        },
        {
            "input": "s = \"cbbd\"",
            "output": "\"bb\""
        }
    ],
    "constraints": [
        "1 <= s.length <= 1000",
        "s consists of only digits and English letters."
    ],
    "difficulty": "Medium",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Check palindrome expanding from each character.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function longest_palindrome that takes s.",
                    "placeholderCode": "def longest_palindrome(s):",
                    "validationRegex": "^def\\s+longest_palindrome\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def longest_palindrome(s):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result string and length.",
                    "placeholderCode": "    res = \"\"\n    resLen = 0",
                    "validationRegex": "^\\s+res\\s*=\\s*\"\"\\s*resLen\\s*=\\s*0$",
                    "hint": "Initialize variables to store the longest palindrome found so far.",
                    "solutionCode": "    res = \"\"\n    resLen = 0"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through string.",
                    "placeholderCode": "    for i in range(len(s)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\)\\):$",
                    "hint": "Iterate through each character in the string, treating it as the center of a potential palindrome.",
                    "solutionCode": "    for i in range(len(s)):"
                },
                {
                    "id": 4,
                    "instruction": "Check odd length palindromes.",
                    "placeholderCode": "        l, r = i, i\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if (r - l + 1) > resLen:\n                res = s[l:r+1]\n                resLen = r - l + 1\n            l -= 1\n            r += 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*i,\\s*i\\s*while\\s+l\\s*>=\\s*0\\s+and\\s+r\\s*<\\s+len\\(s\\)\\s+and\\s+s\\[l\\]\\s*==\\s+s\\[r\\]:\\s*if\\s*\\(r\\s*-\\s*l\\s*\\+\\s*1\\)\\s*>\\s*resLen:\\s*res\\s*=\\s*s\\[l:r\\+1\\]\\s*resLen\\s*=\\s*r\\s*-\\s*l\\s*\\+\\s*1\\s*l\\s*-=\\s*1\\s*r\\s*\\+=\\s*1$",
                    "hint": "Expand outwards from single character center (odd length). Update max length if found.",
                    "solutionCode": "        l, r = i, i\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if (r - l + 1) > resLen:\n                res = s[l:r+1]\n                resLen = r - l + 1\n            l -= 1\n            r += 1"
                },
                {
                    "id": 5,
                    "instruction": "Check even length palindromes.",
                    "placeholderCode": "        l, r = i, i + 1\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if (r - l + 1) > resLen:\n                res = s[l:r+1]\n                resLen = r - l + 1\n            l -= 1\n            r += 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*i,\\s*i\\s*\\+\\s*1\\s*while\\s+l\\s*>=\\s*0\\s+and\\s+r\\s*<\\s+len\\(s\\)\\s+and\\s+s\\[l\\]\\s*==\\s+s\\[r\\]:\\s*if\\s*\\(r\\s*-\\s*l\\s*\\+\\s*1\\)\\s*>\\s*resLen:\\s*res\\s*=\\s*s\\[l:r\\+1\\]\\s*resLen\\s*=\\s*r\\s*-\\s*l\\s*\\+\\s*1\\s*l\\s*-=\\s*1\\s*r\\s*\\+=\\s*1$",
                    "hint": "Expand outwards from between characters (even length). Update max length if found.",
                    "solutionCode": "        l, r = i, i + 1\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            if (r - l + 1) > resLen:\n                res = s[l:r+1]\n                resLen = r - l + 1\n            l -= 1\n            r += 1"
                },
                {
                    "id": 6,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the longest palindrome string found.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force, O(n^2) time and O(1) space.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function longest_palindrome that takes s.",
                    "placeholderCode": "def longest_palindrome(s):",
                    "validationRegex": "^def\\s+longest_palindrome\\(s\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def longest_palindrome(s):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the result string as empty.",
                    "placeholderCode": "    res = \"\"",
                    "validationRegex": "^\\s+res\\s*=\\s*\"\"$",
                    "hint": "This variable will store the actual palindromic substring.",
                    "solutionCode": "    res = \"\""
                },
                {
                    "id": 3,
                    "instruction": "Initialize the length of the longest palindrome found to zero.",
                    "placeholderCode": "    resLen = 0",
                    "validationRegex": "^\\s+resLen\\s*=\\s*0$",
                    "hint": "Use this to track and compare the lengths of various centered palindromes.",
                    "solutionCode": "    resLen = 0"
                },
                {
                    "id": 4,
                    "instruction": "Iterate through each character in the string, treating it as a potential center.",
                    "placeholderCode": "    for i in range(len(s)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\)\\):$",
                    "hint": "Every character (or space between) can be the center of a palindrome.",
                    "solutionCode": "    for i in range(len(s)):"
                },
                {
                    "id": 5,
                    "instruction": "Initialize the left and right pointers at the current index 'i' (odd length center).",
                    "placeholderCode": "        l, r = i, i",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*i,\\s*i$",
                    "hint": "For odd-length palindromes, the center is a single character.",
                    "solutionCode": "        l, r = i, i"
                },
                {
                    "id": 6,
                    "instruction": "Expand outwards as long as the characters at pointers 'l' and 'r' match.",
                    "placeholderCode": "        while l >= 0 and r < len(s) and s[l] == s[r]:",
                    "validationRegex": "^\\s+while\\s+l\\s*>=\\s*0\\s+and\\s+r\\s*<\\s+len\\(s\\)\\s+and\\s+s\\[l\\]\\s*==\\s+s\\[r\\]:$",
                    "hint": "Ensure the pointers are within bounds and the symmetry is maintained.",
                    "solutionCode": "        while l >= 0 and r < len(s) and s[l] == s[r]:"
                },
                {
                    "id": 7,
                    "instruction": "Check if the current palindrome is longer than the previous maximum.",
                    "placeholderCode": "            if (r - l + 1) > resLen:",
                    "validationRegex": "^\\s+if\\s+\\(r\\s*-\\s*l\\s*\\+\\s*1\\)\\s*>\\s*resLen:$",
                    "hint": "Compare the current window width (r - l + 1) with our record.",
                    "solutionCode": "            if (r - l + 1) > resLen:"
                },
                {
                    "id": 8,
                    "instruction": "Update the result string with the new longest palindrome.",
                    "placeholderCode": "                res = s[l:r+1]",
                    "validationRegex": "^\\s+res\\s*=\\s*s\\[l:r\\+1\\]$",
                    "hint": "Slice the string to capture the symmetric part.",
                    "solutionCode": "                res = s[l:r+1]"
                },
                {
                    "id": 9,
                    "instruction": "Update the maximum length record.",
                    "placeholderCode": "                resLen = r - l + 1",
                    "validationRegex": "^\\s+resLen\\s*=\\s*r\\s*-\\s*l\\s*\\+\\s*1$",
                    "hint": "Record the new length to compare in future iterations.",
                    "solutionCode": "                resLen = r - l + 1"
                },
                {
                    "id": 10,
                    "instruction": "Move the left pointer one step to the left.",
                    "placeholderCode": "            l -= 1",
                    "validationRegex": "^\\s+l\\s*-=\\s*1$",
                    "hint": "Expand the window outwards.",
                    "solutionCode": "            l -= 1"
                },
                {
                    "id": 11,
                    "instruction": "Move the right pointer one step to the right.",
                    "placeholderCode": "            r += 1",
                    "validationRegex": "^\\s+r\\s*\\+=\\s*1$",
                    "hint": "Continue the expansion in the next while loop iteration.",
                    "solutionCode": "            r += 1"
                },
                {
                    "id": 12,
                    "instruction": "Initialize the left and right pointers around index 'i' and 'i+1' (even length center).",
                    "placeholderCode": "        l, r = i, i + 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*i,\\s*i\\s*\\+\\s*1$",
                    "hint": "For even-length palindromes, the center is the gap between two characters.",
                    "solutionCode": "        l, r = i, i + 1"
                },
                {
                    "id": 13,
                    "instruction": "Expand outwards as long as the characters at pointers 'l' and 'r' match.",
                    "placeholderCode": "        while l >= 0 and r < len(s) and s[l] == s[r]:",
                    "validationRegex": "^\\s+while\\s+l\\s*>=\\s*0\\s+and\\s+r\\s*<\\s+len\\(s\\)\\s+and\\s+s\\[l\\]\\s*==\\s+s\\[r\\]:$",
                    "hint": "Ensure the pointers are within bounds and the symmetry is maintained.",
                    "solutionCode": "        while l >= 0 and r < len(s) and s[l] == s[r]:"
                },
                {
                    "id": 14,
                    "instruction": "Check if the current even palindrome is longer than the current maximum.",
                    "placeholderCode": "            if (r - l + 1) > resLen:",
                    "validationRegex": "^\\s+if\\s+\\(r\\s*-\\s*l\\s*\\+\\s*1\\)\\s*>\\s*resLen:$",
                    "hint": "Compare the current window width (r - l + 1) with our record.",
                    "solutionCode": "            if (r - l + 1) > resLen:"
                },
                {
                    "id": 15,
                    "instruction": "Update the result string with the new longest even palindrome.",
                    "placeholderCode": "                res = s[l:r+1]",
                    "validationRegex": "^\\s+res\\s*=\\s*s\\[l:r\\+1\\]$",
                    "hint": "Slice the string to capture the symmetric part.",
                    "solutionCode": "                res = s[l:r+1]"
                },
                {
                    "id": 16,
                    "instruction": "Update the maximum length record for even palindromes.",
                    "placeholderCode": "                resLen = r - l + 1",
                    "validationRegex": "^\\s+resLen\\s*=\\s*r\\s*-\\s*l\\s*\\+\\s*1$",
                    "hint": "Record the new length to compare in future iterations.",
                    "solutionCode": "                resLen = r - l + 1"
                },
                {
                    "id": 17,
                    "instruction": "Move the left pointer one step to the left for even expansion.",
                    "placeholderCode": "            l -= 1",
                    "validationRegex": "^\\s+l\\s*-=\\s*1$",
                    "hint": "Expand the window outwards.",
                    "solutionCode": "            l -= 1"
                },
                {
                    "id": 18,
                    "instruction": "Move the right pointer one step to the right for even expansion.",
                    "placeholderCode": "            r += 1",
                    "validationRegex": "^\\s+r\\s*\\+=\\s*1$",
                    "hint": "Continue the expansion in the next while loop iteration.",
                    "solutionCode": "            r += 1"
                },
                {
                    "id": 19,
                    "instruction": "Return the final result string representing the longest palindrome found.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "The answer is finally stored in 'res'.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}