{
    "id": "clone-graph",
    "title": "Clone Graph",
    "description": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.",
    "examples": [
        {
            "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
            "output": "[[2,4],[1,3],[2,4],[1,3]]",
            "explanation": "There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3)."
        }
    ],
    "constraints": [
        "The number of nodes in the graph is in the range [0, 100].",
        "1 <= Node.val <= 100",
        "Node.val is unique for each node.",
        "There are no repeated edges and no self-loops in the graph.",
        "The Graph is connected and all nodes can be visited starting from the given node."
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS",
            "description": "Use a hash map to track cloned nodes and DFS to traverse.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function clone_graph that takes node.",
                    "placeholderCode": "def clone_graph(node):",
                    "validationRegex": "^def\\s+clone_graph\\(node\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def clone_graph(node):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize hash map for old_node -> new_node.",
                    "placeholderCode": "    oldToNew = {}",
                    "validationRegex": "^\\s+oldToNew\\s*=\\s*\\{\\}$",
                    "hint": "Create a dictionary to map original nodes to their clones.",
                    "solutionCode": "    oldToNew = {}"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper.",
                    "placeholderCode": "    def dfs(node):\n        if node in oldToNew:\n            return oldToNew[node]",
                    "validationRegex": "^\\s+def\\s+dfs\\(node\\):\\s*if\\s+node\\s+in\\s+oldToNew:\\s*return\\s+oldToNew\\[node\\]$",
                    "hint": "If the node has already been cloned, return the clone from the map.",
                    "solutionCode": "    def dfs(node):\n        if node in oldToNew:\n            return oldToNew[node]"
                },
                {
                    "id": 4,
                    "instruction": "Create copy of node and add to map.",
                    "placeholderCode": "        copy = Node(node.val)\n        oldToNew[node] = copy",
                    "validationRegex": "^\\s+copy\\s*=\\s*Node\\(node\\.val\\)\\s*oldToNew\\[node\\]\\s*=\\s*copy$",
                    "hint": "Create a new node with the same value and store it in the map.\\n\\nExample:\\nOriginal Node 1. Neighbors: [2, 4].\\nCreate Copy 1. Map: {Node1: Copy1}.\\nRecurse on 2. Create Copy 2. Map: {Node1: Copy1, Node2: Copy2}.\\nLink Copy1.neighbors.append(Copy2).",
                    "solutionCode": "        copy = Node(node.val)\n        oldToNew[node] = copy"
                },
                {
                    "id": 5,
                    "instruction": "Recursively clone neighbors.",
                    "placeholderCode": "        for nei in node.neighbors:\n            copy.neighbors.append(dfs(nei))",
                    "validationRegex": "^\\s+for\\s+nei\\s+in\\s+node\\.neighbors:\\s*copy\\.neighbors\\.append\\(dfs\\(nei\\)\\)$",
                    "hint": "Iterate through neighbors and recursively clone them.",
                    "solutionCode": "        for nei in node.neighbors:\n            copy.neighbors.append(dfs(nei))"
                },
                {
                    "id": 6,
                    "instruction": "Return copy.",
                    "placeholderCode": "        return copy",
                    "validationRegex": "^\\s+return\\s+copy$",
                    "hint": "Return the cloned node.",
                    "solutionCode": "        return copy"
                },
                {
                    "id": 7,
                    "instruction": "Call DFS if node exists.",
                    "placeholderCode": "    return dfs(node) if node else None",
                    "validationRegex": "^\\s+return\\s+dfs\\(node\\)\\s+if\\s+node\\s+else\\s+None$",
                    "hint": "Start DFS from the input node if it's not None.",
                    "solutionCode": "    return dfs(node) if node else None"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "DFS",
            "description": "Same as brute force, O(V+E).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function clone_graph that takes node.",
                    "placeholderCode": "def clone_graph(node):",
                    "validationRegex": "^def\\s+clone_graph\\(node\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def clone_graph(node):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize hash map for old_node -> new_node.",
                    "placeholderCode": "    oldToNew = {}",
                    "validationRegex": "^\\s+oldToNew\\s*=\\s*\\{\\}$",
                    "hint": "Create a dictionary to map original nodes to their clones.",
                    "solutionCode": "    oldToNew = {}"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper function header.",
                    "placeholderCode": "    def dfs(node):",
                    "validationRegex": "^\\s+def\\s+dfs\\(node\\):$",
                    "hint": "Start the DFS helper function.",
                    "solutionCode": "    def dfs(node):"
                },
                {
                    "id": 4,
                    "instruction": "Check if the node has already been cloned.",
                    "placeholderCode": "        if node in oldToNew:",
                    "validationRegex": "^\\s+if\\s+node\\s+in\\s+oldToNew:$",
                    "hint": "Look up the node in the hash map.",
                    "solutionCode": "        if node in oldToNew:"
                },
                {
                    "id": 5,
                    "instruction": "Return the already cloned node if it exists.",
                    "placeholderCode": "            return oldToNew[node]",
                    "validationRegex": "^\\s+return\\s+oldToNew\\[node\\]$",
                    "hint": "Return the value from the map.",
                    "solutionCode": "            return oldToNew[node]"
                },
                {
                    "id": 6,
                    "instruction": "Create a copy of the current node.",
                    "placeholderCode": "        copy = Node(node.val)",
                    "validationRegex": "^\\s+copy\\s*=\\s*Node\\(node\\.val\\)$",
                    "hint": "Create a new Node instance using the value of the original node.",
                    "solutionCode": "        copy = Node(node.val)"
                },
                {
                    "id": 7,
                    "instruction": "Store the cloned node in the hash map.",
                    "placeholderCode": "        oldToNew[node] = copy",
                    "validationRegex": "^\\s+oldToNew\\[node\\]\\s*=\\s*copy$",
                    "hint": "Map the original node to its new copy to avoid redundant cloning.",
                    "solutionCode": "        oldToNew[node] = copy"
                },
                {
                    "id": 8,
                    "instruction": "Recursively clone neighbors.",
                    "placeholderCode": "        for nei in node.neighbors:\n            copy.neighbors.append(dfs(nei))",
                    "validationRegex": "^\\s+for\\s+nei\\s+in\\s+node\\.neighbors:\\s*copy\\.neighbors\\.append\\(dfs\\(nei\\)\\)$",
                    "hint": "Iterate through neighbors and recursively clone them.",
                    "solutionCode": "        for nei in node.neighbors:\n            copy.neighbors.append(dfs(nei))"
                },
                {
                    "id": 9,
                    "instruction": "Return copy.",
                    "placeholderCode": "        return copy",
                    "validationRegex": "^\\s+return\\s+copy$",
                    "hint": "Return the cloned node.",
                    "solutionCode": "        return copy"
                },
                {
                    "id": 10,
                    "instruction": "Call DFS if node exists.",
                    "placeholderCode": "    return dfs(node) if node else None",
                    "validationRegex": "^\\s+return\\s+dfs\\(node\\)\\s+if\\s+node\\s+else\\s+None$",
                    "hint": "Start DFS from the input node if it's not None.",
                    "solutionCode": "    return dfs(node) if node else None"
                }
            ]
        }
    }
}