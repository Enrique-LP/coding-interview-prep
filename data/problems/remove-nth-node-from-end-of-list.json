{
    "id": "remove-nth-node-from-end-of-list",
    "title": "Remove Nth Node From End of List",
    "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
    "examples": [
        {
            "input": "head = [1,2,3,4,5], n = 2",
            "output": "[1,2,3,5]"
        },
        {
            "input": "head = [1], n = 1",
            "output": "[]"
        }
    ],
    "constraints": [
        "The number of nodes in the list is sz.",
        "1 <= sz <= 30",
        "0 <= Node.val <= 100",
        "1 <= n <= sz"
    ],
    "difficulty": "Medium",
    "topic": "Linked List",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Two Pass",
            "description": "Calculate length first, then remove node.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'remove_nth_from_end' that takes 'head' and 'n' as arguments.",
                    "placeholderCode": "def remove_nth_from_end(head, n):",
                    "validationRegex": "^def\\s+remove_nth_from_end\\(head,\\s*n\\):$",
                    "hint": "Use `def` to define the function named `remove_nth_from_end`.",
                    "solutionCode": "def remove_nth_from_end(head, n):"
                },
                {
                    "id": 2,
                    "instruction": "Calculate the length of the list.",
                    "placeholderCode": "    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next",
                    "validationRegex": "^\\s+length\\s*=\\s*0\\s*curr\\s*=\\s*head\\s*while\\s+curr:\\s*length\\s*\\+=\\s*1\\s*curr\\s*=\\s*curr\\.next$",
                    "hint": "Traverse list to count nodes.",
                    "solutionCode": "    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next"
                },
                {
                    "id": 3,
                    "instruction": "Handle edge case: removing the head.",
                    "placeholderCode": "    if length == n:\n        return head.next",
                    "validationRegex": "^\\s+if\\s+length\\s*==\\s*n:\\s*return\\s+head\\.next$",
                    "hint": "If `length == n`, remove the first node.",
                    "solutionCode": "    if length == n:\n        return head.next"
                },
                {
                    "id": 4,
                    "instruction": "Iterate to the node before the one to remove.",
                    "placeholderCode": "    curr = head\n    for _ in range(length - n - 1):\n        curr = curr.next",
                    "validationRegex": "^\\s+curr\\s*=\\s*head\\s*for\\s+_\\s+in\\s+range\\(length\\s*-\\s*n\\s*-\\s*1\\):\\s*curr\\s*=\\s*curr\\.next$",
                    "hint": "Move `curr` to `length - n - 1` position.",
                    "solutionCode": "    curr = head\n    for _ in range(length - n - 1):\n        curr = curr.next"
                },
                {
                    "id": 5,
                    "instruction": "Remove the node.",
                    "placeholderCode": "    curr.next = curr.next.next",
                    "validationRegex": "^\\s+curr\\.next\\s*=\\s*curr\\.next\\.next$",
                    "hint": "Skip the next node.",
                    "solutionCode": "    curr.next = curr.next.next"
                },
                {
                    "id": 6,
                    "instruction": "Return head.",
                    "placeholderCode": "    return head",
                    "validationRegex": "^\\s+return\\s+head$",
                    "hint": "Return the head of the modified list.",
                    "solutionCode": "    return head"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "One Pass",
            "description": "Use two pointers separated by n nodes.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'remove_nth_from_end' that takes 'head' and 'n' as arguments.",
                    "placeholderCode": "def remove_nth_from_end(head, n):",
                    "validationRegex": "^def\\s+remove_nth_from_end\\(head,\\s*n\\):$",
                    "hint": "Use `def` to define the function named `remove_nth_from_end`.",
                    "solutionCode": "def remove_nth_from_end(head, n):"
                },
                {
                    "id": 2,
                    "instruction": "Create a dummy node that points to the head of the list.",
                    "placeholderCode": "    dummy = ListNode(0, head)",
                    "validationRegex": "^\\s+dummy\\s*=\\s*ListNode\\(0,\\s*head\\)$",
                    "hint": "A dummy node helps handle edge cases like removing the very first node of the list.",
                    "solutionCode": "    dummy = ListNode(0, head)"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the 'left' pointer at the dummy node.",
                    "placeholderCode": "    left = dummy",
                    "validationRegex": "^\\s+left\\s*=\\s*dummy$",
                    "hint": "The `left` pointer will eventually be at the node right BEFORE the one we want to remove.",
                    "solutionCode": "    left = dummy"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the 'right' pointer at the head of the list.",
                    "placeholderCode": "    right = head",
                    "validationRegex": "^\\s+right\\s*=\\s*head$",
                    "hint": "The `right` pointer will move ahead to create a gap of size `n` with `left`.",
                    "solutionCode": "    right = head"
                },
                {
                    "id": 5,
                    "instruction": "Initialize a loop to create a gap between the pointers.",
                    "placeholderCode": "    while n > 0 and right:",
                    "validationRegex": "^\\s+while\\s+n\\s*>\\s+0\\s+and\\s+right:$",
                    "hint": "The loop should run exactly 'n' times to advance the right pointer.",
                    "solutionCode": "    while n > 0 and right:"
                },
                {
                    "id": 6,
                    "instruction": "Move the 'right' pointer forward by one node.",
                    "placeholderCode": "        right = right.next",
                    "validationRegex": "^\\s+right\\s*=\\s*right\\.next$",
                    "hint": "Advance the `right` pointer to the next node in the list.",
                    "solutionCode": "        right = right.next"
                },
                {
                    "id": 7,
                    "instruction": "Decrement 'n' to keep track of the steps remaining.",
                    "placeholderCode": "        n -= 1",
                    "validationRegex": "^\\s+n\\s*-=\\s*1$",
                    "hint": "Decrease the counter in each iteration of the loop.",
                    "solutionCode": "        n -= 1"
                },
                {
                    "id": 8,
                    "instruction": "Move both pointers until 'right' reaches the end of the list.",
                    "placeholderCode": "    while right:\n        left = left.next\n        right = right.next",
                    "validationRegex": "^\\s+while\\s+right:\\s*left\\s*=\\s*left\\.next\\s*right\\s*=\\s*right\\.next$",
                    "hint": "Keep the gap constant until `right` falls off the end. `left` will now be right before the target node.",
                    "solutionCode": "    while right:\n        left = left.next\n        right = right.next"
                },
                {
                    "id": 9,
                    "instruction": "Remove the target node by skipping it.",
                    "placeholderCode": "    left.next = left.next.next",
                    "validationRegex": "^\\s+left\\.next\\s*=\\s*left\\.next\\.next$",
                    "hint": "Link `left.next` directly to the node after the target.",
                    "solutionCode": "    left.next = left.next.next"
                },
                {
                    "id": 10,
                    "instruction": "Return the head of the modified list using the dummy node's next pointer.",
                    "placeholderCode": "    return dummy.next",
                    "validationRegex": "^\\s+return\\s+dummy\\.next$",
                    "hint": "The `dummy.next` always points to the correct new head.",
                    "solutionCode": "    return dummy.next"
                }
            ]
        }
    }
}