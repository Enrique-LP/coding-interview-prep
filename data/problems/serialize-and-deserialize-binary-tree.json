{
    "id": "serialize-and-deserialize-binary-tree",
    "title": "Serialize and Deserialize Binary Tree",
    "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.",
    "examples": [
        {
            "input": "root = [1,2,3,null,null,4,5]",
            "output": [
                1,
                2,
                3,
                null,
                null,
                4,
                5
            ]
        },
        {
            "input": "root = []",
            "output": []
        }
    ],
    "constraints": [
        "The number of nodes in the tree is in the range [0, 10^4].",
        "-1000 <= Node.val <= 1000"
    ],
    "difficulty": "Hard",
    "topic": "Trees",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS Preorder",
            "description": "Use preorder traversal with delimiter.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define Codec class.",
                    "placeholderCode": "class Codec:",
                    "validationRegex": "^class\\s+Codec:$",
                    "hint": "Define the class.",
                    "solutionCode": "class Codec:"
                },
                {
                    "id": 2,
                    "instruction": "Define the serialize method that takes the root of the tree.",
                    "placeholderCode": "    def serialize(self, root):",
                    "validationRegex": "^\\s+def\\s+serialize\\(self,\\s*root\\):$",
                    "hint": "This method converts the tree into a single string.",
                    "solutionCode": "    def serialize(self, root):"
                },
                {
                    "id": 3,
                    "instruction": "Initialize an empty list 'res' to store the serialized values.",
                    "placeholderCode": "        res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "A list is more efficient than string concatenation for building the result.",
                    "solutionCode": "        res = []"
                },
                {
                    "id": 4,
                    "instruction": "Define a nested 'dfs' helper function that takes a node.",
                    "placeholderCode": "        def dfs(node):",
                    "validationRegex": "^\\s+def\\s+dfs\\(node\\):$",
                    "hint": "This helper will perform a preorder traversal (Root -> Left -> Right).",
                    "solutionCode": "        def dfs(node):"
                },
                {
                    "id": 5,
                    "instruction": "Check if the current node is None.",
                    "placeholderCode": "            if not node:",
                    "validationRegex": "^\\s+if\\s+not\\s+node:$",
                    "hint": "Base case for the recursion.",
                    "solutionCode": "            if not node:"
                },
                {
                    "id": 6,
                    "instruction": "Append a placeholder like 'N' for null nodes and return.",
                    "placeholderCode": "                res.append(\"N\")\n                return",
                    "validationRegex": "^\\s+res\\.append\\(\"N\"\\)\\s*return$",
                    "hint": "We must record null pointers to reconstruct the tree structure correctly.",
                    "solutionCode": "                res.append(\"N\")\n                return"
                },
                {
                    "id": 7,
                    "instruction": "Append the string value of the current node to 'res'.",
                    "placeholderCode": "            res.append(str(node.val))",
                    "validationRegex": "^\\s+res\\.append\\(str\\(node\\.val\\)\\)$",
                    "hint": "Store the current node's value as a string.",
                    "solutionCode": "            res.append(str(node.val))"
                },
                {
                    "id": 8,
                    "instruction": "Recursively call 'dfs' for the left child.",
                    "placeholderCode": "            dfs(node.left)",
                    "validationRegex": "^\\s+dfs\\(node\\.left\\)$",
                    "hint": "Traverse down the left branch.",
                    "solutionCode": "            dfs(node.left)"
                },
                {
                    "id": 9,
                    "instruction": "Recursively call 'dfs' for the right child.",
                    "placeholderCode": "            dfs(node.right)",
                    "validationRegex": "^\\s+dfs\\(node\\.right\\)$",
                    "hint": "Traverse down the right branch.",
                    "solutionCode": "            dfs(node.right)"
                },
                {
                    "id": 10,
                    "instruction": "Start the DFS traversal from the root.",
                    "placeholderCode": "        dfs(root)",
                    "validationRegex": "^\\s+dfs\\(root\\)$",
                    "hint": "Call the helper function to populate the 'res' list.",
                    "solutionCode": "        dfs(root)"
                },
                {
                    "id": 11,
                    "instruction": "Join the list elements into a single string separated by commas.",
                    "placeholderCode": "        return \",\".join(res)",
                    "validationRegex": "^\\s+return\\s+\",\"\\.join\\(res\\)$",
                    "hint": "This produces the final serialized string result.",
                    "solutionCode": "        return \",\".join(res)"
                },
                {
                    "id": 12,
                    "instruction": "Define the 'deserialize' method that takes the serialized data string.",
                    "placeholderCode": "    def deserialize(self, data):",
                    "validationRegex": "^\\s+def\\s+deserialize\\(self,\\s*data\\):$",
                    "hint": "This method reconstructs the binary tree from the string.",
                    "solutionCode": "    def deserialize(self, data):"
                },
                {
                    "id": 13,
                    "instruction": "Split the data string by commas into a list of values.",
                    "placeholderCode": "        vals = data.split(\",\")",
                    "validationRegex": "^\\s+vals\\s*=\\s*data\\.split\\(\",\"\\)$",
                    "hint": "This converts our string back into a manageable list of node values.",
                    "solutionCode": "        vals = data.split(\",\")"
                },
                {
                    "id": 14,
                    "instruction": "Initialize a global index 'self.i' to track current position in the list.",
                    "placeholderCode": "        self.i = 0",
                    "validationRegex": "^\\s+self\\.i\\s*=\\s*0$",
                    "hint": "We use a class variable so the nested recursive helper can update it correctly.",
                    "solutionCode": "        self.i = 0"
                },
                {
                    "id": 15,
                    "instruction": "Define a nested 'dfs' helper function for tree reconstruction.",
                    "placeholderCode": "        def dfs():",
                    "validationRegex": "^\\s+def\\s+dfs\\(\\):$",
                    "hint": "This helper will build the tree in preorder fashion.",
                    "solutionCode": "        def dfs():"
                },
                {
                    "id": 16,
                    "instruction": "Check if the current value in 'vals' is 'N' (null).",
                    "placeholderCode": "            if vals[self.i] == \"N\":",
                    "validationRegex": "^\\s+if\\s+vals\\[self\\.i\\]\\s*==\\s*\"N\":$",
                    "hint": "If we see 'N', it means this branch is empty.",
                    "solutionCode": "            if vals[self.i] == \"N\":"
                },
                {
                    "id": 17,
                    "instruction": "Increment the index and return None for the null node.",
                    "placeholderCode": "                self.i += 1\n                return None",
                    "validationRegex": "^\\s+self\\.i\\s*\\+=\\s*1\\s*return\\s*None$",
                    "hint": "Move to the next element and stop the current recursion.",
                    "solutionCode": "                self.i += 1\n                return None"
                },
                {
                    "id": 18,
                    "instruction": "Create a new TreeNode using the current integer value.",
                    "placeholderCode": "            node = TreeNode(int(vals[self.i]))",
                    "validationRegex": "^\\s+node\\s*=\\s*TreeNode\\(int\\(vals\\[self\\.i\\]\\)\\)$",
                    "hint": "Convert the stored string back into an integer for the node value.",
                    "solutionCode": "            node = TreeNode(int(vals[self.i]))"
                },
                {
                    "id": 19,
                    "instruction": "Increment the index after consuming a value.",
                    "placeholderCode": "            self.i += 1",
                    "validationRegex": "^\\s+self\\.i\\s*\\+=\\s*1$",
                    "hint": "Advance our global pointer to the next element.",
                    "solutionCode": "            self.i += 1"
                },
                {
                    "id": 20,
                    "instruction": "Recursively build and link the left subtree.",
                    "placeholderCode": "            node.left = dfs()",
                    "validationRegex": "^\\s+node\\.left\\s*=\\s*dfs\\(\\)$",
                    "hint": "Following preorder, the next elements in the list belong to the left child.",
                    "solutionCode": "            node.left = dfs()"
                },
                {
                    "id": 21,
                    "instruction": "Recursively build and link the right subtree.",
                    "placeholderCode": "            node.right = dfs()",
                    "validationRegex": "^\\s+node\\.right\\s*=\\s*dfs\\(\\)$",
                    "hint": "The subsequent elements after the left child's recursion belong to the right child.",
                    "solutionCode": "            node.right = dfs()"
                },
                {
                    "id": 22,
                    "instruction": "Return the reconstructed node.",
                    "placeholderCode": "            return node",
                    "validationRegex": "^\\s+return\\s+node$",
                    "hint": "Pass the completed subtree back to the parent caller.",
                    "solutionCode": "            return node"
                },
                {
                    "id": 23,
                    "instruction": "Initiate the reconstruction process from the starting index.",
                    "placeholderCode": "        return dfs()",
                    "validationRegex": "^\\s+return\\s+dfs\\(\\)$",
                    "hint": "Returns the root of the fully reconstructed tree.",
                    "solutionCode": "        return dfs()"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "DFS Preorder (Granular)",
            "description": "Standard DFS Preorder approach descomposed into line-by-line logical steps to ensure clarity in pointer management and tree reconstruction.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the Codec class.",
                    "placeholderCode": "class Codec:",
                    "validationRegex": "^class\\s+Codec:$",
                    "hint": "This class will handle both serialization and deserialization.",
                    "solutionCode": "class Codec:"
                },
                {
                    "id": 2,
                    "instruction": "Start implementing the 'serialize' method.",
                    "placeholderCode": "    def serialize(self, root):",
                    "validationRegex": "^\\s+def\\s+serialize\\(self,\\s*root\\):$",
                    "hint": "We need to turn the binary tree into a traversal string.",
                    "solutionCode": "    def serialize(self, root):"
                },
                {
                    "id": 3,
                    "instruction": "Initialize a 'res' list to accumulate node values as strings.",
                    "placeholderCode": "        res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "Appending to a list is $O(1)$ while string concat can be $O(N)$.",
                    "solutionCode": "        res = []"
                },
                {
                    "id": 4,
                    "instruction": "Define a 'dfs' helper to perform the traversal.",
                    "placeholderCode": "        def dfs(node):",
                    "validationRegex": "^\\s+def\\s+dfs\\(node\\):$",
                    "hint": "Nested function to recursive through the tree branches.",
                    "solutionCode": "        def dfs(node):"
                },
                {
                    "id": 5,
                    "instruction": "Check for null nodes (the base case).",
                    "placeholderCode": "            if not node:",
                    "validationRegex": "^\\s+if\\s+not\\s+node:$",
                    "hint": "Empty nodes are part of the serialized data to maintain structure.",
                    "solutionCode": "            if not node:"
                },
                {
                    "id": 6,
                    "instruction": "Append 'N' to 'res' for null nodes and return.",
                    "placeholderCode": "                res.append(\"N\")\n                return",
                    "validationRegex": "^\\s+res\\.append\\(\"N\"\\)\\s*return$",
                    "hint": "Returning here stops the current recursive branch.",
                    "solutionCode": "                res.append(\"N\")\n                return"
                },
                {
                    "id": 7,
                    "instruction": "Append the current node's value (as a string) to the result list.",
                    "placeholderCode": "            res.append(str(node.val))",
                    "validationRegex": "^\\s+res\\.append\\(str\\(node\\.val\\)\\)$",
                    "hint": "Record the current root value first (Preorder).",
                    "solutionCode": "            res.append(str(node.val))"
                },
                {
                    "id": 8,
                    "instruction": "Recursively visit the left child.",
                    "placeholderCode": "            dfs(node.left)",
                    "validationRegex": "^\\s+dfs\\(node\\.left\\)$",
                    "hint": "Standard preorder: visit root then left child.",
                    "solutionCode": "            dfs(node.left)"
                },
                {
                    "id": 9,
                    "instruction": "Recursively visit the right child.",
                    "placeholderCode": "            dfs(node.right)",
                    "validationRegex": "^\\s+dfs\\(node\\.right\\)$",
                    "hint": "Standard preorder: finally visit the right child.",
                    "solutionCode": "            dfs(node.right)"
                },
                {
                    "id": 10,
                    "instruction": "Launch the DFS process starting from the provided root.",
                    "placeholderCode": "        dfs(root)",
                    "validationRegex": "^\\s+dfs\\(root\\)$",
                    "hint": "Trigger the helper function execution.",
                    "solutionCode": "        dfs(root)"
                },
                {
                    "id": 11,
                    "instruction": "Return the serialized string by joining 'res' with commas.",
                    "placeholderCode": "        return \",\".join(res)",
                    "validationRegex": "^\\s+return\\s+\",\"\\.join\\(res\\)$",
                    "hint": "Join the collected values into the final format.",
                    "solutionCode": "        return \",\".join(res)"
                },
                {
                    "id": 12,
                    "instruction": "Define the 'deserialize' method using the result string.",
                    "placeholderCode": "    def deserialize(self, data):",
                    "validationRegex": "^\\s+def\\s+deserialize\\(self,\\s*data\\):$",
                    "hint": "Transform the string back into a tree object.",
                    "solutionCode": "    def deserialize(self, data):"
                },
                {
                    "id": 13,
                    "instruction": "Convert the input string into a list of node labels.",
                    "placeholderCode": "        vals = data.split(\",\")",
                    "validationRegex": "^\\s+vals\\s*=\\s*data\\.split\\(\",\"\\)$",
                    "hint": "Split by the delimiter used during serialization.",
                    "solutionCode": "        vals = data.split(\",\")"
                },
                {
                    "id": 14,
                    "instruction": "Set an index 'self.i' to keep track of our progress in the list.",
                    "placeholderCode": "        self.i = 0",
                    "validationRegex": "^\\s+self\\.i\\s*=\\s*0$",
                    "hint": "Keeping 'i' at the class level ensures all recursive calls share the same pointer.",
                    "solutionCode": "        self.i = 0"
                },
                {
                    "id": 15,
                    "instruction": "Define a helper function 'dfs' to rebuild the nodes.",
                    "placeholderCode": "        def dfs():",
                    "validationRegex": "^\\s+def\\s+dfs\\(\\):$",
                    "hint": "This helper will be called recursively for each part of the tree.",
                    "solutionCode": "        def dfs():"
                },
                {
                    "id": 16,
                    "instruction": "Check if the current label represents a null node.",
                    "placeholderCode": "            if vals[self.i] == \"N\":",
                    "validationRegex": "^\\s+if\\s+vals\\[self\\.i\\]\\s*==\\s*\"N\":$",
                    "hint": "Check the value at the current index.",
                    "solutionCode": "            if vals[self.i] == \"N\":"
                },
                {
                    "id": 17,
                    "instruction": "Increment index and return None if a null node is found.",
                    "placeholderCode": "                self.i += 1\n                return None",
                    "validationRegex": "^\\s+self\\.i\\s*\\+=\\s*1\\s*return\\s*None$",
                    "hint": "Advance the pointer and exit the current branch.",
                    "solutionCode": "                self.i += 1\n                return None"
                },
                {
                    "id": 18,
                    "instruction": "Initialize a new TreeNode with the integer value from 'vals'.",
                    "placeholderCode": "            node = TreeNode(int(vals[self.i]))",
                    "validationRegex": "^\\s+node\\s*=\\s*TreeNode\\(int\\(vals\\[self\\.i\\]\\)\\)$",
                    "hint": "Construct the current root node of the sub-tree.",
                    "solutionCode": "            node = TreeNode(int(vals[self.i]))"
                },
                {
                    "id": 19,
                    "instruction": "Advance the index after processing the node's value.",
                    "placeholderCode": "            self.i += 1",
                    "validationRegex": "^\\s+self\\.i\\s*\\+=\\s*1$",
                    "hint": "Move the pointer to prepare for child construction.",
                    "solutionCode": "            self.i += 1"
                },
                {
                    "id": 20,
                    "instruction": "Recursively reconstruct the left subtree.",
                    "placeholderCode": "            node.left = dfs()",
                    "validationRegex": "^\\s+node\\.left\\s*=\\s*dfs\\(\\)$",
                    "hint": "Follow preorder rule: Root, then Left.",
                    "solutionCode": "            node.left = dfs()"
                },
                {
                    "id": 21,
                    "instruction": "Recursively reconstruct the right subtree.",
                    "placeholderCode": "            node.right = dfs()",
                    "validationRegex": "^\\s+node\\.right\\s*=\\s*dfs\\(\\)$",
                    "hint": "After the left branch is finished, rebuild the right branch.",
                    "solutionCode": "            node.right = dfs()"
                },
                {
                    "id": 22,
                    "instruction": "Return the current node up to its parent.",
                    "placeholderCode": "            return node",
                    "validationRegex": "^\\s+return\\s+node$",
                    "hint": "The node is now fully connected with its descendants.",
                    "solutionCode": "            return node"
                },
                {
                    "id": 23,
                    "instruction": "Begin the deserialization process and return the resulting root.",
                    "placeholderCode": "        return dfs()",
                    "validationRegex": "^\\s+return\\s+dfs\\(\\)$",
                    "hint": "This final call starts the cascade and returns the complete tree.",
                    "solutionCode": "        return dfs()"
                }
            ]
        }
    }
}