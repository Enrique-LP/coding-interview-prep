{
    "id": "word-break",
    "title": "Word Break",
    "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
    "examples": [
        {
            "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
            "output": "true",
            "explanation": "Return true because \"leetcode\" can be segmented as \"leet code\"."
        },
        {
            "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
            "output": "true",
            "explanation": "Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word."
        }
    ],
    "constraints": [
        "1 <= s.length <= 300",
        "1 <= wordDict.length <= 1000",
        "1 <= wordDict[i].length <= 20",
        "s and wordDict[i] consist of only lowercase English letters.",
        "All the strings of wordDict are unique."
    ],
    "difficulty": "Medium",
    "topic": "1-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively check if prefix is in dictionary using memoization.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function word_break that takes s and wordDict.",
                    "placeholderCode": "def word_break(s, wordDict):",
                    "validationRegex": "^def\\s+word_break\\(s,\\s*wordDict\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def word_break(s, wordDict):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(i):\n        if i == len(s): return True\n        if i in memo: return memo[i]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i\\):\\s*if\\s+i\\s*==\\s*len\\(s\\):\\s*return\\s+True\\s*if\\s+i\\s+in\\s+memo:\\s*return\\s+memo\\[i\\]$",
                    "hint": "Recursive function `dfs(i)` checks if suffix starting at `i` can be segmented. Base case: i reached end -> True. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(i):\n        if i == len(s): return True\n        if i in memo: return memo[i]"
                },
                {
                    "id": 3,
                    "instruction": "Check all words in dict.",
                    "placeholderCode": "        for w in wordDict:\n            if (i + len(w) <= len(s) and\n                s[i : i + len(w)] == w):\n                if dfs(i + len(w)):\n                    memo[i] = True\n                    return True",
                    "validationRegex": "^\\s+for\\s+w\\s+in\\s+wordDict:\\s*if\\s*\\(i\\s*\\+\\s*len\\(w\\)\\s*<=\\s*len\\(s\\)\\s+and\\s+s\\[i\\s*:\\s*i\\s*\\+\\s*len\\(w\\)\\]\\s*==\\s*w\\):\\s*if\\s+dfs\\(i\\s*\\+\\s*len\\(w\\)\\):\\s*memo\\[i\\]\\s*=\\s*True\\s*return\\s+True$",
                    "hint": "Try every word in dictionary. If it matches current prefix, recurse on the rest of the string.",
                    "solutionCode": "        for w in wordDict:\n            if (i + len(w) <= len(s) and\n                s[i : i + len(w)] == w):\n                if dfs(i + len(w)):\n                    memo[i] = True\n                    return True"
                },
                {
                    "id": 4,
                    "instruction": "Memoize False and return.",
                    "placeholderCode": "        memo[i] = False\n        return False",
                    "validationRegex": "^\\s+memo\\[i\\]\\s*=\\s*False\\s*return\\s+False$",
                    "hint": "If no word matches, store False in memo and return.",
                    "solutionCode": "        memo[i] = False\n        return False"
                },
                {
                    "id": 5,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0\\)$",
                    "hint": "Start recursion from index 0.",
                    "solutionCode": "    return dfs(0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iterative approach checking if suffixes can be segmented in O(n * m) time.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function word_break that takes s and wordDict.",
                    "placeholderCode": "def word_break(s, wordDict):",
                    "validationRegex": "^def\\s+word_break\\(s,\\s*wordDict\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def word_break(s, wordDict):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP table 'dp' with False values for all possible indices in string 's'.",
                    "placeholderCode": "    dp = [False] * (len(s) + 1)",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[False\\]\\s*\\*\\s*\\(len\\(s\\)\\s*\\+\\s*1\\)$",
                    "hint": "The table represents if the substring starting at index 'i' can be segmented into valid words.",
                    "solutionCode": "    dp = [False] * (len(s) + 1)"
                },
                {
                    "id": 3,
                    "instruction": "Set the base case: an empty string (at the end of 's') can always be segmented.",
                    "placeholderCode": "    dp[len(s)] = True",
                    "validationRegex": "^\\s+dp\\[len\\(s\\)\\]\\s*=\\s*True$",
                    "hint": "Starting from the end helps us build solutions for prefixes back to index 0.",
                    "solutionCode": "    dp[len(s)] = True"
                },
                {
                    "id": 4,
                    "instruction": "Initiate a loop to iterate through the string 's' backwards.",
                    "placeholderCode": "    for i in range(len(s) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "Starting from the end helps build solutions for the suffixes.",
                    "solutionCode": "    for i in range(len(s) - 1, -1, -1):"
                },
                {
                    "id": 5,
                    "instruction": "For each position 'i', iterate through every word in the dictionary.",
                    "placeholderCode": "        for w in wordDict:",
                    "validationRegex": "^\\s+for\\s+w\\s+in\\s+wordDict:$",
                    "hint": "We check if any word from the dictionary can start at the current index.",
                    "solutionCode": "        for w in wordDict:"
                },
                {
                    "id": 6,
                    "instruction": "Check if the current word 'w' fits within the boundaries of the remaining string.",
                    "placeholderCode": "            if (i + len(w) <= len(s)):",
                    "validationRegex": "^\\s+if\\s*\\(i\\s*\\+\\s*len\\(w\\)\\s*<=\\s*len\\(s\\)\\):$",
                    "hint": "We can only check for a match if the word is not longer than the available suffix.",
                    "solutionCode": "            if (i + len(w) <= len(s)):"
                },
                {
                    "id": 7,
                    "instruction": "Verify if the substring starting at index 'i' with the same length as 'w' matches 'w'.",
                    "placeholderCode": "                if s[i : i + len(w)] == w:",
                    "validationRegex": "^\\s+if\\s+s\\[i\\s*:\\s*i\\s*\\+\\s*len\\(w\\)\\]\\s*==\\s*w:$",
                    "hint": "Perform a string slice comparison to find a match.",
                    "solutionCode": "                if s[i : i + len(w)] == w:"
                },
                {
                    "id": 8,
                    "instruction": "Assign the segmentation status of the remaining suffix to the current index 'dp[i]'.",
                    "placeholderCode": "                    dp[i] = dp[i + len(w)]",
                    "validationRegex": "^\\s+dp\\[i\\]\\s*=\\s*dp\\[i\\s*\\+\\s*len\\(w\\)\\]$",
                    "hint": "If the string after word 'w' can be segmented (which we already calculated), then the string from 'i' can also be segmented.",
                    "solutionCode": "                    dp[i] = dp[i + len(w)]"
                },
                {
                    "id": 9,
                    "instruction": "If a valid segmentation is found for the current index, check the condition to stop further word checks.",
                    "placeholderCode": "                    if dp[i]:",
                    "validationRegex": "^\\s+if\\s+dp\\[i\\]:$",
                    "hint": "Only one valid decomposition starting at 'i' is needed.",
                    "solutionCode": "                    if dp[i]:"
                },
                {
                    "id": 10,
                    "instruction": "Break the inner loop since a valid segmentation for 'dp[i]' has been confirmed.",
                    "placeholderCode": "                        break",
                    "validationRegex": "^\\s+break$",
                    "hint": "Terminate the dictionary search for this index to save time.",
                    "solutionCode": "                        break"
                },
                {
                    "id": 11,
                    "instruction": "Return whether the entire string 's' can be segmented into words from the dictionary.",
                    "placeholderCode": "    return dp[0]",
                    "validationRegex": "^\\s+return\\s+dp\\[0\\]$",
                    "hint": "Wait for the entire DP table to be populated and return the result starting from index 0.",
                    "solutionCode": "    return dp[0]"
                }
            ]
        }
    }
}