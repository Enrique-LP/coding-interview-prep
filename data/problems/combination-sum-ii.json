{
    "id": "combination-sum-ii",
    "title": "Combination Sum II",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations.",
    "examples": [
        {
            "input": "candidates = [10,1,2,7,6,1,5], target = 8",
            "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]"
        },
        {
            "input": "candidates = [2,5,2,1,2], target = 5",
            "output": "[[1,2,2],[5]]"
        }
    ],
    "constraints": [
        "1 <= candidates.length <= 100",
        "1 <= candidates[i] <= 50",
        "1 <= target <= 30"
    ],
    "difficulty": "Medium",
    "topic": "Backtracking",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Backtracking",
            "description": "Sort and backtrack, skipping duplicates.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function combination_sum2 that takes candidates and target.",
                    "placeholderCode": "def combination_sum2(candidates, target):",
                    "validationRegex": "^def\\s+combination_sum2\\(candidates,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def combination_sum2(candidates, target):"
                },
                {
                    "id": 2,
                    "instruction": "Sort candidates.",
                    "placeholderCode": "    candidates.sort()",
                    "validationRegex": "^\\s+candidates\\.sort\\(\\)$",
                    "hint": "Sort the candidates to handle duplicates and optimize.",
                    "solutionCode": "    candidates.sort()"
                },
                {
                    "id": 3,
                    "instruction": "Define backtrack.",
                    "placeholderCode": "    res = []\n    def backtrack(cur, pos, target):\n        if target == 0:\n            res.append(cur.copy())\n            return\n        if target <= 0:\n            return\n        prev = -1\n        for i in range(pos, len(candidates)):\n            if candidates[i] == prev:\n                continue\n            cur.append(candidates[i])\n            backtrack(cur, i + 1, target - candidates[i])\n            cur.pop()\n            prev = candidates[i]",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*def\\s+backtrack\\(cur,\\s*pos,\\s*target\\):\\s*if\\s+target\\s*==\\s*0:\\s*res\\.append\\(cur\\.copy\\(\\)\\)\\s*return\\s*if\\s+target\\s*<=\\s*0:\\s*return\\s*prev\\s*=\\s*-1\\s*for\\s+i\\s+in\\s+range\\(pos,\\s*len\\(candidates\\)\\):\\s*if\\s+candidates\\[i\\]\\s*==\\s*prev:\\s*continue\\s*cur\\.append\\(candidates\\[i\\]\\)\\s*backtrack\\(cur,\\s*i\\s*\\+\\s*1,\\s*target\\s*-\\s*candidates\\[i\\]\\)\\s*cur\\.pop\\(\\)\\s*prev\\s*=\\s*candidates\\[i\\]$",
                    "hint": "Implement backtracking. Iterate through candidates, skip duplicates, and recurse with updated target.\\n\\nExample:\\nCands=[1, 1, 2], Target=3.\\nUse first 1. Rem=2. Recurse.\\nUse second 1. Rem=1. Recurse.\\nBacktrack. Skip second 1 (duplicate) in loop.",
                    "solutionCode": "    res = []\n    def backtrack(cur, pos, target):\n        if target == 0:\n            res.append(cur.copy())\n            return\n        if target <= 0:\n            return\n        prev = -1\n        for i in range(pos, len(candidates)):\n            if candidates[i] == prev:\n                continue\n            cur.append(candidates[i])\n            backtrack(cur, i + 1, target - candidates[i])\n            cur.pop()\n            prev = candidates[i]"
                },
                {
                    "id": 4,
                    "instruction": "Call backtrack.",
                    "placeholderCode": "    backtrack([], 0, target)\n    return res",
                    "validationRegex": "^\\s+backtrack\\(\\[\\],\\s*0,\\s*target\\)\\s*return\\s+res$",
                    "hint": "Start backtracking from the beginning.",
                    "solutionCode": "    backtrack([], 0, target)\n    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Backtracking",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function combination_sum2 that takes candidates and target.",
                    "placeholderCode": "def combination_sum2(candidates, target):",
                    "validationRegex": "^def\\s+combination_sum2\\(candidates,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def combination_sum2(candidates, target):"
                },
                {
                    "id": 2,
                    "instruction": "Sort candidates.",
                    "placeholderCode": "    candidates.sort()",
                    "validationRegex": "^\\s+candidates\\.sort\\(\\)$",
                    "hint": "Sort the candidates to handle duplicates and optimize.",
                    "solutionCode": "    candidates.sort()"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the list 'res' to store all unique combinations.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "This will hold our final answer.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 4,
                    "instruction": "Define the helper function 'backtrack'.",
                    "placeholderCode": "    def backtrack(cur, pos, target):",
                    "validationRegex": "^\\s+def\\s+backtrack\\(cur,\\s*pos,\\s*target\\):$",
                    "hint": "The function uses current combination 'cur', start position 'pos', and remaining 'target'.",
                    "solutionCode": "    def backtrack(cur, pos, target):"
                },
                {
                    "id": 5,
                    "instruction": "Check if target is met.",
                    "placeholderCode": "        if target == 0:",
                    "validationRegex": "^\\s+if\\s+target\\s*==\\s*0:$",
                    "hint": "If target is 0, we found a valid combination.",
                    "solutionCode": "        if target == 0:"
                },
                {
                    "id": 6,
                    "instruction": "Add a copy of 'cur' to 'res'.",
                    "placeholderCode": "            res.append(cur.copy())",
                    "validationRegex": "^\\s+res\\.append\\(cur\\.copy\\(\\)\\)$",
                    "hint": "Make sure to append a copy, otherwise it will change when we backtrack.",
                    "solutionCode": "            res.append(cur.copy())"
                },
                {
                    "id": 7,
                    "instruction": "Return from the successful branch.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "Stop searching this branch once target is reached.",
                    "solutionCode": "            return"
                },
                {
                    "id": 8,
                    "instruction": "Handle base case for exceeded target.",
                    "placeholderCode": "        if target <= 0:",
                    "validationRegex": "^\\s+if\\s+target\\s*<=\\s*0:$",
                    "hint": "Stop if target is less than zero.",
                    "solutionCode": "        if target <= 0:"
                },
                {
                    "id": 9,
                    "instruction": "Return from the invalid branch.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "No need to look further if the sum is too large.",
                    "solutionCode": "            return"
                },
                {
                    "id": 10,
                    "instruction": "Initialize 'prev' to track the last used candidate at this level.",
                    "placeholderCode": "        prev = -1",
                    "validationRegex": "^\\s+prev\\s*=\\s*-1$",
                    "hint": "This helps us avoid picking the same value multiple times at the same level.",
                    "solutionCode": "        prev = -1"
                },
                {
                    "id": 11,
                    "instruction": "Loop through candidates starting from 'pos'.",
                    "placeholderCode": "        for i in range(pos, len(candidates)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(pos,\\s*len\\(candidates\\)\\):$",
                    "hint": "Standard DFS loop for combinations.",
                    "solutionCode": "        for i in range(pos, len(candidates)):"
                },
                {
                    "id": 12,
                    "instruction": "Skip duplicates in the same level.",
                    "placeholderCode": "            if candidates[i] == prev:",
                    "validationRegex": "^\\s+if\\s+candidates\\[i\\]\\s*==\\s*prev:$",
                    "hint": "If this candidate is the same as the previous one at this depth, skip it.",
                    "solutionCode": "            if candidates[i] == prev:"
                },
                {
                    "id": 13,
                    "instruction": "Continue to the next iteration if it's a duplicate.",
                    "placeholderCode": "                continue",
                    "validationRegex": "^\\s+continue$",
                    "hint": "Use 'continue' to skip.",
                    "solutionCode": "                continue"
                },
                {
                    "id": 14,
                    "instruction": "Pre-decision: Add choice to 'cur'.",
                    "placeholderCode": "            cur.append(candidates[i])",
                    "validationRegex": "^\\s+cur\\.append\\(candidates\\[i\\]\\)$",
                    "hint": "Include the candidate in the current potential combination.",
                    "solutionCode": "            cur.append(candidates[i])"
                },
                {
                    "id": 15,
                    "instruction": "Recurse: Call backtrack with next index and reduced target.",
                    "placeholderCode": "            backtrack(cur, i + 1, target - candidates[i])",
                    "validationRegex": "^\\s+backtrack\\(cur,\\s*i\\s*\\+\\s*1,\\s*target\\s*-\\s*candidates\\[i\\]\\)$",
                    "hint": "Move to the next index because we can only use each item once.",
                    "solutionCode": "            backtrack(cur, i + 1, target - candidates[i])"
                },
                {
                    "id": 16,
                    "instruction": "Post-decision: Remove choice from 'cur' (backtrack).",
                    "placeholderCode": "            cur.pop()",
                    "validationRegex": "^\\s+cur\\.pop\\(\\)$",
                    "hint": "Clean up 'cur' for the next branch.",
                    "solutionCode": "            cur.pop()"
                },
                {
                    "id": 17,
                    "instruction": "Update 'prev' with the current candidate.",
                    "placeholderCode": "            prev = candidates[i]",
                    "validationRegex": "^\\s+prev\\s*=\\s*candidates\\[i\\]$",
                    "hint": "Mark this value as processed for this level.",
                    "solutionCode": "            prev = candidates[i]"
                },
                {
                    "id": 18,
                    "instruction": "Trigger the initial call and return results.",
                    "placeholderCode": "    backtrack([], 0, target)\n    return res",
                    "validationRegex": "^\\s+backtrack\\(\\[\\],\\s*0,\\s*target\\)\\s*return\\s+res$",
                    "hint": "Start with an empty combination.",
                    "solutionCode": "    backtrack([], 0, target)\n    return res"
                }
            ]
        }
    }
}