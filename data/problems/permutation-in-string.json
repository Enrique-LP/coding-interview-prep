{
    "id": "permutation-in-string",
    "title": "Permutation in String",
    "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1's permutations is the substring of s2.",
    "examples": [
        {
            "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
            "output": "true",
            "explanation": "s2 contains one permutation of s1 (\"ba\")."
        },
        {
            "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
            "output": "false"
        }
    ],
    "constraints": [
        "1 <= s1.length, s2.length <= 10^4",
        "s1 and s2 consist of lowercase English letters."
    ],
    "difficulty": "Medium",
    "topic": "Sliding Window",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Sorting",
            "description": "Sort s1 and every substring of s2.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function check_inclusion that takes s1 and s2.",
                    "placeholderCode": "def check_inclusion(s1, s2):",
                    "validationRegex": "^def\\s+check_inclusion\\(s1,\\s*s2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def check_inclusion(s1, s2):"
                },
                {
                    "id": 2,
                    "instruction": "Sort s1.",
                    "placeholderCode": "    s1 = sorted(s1)",
                    "validationRegex": "^\\s+s1\\s*=\\s*sorted\\(s1\\)$",
                    "hint": "Sort `s1` to compare with sorted substrings.",
                    "solutionCode": "    s1 = sorted(s1)"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through s2 substrings.",
                    "placeholderCode": "    for i in range(len(s2) - len(s1) + 1):\n        if sorted(s2[i : i + len(s1)]) == s1:\n            return True",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s2\\)\\s*-\\s*len\\(s1\\)\\s*\\+\\s*1\\):\\s*if\\s+sorted\\(s2\\[i\\s*:\\s*i\\s*\\+\\s*len\\(s1\\)\\]\\)\\s*==\\s*s1:\\s*return\\s+True$",
                    "hint": "Iterate and sort each substring of length `len(s1)`.",
                    "solutionCode": "    for i in range(len(s2) - len(s1) + 1):\n        if sorted(s2[i : i + len(s1)]) == s1:\n            return True"
                },
                {
                    "id": 4,
                    "instruction": "Return False.",
                    "placeholderCode": "    return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "Return `False` if no match found.",
                    "solutionCode": "    return False"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Sliding Window with Array",
            "description": "Use frequency arrays and a match counter for O(n) complexity.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function check_inclusion that takes s1 and s2.",
                    "placeholderCode": "def check_inclusion(s1, s2):",
                    "validationRegex": "^def\\s+check_inclusion\\(s1,\\s*s2\\):$",
                    "hint": "Start by defining the function.",
                    "solutionCode": "def check_inclusion(s1, s2):"
                },
                {
                    "id": 2,
                    "instruction": "Handle the case where s1 is longer than s2.",
                    "placeholderCode": "    if len(s1) > len(s2): return False",
                    "validationRegex": "^\\s+if\\s+len\\(s1\\)\\s*>\\s+len\\(s2\\):\\s*return\\s+False$",
                    "hint": "If `s1` is longer, it's impossible for `s2` to contain a permutation of it.",
                    "solutionCode": "    if len(s1) > len(s2): return False"
                },
                {
                    "id": 3,
                    "instruction": "Initialize frequency arrays for s1 and the current window.",
                    "placeholderCode": "    s1Count, s2Count = [0] * 26, [0] * 26",
                    "validationRegex": "^\\s+s1Count,\\s*s2Count\\s*=\\s*\\[0\\]\\s*\\*\\s*26,\\s*\\[0\\]\\s*\\*\\s*26$",
                    "hint": "Create two lists of size 26 initialized with zeros. One for s1 and one for s2's window.",
                    "solutionCode": "    s1Count, s2Count = [0] * 26, [0] * 26"
                },
                {
                    "id": 4,
                    "instruction": "Loop through s1 to populate initial counts.",
                    "placeholderCode": "    for i in range(len(s1)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s1\\)\\):$",
                    "hint": "We are filling the counts for the first `len(s1)` characters.",
                    "solutionCode": "    for i in range(len(s1)):"
                },
                {
                    "id": 5,
                    "instruction": "Increment the count for the character in s1.",
                    "placeholderCode": "        s1Count[ord(s1[i]) - ord('a')] += 1",
                    "validationRegex": "^\\s+s1Count\\[ord\\(s1\\[i\\]\\)\\s*-\\s*ord\\('a'\\)\\]\\s*\\+=\\s*1$",
                    "hint": "Map the character to its 0-25 index using `ord()` and increment its frequency.",
                    "solutionCode": "        s1Count[ord(s1[i]) - ord('a')] += 1"
                },
                {
                    "id": 6,
                    "instruction": "Increment the count for the character in the s2 window.",
                    "placeholderCode": "        s2Count[ord(s2[i]) - ord('a')] += 1",
                    "validationRegex": "^\\s+s2Count\\[ord\\(s2\\[i\\]\\)\\s*-\\s*ord\\('a'\\)\\]\\s*\\+=\\s*1$",
                    "hint": "Simultaneously, fill the initial window for s2.",
                    "solutionCode": "        s2Count[ord(s2[i]) - ord('a')] += 1"
                },
                {
                    "id": 7,
                    "instruction": "Calculate initial matches.",
                    "placeholderCode": "    matches = 0\n    for i in range(26):\n        if s1Count[i] == s2Count[i]:\n            matches += 1",
                    "validationRegex": "^\\s+matches\\s*=\\s*0\\s*for\\s+i\\s+in\\s+range\\(26\\):\\s*if\\s+s1Count\\[i\\]\\s*==\\s*s2Count\\[i\\]:\\s*matches\\s*\\+=\\s*1$",
                    "hint": "Compare the two arrays. `matches` tracking prevents us from re-scanning 26 letters every time.",
                    "solutionCode": "    matches = 0\n    for i in range(26):\n        if s1Count[i] == s2Count[i]:\n            matches += 1"
                },
                {
                    "id": 8,
                    "instruction": "Slide the window through s2.",
                    "placeholderCode": "    l = 0\n    for r in range(len(s1), len(s2)):",
                    "validationRegex": "^\\s+l\\s*=\\s*0\\s*for\\s+r\\s+in\\s+range\\(len\\(s1\\),\\s*len\\(s2\\)\\):$",
                    "hint": "Use `l` as the left pointer and `r` as the right pointer. Start `r` from `len(s1)`.",
                    "solutionCode": "    l = 0\n    for r in range(len(s1), len(s2)):"
                },
                {
                    "id": 9,
                    "instruction": "Return True if all 26 characters match.",
                    "placeholderCode": "        if matches == 26: return True",
                    "validationRegex": "^\\s+if\\s+matches\\s*==\\s*26:\\s*return\\s+True$",
                    "hint": "If at any point we have 26 matches, we found a permutation!",
                    "solutionCode": "        if matches == 26: return True"
                },
                {
                    "id": 10,
                    "instruction": "Process the character entering from the right.",
                    "placeholderCode": "        index = ord(s2[r]) - ord('a')\n        s2Count[index] += 1\n        if s1Count[index] == s2Count[index]:\n            matches += 1\n        elif s1Count[index] + 1 == s2Count[index]:\n            matches -= 1",
                    "validationRegex": "^\\s+index\\s*=\\s*ord\\(s2\\[r\\]\\)\\s*-\\s*ord\\('a'\\)\\s*s2Count\\[index\\]\\s*\\+=\\s*1\\s*if\\s+s1Count\\[index\\]\\s*==\\s*s2Count\\[index\\]:\\s*matches\\s*\\+=\\s*1\\s*elif\\s+s1Count\\[index\\]\\s*\\+\\s*1\\s*==\\s*s2Count\\[index\\]:\\s*matches\\s*-=\\s*1$",
                    "hint": "Increment count for `s2[r]`. If it now matches `s1Count`, increment `matches`. If it just *stopped* matching, decrement `matches`.",
                    "solutionCode": "        index = ord(s2[r]) - ord('a')\n        s2Count[index] += 1\n        if s1Count[index] == s2Count[index]:\n            matches += 1\n        elif s1Count[index] + 1 == s2Count[index]:\n            matches -= 1"
                },
                {
                    "id": 11,
                    "instruction": "Process the character leaving from the left.",
                    "placeholderCode": "        index = ord(s2[l]) - ord('a')\n        s2Count[index] -= 1\n        if s1Count[index] == s2Count[index]:\n            matches += 1\n        elif s1Count[index] - 1 == s2Count[index]:\n            matches -= 1\n        l += 1",
                    "validationRegex": "^\\s+index\\s*=\\s*ord\\(s2\\[l\\]\\)\\s*-\\s*ord\\('a'\\)\\s*s2Count\\[index\\]\\s*-=\\s*1\\s*if\\s+s1Count\\[index\\]\\s*==\\s*s2Count\\[index\\]:\\s*matches\\s*\\+=\\s*1\\s*elif\\s+s1Count\\[index\\]\\s*-\\s*1\\s*==\\s*s2Count\\[index\\]:\\s*matches\\s*-=\\s*1\\s*l\\s*\\+=\\s*1$",
                    "hint": "Decrement count for `s2[l]`. Same match logic. Then increment `l` (shrink window).",
                    "solutionCode": "        index = ord(s2[l]) - ord('a')\n        s2Count[index] -= 1\n        if s1Count[index] == s2Count[index]:\n            matches += 1\n        elif s1Count[index] - 1 == s2Count[index]:\n            matches -= 1\n        l += 1"
                },
                {
                    "id": 12,
                    "instruction": "Return the final match check.",
                    "placeholderCode": "    return matches == 26",
                    "validationRegex": "^\\s+return\\s+matches\\s*==\\s*26$",
                    "hint": "One final check after the loop ends.",
                    "solutionCode": "    return matches == 26"
                }
            ]
        }
    }
}