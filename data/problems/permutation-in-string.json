{
    "id": "permutation-in-string",
    "title": "Permutation in String",
    "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1's permutations is the substring of s2.",
    "examples": [
        {
            "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
            "output": "true",
            "explanation": "s2 contains one permutation of s1 (\"ba\")."
        },
        {
            "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
            "output": "false"
        }
    ],
    "constraints": [
        "1 <= s1.length, s2.length <= 10^4",
        "s1 and s2 consist of lowercase English letters."
    ],
    "difficulty": "Medium",
    "topic": "Sliding Window",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Sorting",
            "description": "Sort s1 and every substring of s2.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function check_inclusion that takes s1 and s2.",
                    "placeholderCode": "def check_inclusion(s1, s2):",
                    "validationRegex": "^def\\s+check_inclusion\\(s1,\\s*s2\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def check_inclusion(s1, s2):"
                },
                {
                    "id": 2,
                    "instruction": "Sort s1.",
                    "placeholderCode": "    s1 = sorted(s1)",
                    "validationRegex": "^\\s+s1\\s*=\\s*sorted\\(s1\\)$",
                    "hint": "Sort `s1` to compare with sorted substrings.",
                    "solutionCode": "    s1 = sorted(s1)"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through s2 substrings.",
                    "placeholderCode": "    for i in range(len(s2) - len(s1) + 1):\n        if sorted(s2[i : i + len(s1)]) == s1:\n            return True",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s2\\)\\s*-\\s*len\\(s1\\)\\s*\\+\\s*1\\):\\s*if\\s+sorted\\(s2\\[i\\s*:\\s*i\\s*\\+\\s*len\\(s1\\)\\]\\)\\s*==\\s*s1:\\s*return\\s+True$",
                    "hint": "Iterate and sort each substring of length `len(s1)`.",
                    "solutionCode": "    for i in range(len(s2) - len(s1) + 1):\n        if sorted(s2[i : i + len(s1)]) == s1:\n            return True"
                },
                {
                    "id": 4,
                    "instruction": "Return False.",
                    "placeholderCode": "    return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "Return `False` if no match found.",
                    "solutionCode": "    return False"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Sliding Window with Array",
            "description": "Use frequency arrays and a match counter for O(n) complexity.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function check_inclusion that takes s1 and s2.",
                    "placeholderCode": "def check_inclusion(s1, s2):",
                    "validationRegex": "^def\\s+check_inclusion\\(s1,\\s*s2\\):$",
                    "hint": "Start by defining the function.",
                    "solutionCode": "def check_inclusion(s1, s2):"
                },
                {
                    "id": 2,
                    "instruction": "Handle the case where s1 is longer than s2.",
                    "placeholderCode": "    if len(s1) > len(s2): return False",
                    "validationRegex": "^\\s+if\\s+len\\(s1\\)\\s*>\\s+len\\(s2\\):\\s*return\\s+False$",
                    "hint": "If `s1` is longer, it's impossible for `s2` to contain a permutation of it.",
                    "solutionCode": "    if len(s1) > len(s2): return False"
                },
                {
                    "id": 3,
                    "instruction": "Initialize frequency arrays for s1 and the current window.",
                    "placeholderCode": "    s1Count, s2Count = [0] * 26, [0] * 26",
                    "validationRegex": "^\\s+s1Count,\\s*s2Count\\s*=\\s*\\[0\\]\\s*\\*\\s*26,\\s*\\[0\\]\\s*\\*\\s*26$",
                    "hint": "Create two lists of size 26 initialized with zeros. One for s1 and one for s2's window.",
                    "solutionCode": "    s1Count, s2Count = [0] * 26, [0] * 26"
                },
                {
                    "id": 4,
                    "instruction": "Loop through s1 to populate initial counts.",
                    "placeholderCode": "    for i in range(len(s1)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s1\\)\\):$",
                    "hint": "We are filling the counts for the first `len(s1)` characters.",
                    "solutionCode": "    for i in range(len(s1)):"
                },
                {
                    "id": 5,
                    "instruction": "Increment the count for the character in s1.",
                    "placeholderCode": "        s1Count[ord(s1[i]) - ord('a')] += 1",
                    "validationRegex": "^\\s+s1Count\\[ord\\(s1\\[i\\]\\)\\s*-\\s*ord\\('a'\\)\\]\\s*\\+=\\s*1$",
                    "hint": "Use `ord()` to convert a character into its integer ASCII value. Subtracting `ord('a')` from it maps the letters 'a'-'z' to the indices 0-25. \n\nExample: If s1[i] is 'b', then `ord('b') - ord('a')` is `98 - 97 = 1`. This allows us to increment `s1Count[1]` to track the frequency of 'b'.",
                    "solutionCode": "        s1Count[ord(s1[i]) - ord('a')] += 1"
                },
                {
                    "id": 6,
                    "instruction": "Increment the count for the character in the s2 window.",
                    "placeholderCode": "        s2Count[ord(s2[i]) - ord('a')] += 1",
                    "validationRegex": "^\\s+s2Count\\[ord\\(s2\\[i\\]\\)\\s*-\\s*ord\\('a'\\)\\]\\s*\\+=\\s*1$",
                    "hint": "Similarly, map the character from s2 to an index 0-25 using `ord()` and increment its frequency in the current window counter.",
                    "solutionCode": "        s2Count[ord(s2[i]) - ord('a')] += 1"
                },
                {
                    "id": 7,
                    "instruction": "Initialize the match counter.",
                    "placeholderCode": "    matches = 0",
                    "validationRegex": "^\\s+matches\\s*=\\s*0$",
                    "hint": "We start with 0 matches and will check all 26 possible lowercase English letters.",
                    "solutionCode": "    matches = 0"
                },
                {
                    "id": 8,
                    "instruction": "Iterate through the 26 possible characters.",
                    "placeholderCode": "    for i in range(26):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(26\\):$",
                    "hint": "Each index in our frequency arrays represents one letter of the alphabet ('a'-'z').",
                    "solutionCode": "    for i in range(26):"
                },
                {
                    "id": 9,
                    "instruction": "Check if frequencies match for the current character.",
                    "placeholderCode": "        if s1Count[i] == s2Count[i]:",
                    "validationRegex": "^\\s+if\\s+s1Count\\[i\\]\\s*==\\s*s2Count\\[i\\]:$",
                    "hint": "Compare the count of letter `i` in `s1` versus its count in the current `s2` window.",
                    "solutionCode": "        if s1Count[i] == s2Count[i]:"
                },
                {
                    "id": 10,
                    "instruction": "Increment the match count.",
                    "placeholderCode": "            matches += 1",
                    "validationRegex": "^\\s+matches\\s*\\+=\\s*1$",
                    "hint": "If the frequencies are equal (even if both are 0), it counts as a match for that specific letter.",
                    "solutionCode": "            matches += 1"
                },
                {
                    "id": 11,
                    "instruction": "Slide the window through s2.",
                    "placeholderCode": "    l = 0\n    for r in range(len(s1), len(s2)):",
                    "validationRegex": "^\\s+l\\s*=\\s*0\\s*for\\s+r\\s+in\\s+range\\(len\\(s1\\),\\s*len\\(s2\\)\\):$",
                    "hint": "Use `l` as the left pointer and `r` as the right pointer. Start `r` from `len(s1)`.",
                    "solutionCode": "    l = 0\n    for r in range(len(s1), len(s2)):"
                },
                {
                    "id": 12,
                    "instruction": "Return True if all 26 characters match.",
                    "placeholderCode": "        if matches == 26: return True",
                    "validationRegex": "^\\s+if\\s+matches\\s*==\\s*26:\\s*return\\s+True$",
                    "hint": "If at any point we have 26 matches, we found a permutation!",
                    "solutionCode": "        if matches == 26: return True"
                },
                {
                    "id": 13,
                    "instruction": "Calculate the alphabet index of the character entering the window.",
                    "placeholderCode": "        index = ord(s2[r]) - ord('a')",
                    "validationRegex": "^\\s+index\\s*=\\s*ord\\(s2\\[r\\]\\)\\s*-\\s*ord\\('a'\\)$",
                    "hint": "Like before, we convert the character at the right pointer `r` to an index 0-25.",
                    "solutionCode": "        index = ord(s2[r]) - ord('a')"
                },
                {
                    "id": 14,
                    "instruction": "Increment the frequency of the new character in our window.",
                    "placeholderCode": "        s2Count[index] += 1",
                    "validationRegex": "^\\s+s2Count\\[index\\]\\s*\\+=\\s*1$",
                    "hint": "The character at `s2[r]` just entered the window, so we increase its count.",
                    "solutionCode": "        s2Count[index] += 1"
                },
                {
                    "id": 15,
                    "instruction": "Check if this character's frequency now matches the requirement.",
                    "placeholderCode": "        if s1Count[index] == s2Count[index]:",
                    "validationRegex": "^\\s+if\\s+s1Count\\[index\\]\\s*==\\s*s2Count\\[index\\]:$",
                    "hint": "Check if the amount of this specific character in our window exactly matches how many we need from `s1`.",
                    "solutionCode": "        if s1Count[index] == s2Count[index]:"
                },
                {
                    "id": 16,
                    "instruction": "If it matches, increment the global matches count.",
                    "placeholderCode": "            matches += 1",
                    "validationRegex": "^\\s+matches\\s*\\+=\\s*1$",
                    "hint": "We found another letter whose frequency is perfectly satisfied in our window.",
                    "solutionCode": "            matches += 1"
                },
                {
                    "id": 17,
                    "instruction": "Check if this character formerly matched but now exceeds the requirement.",
                    "placeholderCode": "        elif s1Count[index] + 1 == s2Count[index]:",
                    "validationRegex": "^\\s+elif\\s+s1Count\\[index\\]\\s*\\+\\s*1\\s*==\\s*s2Count\\[index\\]:$",
                    "hint": "If the count was already equal before we added this character, it means we now have 'too many'.",
                    "solutionCode": "        elif s1Count[index] + 1 == s2Count[index]:"
                },
                {
                    "id": 18,
                    "instruction": "If it no longer matches, decrement the global matches count.",
                    "placeholderCode": "            matches -= 1",
                    "validationRegex": "^\\s+matches\\s*-=\\s*1$",
                    "hint": "This specific letter's frequency is no longer exactly what we need, so we lose a match.",
                    "solutionCode": "            matches -= 1"
                },
                {
                    "id": 19,
                    "instruction": "Calculate the index of the character leaving the window on the left.",
                    "placeholderCode": "        index = ord(s2[l]) - ord('a')",
                    "validationRegex": "^\\s+index\\s*=\\s*ord\\(s2\\[l\\]\\)\\s*-\\s*ord\\('a'\\)$",
                    "hint": "We look at the character pointed by `l` and convert it to its 0-25 index.",
                    "solutionCode": "        index = ord(s2[l]) - ord('a')"
                },
                {
                    "id": 20,
                    "instruction": "Decrement its frequency as it leaves the window.",
                    "placeholderCode": "        s2Count[index] -= 1",
                    "validationRegex": "^\\s+s2Count\\[index\\]\\s*-=\\s*1$",
                    "hint": "The window is moving right, so the character at `s2[l]` is no longer part of our counts.",
                    "solutionCode": "        s2Count[index] -= 1"
                },
                {
                    "id": 21,
                    "instruction": "Check if decrementing created a new match.",
                    "placeholderCode": "        if s1Count[index] == s2Count[index]:",
                    "validationRegex": "^\\s+if\\s+s1Count\\[index\\]\\s*==\\s*s2Count\\[index\\]:$",
                    "hint": "It's possible we had 'too many' of this character, and removing one made the count exactly right.",
                    "solutionCode": "        if s1Count[index] == s2Count[index]:"
                },
                {
                    "id": 22,
                    "instruction": "If it now matches, increment the global matches count.",
                    "placeholderCode": "            matches += 1",
                    "validationRegex": "^\\s+matches\\s*\\+=\\s*1$",
                    "hint": "Another letter's frequency is now perfectly satisfied.",
                    "solutionCode": "            matches += 1"
                },
                {
                    "id": 23,
                    "instruction": "Check if decrementing broke a previous match.",
                    "placeholderCode": "        elif s1Count[index] - 1 == s2Count[index]:",
                    "validationRegex": "^\\s+elif\\s+s1Count\\[index\\]\\s*-\\s*1\\s*==\\s*s2Count\\[index\\]:$",
                    "hint": "If the counts were equal before we subtracted 1, we now have 'too few'.",
                    "solutionCode": "        elif s1Count[index] - 1 == s2Count[index]:"
                },
                {
                    "id": 24,
                    "instruction": "If the match was broken, decrement the global matches count.",
                    "placeholderCode": "            matches -= 1",
                    "validationRegex": "^\\s+matches\\s*-=\\s*1$",
                    "hint": "We lost the match for this specific letter.",
                    "solutionCode": "            matches -= 1"
                },
                {
                    "id": 25,
                    "instruction": "Shift the left pointer of the window to the right.",
                    "placeholderCode": "        l += 1",
                    "validationRegex": "^\\s+l\\s*\\+=\\s*1$",
                    "hint": "Move `l` forward to complete the sliding action.",
                    "solutionCode": "        l += 1"
                },
                {
                    "id": 26,
                    "instruction": "Return the final match check.",
                    "placeholderCode": "    return matches == 26",
                    "validationRegex": "^\\s+return\\s+matches\\s*==\\s*26$",
                    "hint": "One final check after the loop ends.",
                    "solutionCode": "    return matches == 26"
                }
            ]
        }
    }
}