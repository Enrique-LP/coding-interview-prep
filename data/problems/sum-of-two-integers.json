{
    "id": "sum-of-two-integers",
    "title": "Sum of Two Integers",
    "description": "Given two integers a and b, return the sum of the two integers without using the operators + and -.",
    "examples": [
        {
            "input": "a = 1, b = 2",
            "output": "3"
        },
        {
            "input": "a = 2, b = 3",
            "output": "5"
        }
    ],
    "constraints": [
        "-1000 <= a, b <= 1000"
    ],
    "difficulty": "Medium",
    "topic": "Bit Manipulation",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Use sum function. (Violates constraints)",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function get_sum that takes a and b.",
                    "placeholderCode": "def get_sum(a, b):",
                    "validationRegex": "^def\\s+get_sum\\(a,\\s*b\\):$",
                    "hint": "Use the `def` keyword to define the function.",
                    "solutionCode": "def get_sum(a, b):"
                },
                {
                    "id": 2,
                    "instruction": "Return sum.",
                    "placeholderCode": "    return sum([a, b])",
                    "validationRegex": "^\\s+return\\s+sum\\(\\[a,\\s*b\\]\\)$",
                    "hint": "Use the built-in `sum` function with a list containing `a` and `b`.",
                    "solutionCode": "    return sum([a, b])"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Use XOR for sum and AND for carry.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function get_sum that takes a and b.",
                    "placeholderCode": "def get_sum(a, b):",
                    "validationRegex": "^def\\s+get_sum\\(a,\\s*b\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def get_sum(a, b):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize mask for 32-bit integer overflow.",
                    "placeholderCode": "    mask = 0xffffffff",
                    "validationRegex": "^\\s+mask\\s*=\\s*0xffffffff$",
                    "hint": "Set `mask` to `0xffffffff` to constrain numbers to 32 bits.",
                    "solutionCode": "    mask = 0xffffffff"
                },
                {
                    "id": 3,
                    "instruction": "Loop while carry is non-zero.",
                    "placeholderCode": "    while (b & mask) > 0:",
                    "validationRegex": "^\\s+while\\s*\\(b\\s*&\\s*mask\\)\\s*>\\s*0:$",
                    "hint": "Continue loop as long as `b` (masked) is greater than 0.",
                    "solutionCode": "    while (b & mask) > 0:"
                },
                {
                    "id": 4,
                    "instruction": "Calculate carry.",
                    "placeholderCode": "        carry = (a & b) << 1",
                    "validationRegex": "^\\s+carry\\s*=\\s*\\(a\\s*&\\s*b\\)\\s*<<\\s*1$",
                    "hint": "Carry is generated where both bits are 1 (`a & b`), shifted left.",
                    "solutionCode": "        carry = (a & b) << 1"
                },
                {
                    "id": 5,
                    "instruction": "Calculate sum without carry.",
                    "placeholderCode": "        a = (a ^ b)",
                    "validationRegex": "^\\s+a\\s*=\\s*\\(a\\s*\\^\\s*b\\)$",
                    "hint": "Sum without carry is XOR of `a` and `b`.",
                    "solutionCode": "        a = (a ^ b)"
                },
                {
                    "id": 6,
                    "instruction": "Update carry for next iteration.",
                    "placeholderCode": "        b = carry",
                    "validationRegex": "^\\s+b\\s*=\\s*carry$",
                    "hint": "Assign `carry` to `b`.",
                    "solutionCode": "        b = carry"
                },
                {
                    "id": 7,
                    "instruction": "Handle negative numbers and return.",
                    "placeholderCode": "    return (a & mask) if b > 0 else a",
                    "validationRegex": "^\\s+return\\s*\\(a\\s*&\\s*mask\\)\\s+if\\s+b\\s*>\\s*0\\s+else\\s+a$",
                    "hint": "Return masked `a` if `b` is positive (handling overflow for positive sum), otherwise return `a`.",
                    "solutionCode": "    return (a & mask) if b > 0 else a"
                }
            ]
        }
    }
}