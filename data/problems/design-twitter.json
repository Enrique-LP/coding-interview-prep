{
    "id": "design-twitter",
    "title": "Design Twitter",
    "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed.",
    "examples": [
        {
            "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
            "output": "[null, null, [5], null, null, [6, 5], null, [5]]"
        }
    ],
    "constraints": [
        "1 <= userId, followerId, followeeId <= 500",
        "0 <= tweetId <= 10^4",
        "All the tweets have unique IDs.",
        "At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow."
    ],
    "difficulty": "Medium",
    "topic": "Heap / Priority Queue",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Heap",
            "description": "Merge k sorted lists of tweets using heap.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define Twitter class.",
                    "placeholderCode": "class Twitter:\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = collections.defaultdict(list)\n        self.followMap = collections.defaultdict(set)",
                    "validationRegex": "^class\\s+Twitter:\\s*def\\s+__init__\\(self\\):\\s*self\\.count\\s*=\\s*0\\s*self\\.tweetMap\\s*=\\s*collections\\.defaultdict\\(list\\)\\s*self\\.followMap\\s*=\\s*collections\\.defaultdict\\(set\\)$",
                    "hint": "Initialize data structures to store tweets and follow relationships.",
                    "solutionCode": "class Twitter:\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = collections.defaultdict(list)\n        self.followMap = collections.defaultdict(set)"
                },
                {
                    "id": 2,
                    "instruction": "Implement postTweet.",
                    "placeholderCode": "    def postTweet(self, userId, tweetId):\n        self.tweetMap[userId].append([self.count, tweetId])\n        self.count -= 1",
                    "validationRegex": "^\\s+def\\s+postTweet\\(self,\\s*userId,\\s*tweetId\\):\\s*self\\.tweetMap\\[userId\\]\\.append\\(\\[self\\.count,\\s*tweetId\\]\\)\\s*self\\.count\\s*-=\\s*1$",
                    "hint": "Store the tweet with a timestamp (or decrementing counter) for ordering.",
                    "solutionCode": "    def postTweet(self, userId, tweetId):\n        self.tweetMap[userId].append([self.count, tweetId])\n        self.count -= 1"
                },
                {
                    "id": 3,
                    "instruction": "Implement getNewsFeed.",
                    "placeholderCode": "    def getNewsFeed(self, userId):\n        res = []\n        minHeap = []\n        self.followMap[userId].add(userId)\n        for followeeId in self.followMap[userId]:\n            if followeeId in self.tweetMap:\n                index = len(self.tweetMap[followeeId]) - 1\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        return res",
                    "validationRegex": "^\\s+def\\s+getNewsFeed\\(self,\\s*userId\\):\\s*res\\s*=\\s*\\[\\]\\s*minHeap\\s*=\\s*\\[\\]\\s*self\\.followMap\\[userId\\]\\.add\\(userId\\)\\s*for\\s+followeeId\\s+in\\s+self\\.followMap\\[userId\\]:\\s*if\\s+followeeId\\s+in\\s+self\\.tweetMap:\\s*index\\s*=\\s*len\\(self\\.tweetMap\\[followeeId\\]\\)\\s*-\\s*1\\s*count,\\s*tweetId\\s*=\\s*self\\.tweetMap\\[followeeId\\]\\[index\\]\\s*heapq\\.heappush\\(minHeap,\\s*\\[count,\\s*tweetId,\\s*followeeId,\\s*index\\s*-\\s*1\\]\\)\\s*while\\s+minHeap\\s+and\\s+len\\(res\\)\\s*<\\s*10:\\s*count,\\s*tweetId,\\s*followeeId,\\s*index\\s*=\\s*heapq\\.heappop\\(minHeap\\)\\s*res\\.append\\(tweetId\\)\\s*if\\s+index\\s*>=\\s*0:\\s*count,\\s*tweetId\\s*=\\s*self\\.tweetMap\\[followeeId\\]\\[index\\]\\s*heapq\\.heappush\\(minHeap,\\s*\\[count,\\s*tweetId,\\s*followeeId,\\s*index\\s*-\\s*1\\]\\)\\s*return\\s+res$",
                    "hint": "Use a min-heap to merge the most recent tweets from the user and their followees.\\n\\nExample:\\nUser 1 follows 2. User 1 tweets T1(time 5). User 2 tweets T2(time 10).\\nHeap: [(5, T1), (10, T2)]. Pop max (simulated min-heap of neg time) -> T2, then T1.",
                    "solutionCode": "    def getNewsFeed(self, userId):\n        res = []\n        minHeap = []\n        self.followMap[userId].add(userId)\n        for followeeId in self.followMap[userId]:\n            if followeeId in self.tweetMap:\n                index = len(self.tweetMap[followeeId]) - 1\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        return res"
                },
                {
                    "id": 4,
                    "instruction": "Implement follow/unfollow.",
                    "placeholderCode": "    def follow(self, followerId, followeeId):\n        self.followMap[followerId].add(followeeId)\n    def unfollow(self, followerId, followeeId):\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)",
                    "validationRegex": "^\\s+def\\s+follow\\(self,\\s*followerId,\\s*followeeId\\):\\s*self\\.followMap\\[followerId\\]\\.add\\(followeeId\\)\\s*def\\s+unfollow\\(self,\\s*followerId,\\s*followeeId\\):\\s*if\\s+followeeId\\s+in\\s+self\\.followMap\\[followerId\\]:\\s*self\\.followMap\\[followerId\\]\\.remove\\(followeeId\\)$",
                    "hint": "Update the follow map to add or remove relationships.",
                    "solutionCode": "    def follow(self, followerId, followeeId):\n        self.followMap[followerId].add(followeeId)\n    def unfollow(self, followerId, followeeId):\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Heap",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the Twitter class.",
                    "placeholderCode": "class Twitter:",
                    "validationRegex": "^class\\s+Twitter:\\s*$",
                    "hint": "Use the class keyword to start the definition.",
                    "solutionCode": "class Twitter:"
                },
                {
                    "id": 2,
                    "instruction": "Define the __init__ constructor method.",
                    "placeholderCode": "    def __init__(self):",
                    "validationRegex": "^\\s+def\\s+__init__\\(self\\):\\s*$",
                    "hint": "Initialize the class instance.",
                    "solutionCode": "    def __init__(self):"
                },
                {
                    "id": 3,
                    "instruction": "Initialize a global count to track the chronological order of tweets.",
                    "placeholderCode": "        self.count = 0",
                    "validationRegex": "^\\s+self\\.count\\s*=\\s*0\\s*$",
                    "hint": "We'll decrement this count with each new tweet to use it as a chronological timestamp.",
                    "solutionCode": "        self.count = 0"
                },
                {
                    "id": 4,
                    "instruction": "Initialize a map to store tweets for each user.",
                    "placeholderCode": "        self.tweetMap = collections.defaultdict(list)",
                    "validationRegex": "^\\s+self\\.tweetMap\\s*=\\s*collections\\.defaultdict\\(list\\)$",
                    "hint": "A dictionary mapping user IDs to a list of their tweets.",
                    "solutionCode": "        self.tweetMap = collections.defaultdict(list)"
                },
                {
                    "id": 5,
                    "instruction": "Initialize a map to store follow relationships.",
                    "placeholderCode": "        self.followMap = collections.defaultdict(set)",
                    "validationRegex": "^\\s+self\\.followMap\\s*=\\s*collections\\.defaultdict\\(set\\)$",
                    "hint": "A dictionary mapping user IDs to a set of user IDs they follow.",
                    "solutionCode": "        self.followMap = collections.defaultdict(set)"
                },
                {
                    "id": 6,
                    "instruction": "Define the postTweet method.",
                    "placeholderCode": "    def postTweet(self, userId, tweetId):",
                    "validationRegex": "^\\s+def\\s+postTweet\\(self,\\s*userId,\\s*tweetId\\):$",
                    "hint": "This method will be called whenever a user posts a new tweet.",
                    "solutionCode": "    def postTweet(self, userId, tweetId):"
                },
                {
                    "id": 7,
                    "instruction": "Append the new tweet to the user's list in tweetMap using the current count as a timestamp.",
                    "placeholderCode": "        self.tweetMap[userId].append([self.count, tweetId])",
                    "validationRegex": "^\\s+self\\.tweetMap\\[userId\\]\\.append\\(\\[self\\.count,\\s*tweetId\\]\\)$",
                    "hint": "Store both the chronological count and the tweet ID.",
                    "solutionCode": "        self.tweetMap[userId].append([self.count, tweetId])"
                },
                {
                    "id": 8,
                    "instruction": "Decrement the global count to ensure the next tweet has a 'later' (smaller) timestamp.",
                    "placeholderCode": "        self.count -= 1",
                    "validationRegex": "^\\s+self\\.count\\s*-=\\s*1$",
                    "hint": "Since we use a min-heap later, smaller numbers represent more recent times.",
                    "solutionCode": "        self.count -= 1"
                },
                {
                    "id": 9,
                    "instruction": "Define the getNewsFeed method.",
                    "placeholderCode": "    def getNewsFeed(self, userId):",
                    "validationRegex": "^\\s+def\\s+getNewsFeed\\(self,\\s*userId\\):$",
                    "hint": "Method to retrieve the 10 most recent tweets from the user and followees.",
                    "solutionCode": "    def getNewsFeed(self, userId):"
                },
                {
                    "id": 10,
                    "instruction": "Initialize an empty list for the result.",
                    "placeholderCode": "        res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "This will store the tweet IDs to return.",
                    "solutionCode": "        res = []"
                },
                {
                    "id": 11,
                    "instruction": "Initialize an empty list for the heap.",
                    "placeholderCode": "        minHeap = []",
                    "validationRegex": "^\\s+minHeap\\s*=\\s*\\[\\]$",
                    "hint": "A heap is perfect for merging multiple sorted lists (tweets per user).",
                    "solutionCode": "        minHeap = []"
                },
                {
                    "id": 12,
                    "instruction": "Ensure the user is in their own follow map.",
                    "placeholderCode": "        self.followMap[userId].add(userId)",
                    "validationRegex": "^\\s+self\\.followMap\\[userId\\]\\.add\\(userId\\)$",
                    "hint": "Users should see their own tweets in their news feed.",
                    "solutionCode": "        self.followMap[userId].add(userId)"
                },
                {
                    "id": 13,
                    "instruction": "Iterate over all followee IDs.",
                    "placeholderCode": "        for followeeId in self.followMap[userId]:",
                    "validationRegex": "^\\s+for\\s+followeeId\\s+in\\s+self\\.followMap\\[userId\\]:$",
                    "hint": "Loop through everyone the user follows (including themselves).",
                    "solutionCode": "        for followeeId in self.followMap[userId]:"
                },
                {
                    "id": 14,
                    "instruction": "Check if the followee has posted any tweets.",
                    "placeholderCode": "            if followeeId in self.tweetMap:",
                    "validationRegex": "^\\s+if\\s+followeeId\\s+in\\s+self\\.tweetMap:$",
                    "hint": "Skip followees who haven't tweeted anything yet.",
                    "solutionCode": "            if followeeId in self.tweetMap:"
                },
                {
                    "id": 15,
                    "instruction": "Get the index of the followee's most recent tweet.",
                    "placeholderCode": "                index = len(self.tweetMap[followeeId]) - 1",
                    "validationRegex": "^\\s+index\\s*=\\s*len\\(self\\.tweetMap\\[followeeId\\]\\)\\s*-\\s*1$",
                    "hint": "Tweets are appended, so the last element is the most recent.",
                    "solutionCode": "                index = len(self.tweetMap[followeeId]) - 1"
                },
                {
                    "id": 16,
                    "instruction": "Retrieve the tweet data at that index.",
                    "placeholderCode": "                count, tweetId = self.tweetMap[followeeId][index]",
                    "validationRegex": "^\\s+count,\\s*tweetId\\s*=\\s*self\\.tweetMap\\[followeeId\\]\\[index\\]$",
                    "hint": "Each tweet is a list/tuple of [count, tweetId].",
                    "solutionCode": "                count, tweetId = self.tweetMap[followeeId][index]"
                },
                {
                    "id": 17,
                    "instruction": "Push the tweet onto the heap along with its metadata.",
                    "placeholderCode": "                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])",
                    "validationRegex": "^\\s+heapq\\.heappush\\(minHeap,\\s*\\[count,\\s*tweetId,\\s*followeeId,\\s*index\\s*-\\s*1\\]\\)$",
                    "hint": "Include 'index - 1' so we know where to find the next tweet if this one is popped.",
                    "solutionCode": "                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])"
                },
                {
                    "id": 18,
                    "instruction": "Start a loop to pop the top 10 tweets.",
                    "placeholderCode": "        while minHeap and len(res) < 10:",
                    "validationRegex": "^\\s+while\\s+minHeap\\s+and\\s+len\\(res\\)\\s*<\\s*10:$",
                    "hint": "Keep going until the heap is empty or we have the 10 most recent tweets.",
                    "solutionCode": "        while minHeap and len(res) < 10:"
                },
                {
                    "id": 19,
                    "instruction": "Pop the tweet with the smallest count (most recent).",
                    "placeholderCode": "            count, tweetId, followeeId, index = heapq.heappop(minHeap)",
                    "validationRegex": "^\\s+count,\\s*tweetId,\\s*followeeId,\\s*index\\s*=\\s*heapq\\.heappop\\(minHeap\\)$",
                    "hint": "Since we use negative counts, heappop gives us the most recent tweet.",
                    "solutionCode": "            count, tweetId, followeeId, index = heapq.heappop(minHeap)"
                },
                {
                    "id": 20,
                    "instruction": "Add the tweet ID to the result list.",
                    "placeholderCode": "            res.append(tweetId)",
                    "validationRegex": "^\\s+res\\.append\\(tweetId\\)$",
                    "hint": "We only need the ID for the final output.",
                    "solutionCode": "            res.append(tweetId)"
                },
                {
                    "id": 21,
                    "instruction": "Check if the same followee has more tweets.",
                    "placeholderCode": "            if index >= 0:",
                    "validationRegex": "^\\s+if\\s+index\\s*>=\\s*0:$",
                    "hint": "We saved the 'index - 1' previously; if it's not negative, there are more.",
                    "solutionCode": "            if index >= 0:"
                },
                {
                    "id": 22,
                    "instruction": "Retrieve the next most recent tweet data.",
                    "placeholderCode": "                count, tweetId = self.tweetMap[followeeId][index]",
                    "validationRegex": "^\\s+count,\\s*tweetId\\s*=\\s*self\\.tweetMap\\[followeeId\\]\\[index\\]$",
                    "hint": "Use the updated index to get the previous tweet.",
                    "solutionCode": "                count, tweetId = self.tweetMap[followeeId][index]"
                },
                {
                    "id": 23,
                    "instruction": "Push the next tweet onto the heap.",
                    "placeholderCode": "                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])",
                    "validationRegex": "^\\s+heapq\\.heappush\\(minHeap,\\s*\\[count,\\s*tweetId,\\s*followeeId,\\s*index\\s*-\\s*1\\]\\)$",
                    "hint": "Again, decrement the index for the next potential push.",
                    "solutionCode": "                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])"
                },
                {
                    "id": 24,
                    "instruction": "Return the final result list.",
                    "placeholderCode": "        return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Done! This list contains up to 10 most recent tweet IDs.",
                    "solutionCode": "        return res"
                },
                {
                    "id": 25,
                    "instruction": "Define the follow method signature.",
                    "placeholderCode": "    def follow(self, followerId, followeeId):",
                    "validationRegex": "^\\s+def\\s+follow\\(self,\\s*followerId,\\s*followeeId\\):$",
                    "hint": "Method to establish a one-way follow relationship.",
                    "solutionCode": "    def follow(self, followerId, followeeId):"
                },
                {
                    "id": 26,
                    "instruction": "Add the followeeId to the follower's set in the followMap.",
                    "placeholderCode": "        self.followMap[followerId].add(followeeId)",
                    "validationRegex": "^\\s+self\\.followMap\\[followerId\\]\\.add\\(followeeId\\)$",
                    "hint": "Sets automatically handle duplicates, so we don't need to check if they already follow.",
                    "solutionCode": "        self.followMap[followerId].add(followeeId)"
                },
                {
                    "id": 27,
                    "instruction": "Define the unfollow method signature.",
                    "placeholderCode": "    def unfollow(self, followerId, followeeId):",
                    "validationRegex": "^\\s+def\\s+unfollow\\(self,\\s*followerId,\\s*followeeId\\):$",
                    "hint": "Method to remove a follow relationship.",
                    "solutionCode": "    def unfollow(self, followerId, followeeId):"
                },
                {
                    "id": 28,
                    "instruction": "Check if the followeeId exists in the follower's set to avoid errors during removal.",
                    "placeholderCode": "        if followeeId in self.followMap[followerId]:",
                    "validationRegex": "^\\s+if\\s+followeeId\\s+in\\s+self\\.followMap\\[followerId\\]:$",
                    "hint": "Removing a non-existent element from a set raises a KeyError.",
                    "solutionCode": "        if followeeId in self.followMap[followerId]:"
                },
                {
                    "id": 29,
                    "instruction": "Remove the followeeId from the follower's set.",
                    "placeholderCode": "            self.followMap[followerId].remove(followeeId)",
                    "validationRegex": "^\\s+self\\.followMap\\[followerId\\]\\.remove\\(followeeId\\)$",
                    "hint": "Use the remove method to officially unfollow.",
                    "solutionCode": "            self.followMap[followerId].remove(followeeId)"
                }
            ]
        }
    }
}