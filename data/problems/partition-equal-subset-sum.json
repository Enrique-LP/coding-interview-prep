{
    "id": "partition-equal-subset-sum",
    "title": "Partition Equal Subset Sum",
    "description": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",
    "examples": [
        {
            "input": "nums = [1,5,11,5]",
            "output": "true",
            "explanation": "The array can be partitioned as [1, 5, 5] and [11]."
        },
        {
            "input": "nums = [1,2,3,5]",
            "output": "false",
            "explanation": "The array cannot be partitioned into equal sum subsets."
        }
    ],
    "constraints": [
        "1 <= nums.length <= 200",
        "1 <= nums[i] <= 100"
    ],
    "difficulty": "Medium",
    "topic": "1-D DP",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Try all subsets.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define canPartition.",
                    "placeholderCode": "def canPartition(nums):",
                    "validationRegex": "^def\\s+canPartition\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def canPartition(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Check sum parity.",
                    "placeholderCode": "    if sum(nums) % 2:\n        return False",
                    "validationRegex": "^\\s+if\\s+sum\\(nums\\)\\s*%\\s*2:\\s*return\\s+False$",
                    "hint": "If the total sum is odd, it's impossible to partition into two equal sums.",
                    "solutionCode": "    if sum(nums) % 2:\n        return False"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS.",
                    "placeholderCode": "    target = sum(nums) // 2\n    def dfs(i, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or i >= len(nums):\n            return False\n        return dfs(i + 1, current_sum + nums[i]) or dfs(i + 1, current_sum)",
                    "validationRegex": "^\\s+target\\s*=\\s*sum\\(nums\\)\\s*//\\s*2\\s*def\\s+dfs\\(i,\\s*current_sum\\):\\s*if\\s+current_sum\\s*==\\s*target:\\s*return\\s+True\\s*if\\s+current_sum\\s*>\\s*target\\s+or\\s+i\\s*>=\\s*len\\(nums\\):\\s*return\\s+False\\s*return\\s+dfs\\(i\\s*\\+\\s*1,\\s*current_sum\\s*\\+\\s*nums\\[i\\]\\)\\s+or\\s+dfs\\(i\\s*\\+\\s*1,\\s*current_sum\\)$",
                    "hint": "Recursive function to check if a subset sums to `target`. Try including or excluding current element.\\n\\nExample:\\nNums=[1, 5]. Target=3.\\nDFS(0, 0):\\n  Include 1 -> DFS(1, 1).\\n    Include 5 -> DFS(2, 6) (False).\\n    Exclude 5 -> DFS(2, 1) (False).\\n  Exclude 1 -> DFS(1, 0).\\n    Include 5 -> DFS(2, 5) (False).\\n    Exclude 5 -> DFS(2, 0) (False).",
                    "solutionCode": "    target = sum(nums) // 2\n    def dfs(i, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or i >= len(nums):\n            return False\n        return dfs(i + 1, current_sum + nums[i]) or dfs(i + 1, current_sum)"
                },
                {
                    "id": 4,
                    "instruction": "Call DFS.",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start DFS from index 0 with current sum 0.",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iteratively build reachable sums.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define canPartition.",
                    "placeholderCode": "def canPartition(nums):",
                    "validationRegex": "^def\\s+canPartition\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def canPartition(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Check sum parity.",
                    "placeholderCode": "    if sum(nums) % 2:\n        return False",
                    "validationRegex": "^\\s+if\\s+sum\\(nums\\)\\s*%\\s*2:\\s*return\\s+False$",
                    "hint": "If the total sum is odd, it's impossible to partition into two equal sums.",
                    "solutionCode": "    if sum(nums) % 2:\n        return False"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the DP set.",
                    "placeholderCode": "    dp = set()",
                    "validationRegex": "^\\s+dp\\s*=\\s*set\\(\\)$",
                    "hint": "This set will hold all possible sums reachable by subsets.",
                    "solutionCode": "    dp = set()"
                },
                {
                    "id": 4,
                    "instruction": "Add 0 to the DP set.",
                    "placeholderCode": "    dp.add(0)",
                    "validationRegex": "^\\s+dp\\.add\\(0\\)$",
                    "hint": "A sum of 0 is always reachable with an empty subset.",
                    "solutionCode": "    dp.add(0)"
                },
                {
                    "id": 5,
                    "instruction": "Calculate the target sum.",
                    "placeholderCode": "    target = sum(nums) // 2",
                    "validationRegex": "^\\s+target\\s*=\\s*sum\\(nums\\)\\s*//\\s*2$",
                    "hint": "The target is half of the total sum.",
                    "solutionCode": "    target = sum(nums) // 2"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through the numbers in reverse order.",
                    "placeholderCode": "    for i in range(len(nums) - 1, -1, -1):\n        nextDP = set()\n        for t in dp:\n            if (t + nums[i]) == target:\n                return True\n            nextDP.add(t + nums[i])\n            nextDP.add(t)\n        dp = nextDP",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):\\s*nextDP\\s*=\\s*set\\(\\)\\s*for\\s+t\\s+in\\s+dp:\\s*if\\s*\\(t\\s*\\+\\s*nums\\[i\\]\\)\\s*==\\s*target:\\s*return\\s+True\\s*nextDP\\.add\\(t\\s*\\+\\s*nums\\[i\\]\\)\\s*nextDP\\.add\\(t\\)\\s*dp\\s*=\\s*nextDP$",
                    "hint": "For each number, iterate through the sums in 'dp' and create a new set 'nextDP' with updated sums. If target is reached, return True.",
                    "solutionCode": "    for i in range(len(nums) - 1, -1, -1):\n        nextDP = set()\n        for t in dp:\n            if (t + nums[i]) == target:\n                return True\n            nextDP.add(t + nums[i])\n            nextDP.add(t)\n        dp = nextDP"
                },
                {
                    "id": 7,
                    "instruction": "Return whether the target sum was reached.",
                    "placeholderCode": "    return True if target in dp else False",
                    "validationRegex": "^\\s+return\\s+True\\s+if\\s+target\\s+in\\s+dp\\s+else\\s+False$",
                    "hint": "If target is in the set, a partition exists.",
                    "solutionCode": "    return True if target in dp else False"
                }
            ]
        }
    }
}