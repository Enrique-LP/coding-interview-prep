{
    "id": "partition-equal-subset-sum",
    "title": "Partition Equal Subset Sum",
    "description": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.",
    "examples": [
        {
            "input": "nums = [1,5,11,5]",
            "output": "true",
            "explanation": "The array can be partitioned as [1, 5, 5] and [11]."
        },
        {
            "input": "nums = [1,2,3,5]",
            "output": "false",
            "explanation": "The array cannot be partitioned into equal sum subsets."
        }
    ],
    "constraints": [
        "1 <= nums.length <= 200",
        "1 <= nums[i] <= 100"
    ],
    "difficulty": "Medium",
    "topic": "1-D DP",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Try all subsets.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define canPartition.",
                    "placeholderCode": "def canPartition(nums):",
                    "validationRegex": "^def\\s+canPartition\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def canPartition(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Check sum parity.",
                    "placeholderCode": "    if sum(nums) % 2:\n        return False",
                    "validationRegex": "^\\s+if\\s+sum\\(nums\\)\\s*%\\s*2:\\s*return\\s+False$",
                    "hint": "If the total sum is odd, it's impossible to partition into two equal sums.",
                    "solutionCode": "    if sum(nums) % 2:\n        return False"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS.",
                    "placeholderCode": "    target = sum(nums) // 2\n    def dfs(i, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or i >= len(nums):\n            return False\n        return dfs(i + 1, current_sum + nums[i]) or dfs(i + 1, current_sum)",
                    "validationRegex": "^\\s+target\\s*=\\s*sum\\(nums\\)\\s*//\\s*2\\s*def\\s+dfs\\(i,\\s*current_sum\\):\\s*if\\s+current_sum\\s*==\\s*target:\\s*return\\s+True\\s*if\\s+current_sum\\s*>\\s*target\\s+or\\s+i\\s*>=\\s*len\\(nums\\):\\s*return\\s+False\\s*return\\s+dfs\\(i\\s*\\+\\s*1,\\s*current_sum\\s*\\+\\s*nums\\[i\\]\\)\\s+or\\s+dfs\\(i\\s*\\+\\s*1,\\s*current_sum\\)$",
                    "hint": "Recursive function to check if a subset sums to `target`. Try including or excluding current element.\\n\\nExample:\\nNums=[1, 5]. Target=3.\\nDFS(0, 0):\\n  Include 1 -> DFS(1, 1).\\n    Include 5 -> DFS(2, 6) (False).\\n    Exclude 5 -> DFS(2, 1) (False).\\n  Exclude 1 -> DFS(1, 0).\\n    Include 5 -> DFS(2, 5) (False).\\n    Exclude 5 -> DFS(2, 0) (False).",
                    "solutionCode": "    target = sum(nums) // 2\n    def dfs(i, current_sum):\n        if current_sum == target:\n            return True\n        if current_sum > target or i >= len(nums):\n            return False\n        return dfs(i + 1, current_sum + nums[i]) or dfs(i + 1, current_sum)"
                },
                {
                    "id": 4,
                    "instruction": "Call DFS.",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start DFS from index 0 with current sum 0.",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iteratively build reachable sums.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define canPartition.",
                    "placeholderCode": "def canPartition(nums):",
                    "validationRegex": "^def\\s+canPartition\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def canPartition(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Check sum parity.",
                    "placeholderCode": "    if sum(nums) % 2:\n        return False",
                    "validationRegex": "^\\s+if\\s+sum\\(nums\\)\\s*%\\s*2:\\s*return\\s+False$",
                    "hint": "If the total sum is odd, it's impossible to partition into two equal sums.",
                    "solutionCode": "    if sum(nums) % 2:\n        return False"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the DP set.",
                    "placeholderCode": "    dp = set()",
                    "validationRegex": "^\\s+dp\\s*=\\s*set\\(\\)$",
                    "hint": "This set will hold all possible sums reachable by subsets.",
                    "solutionCode": "    dp = set()"
                },
                {
                    "id": 4,
                    "instruction": "Add 0 to the DP set.",
                    "placeholderCode": "    dp.add(0)",
                    "validationRegex": "^\\s+dp\\.add\\(0\\)$",
                    "hint": "A sum of 0 is always reachable with an empty subset.",
                    "solutionCode": "    dp.add(0)"
                },
                {
                    "id": 5,
                    "instruction": "Calculate the target sum.",
                    "placeholderCode": "    target = sum(nums) // 2",
                    "validationRegex": "^\\s+target\\s*=\\s*sum\\(nums\\)\\s*//\\s*2$",
                    "hint": "The target is half of the total sum.",
                    "solutionCode": "    target = sum(nums) // 2"
                },
                {
                    "id": 6,
                    "instruction": "Start a loop to iterate through the numbers in 'nums' in reverse order.",
                    "placeholderCode": "    for i in range(len(nums) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "Iterating backwards is often a convention in DP to avoid using the same element multiple times if we used a 1D array, though here we use a set.",
                    "solutionCode": "    for i in range(len(nums) - 1, -1, -1):"
                },
                {
                    "id": 7,
                    "instruction": "Initialize a temporary set 'nextDP' for the next generation of sums.",
                    "placeholderCode": "        nextDP = set()",
                    "validationRegex": "^\\s+nextDP\\s*=\\s*set\\(\\)$",
                    "hint": "This set will combine current sums with the new possibilities from the current number.",
                    "solutionCode": "        nextDP = set()"
                },
                {
                    "id": 8,
                    "instruction": "Iterate through each reachable sum already in the 'dp' set.",
                    "placeholderCode": "        for t in dp:",
                    "validationRegex": "^\\s+for\\s+t\\s+in\\s+dp:$",
                    "hint": "Each 't' represents a sum we've successfully formed so far.",
                    "solutionCode": "        for t in dp:"
                },
                {
                    "id": 9,
                    "instruction": "Check if adding the current number to sum 't' equals the target.",
                    "placeholderCode": "            if (t + nums[i]) == target:",
                    "validationRegex": "^\\s+if\\s*\\(t\\s*\\+\\s*nums\\[i\\]\\)\\s*==\\s*target:$",
                    "hint": "If this matches, we've found a valid partition.",
                    "solutionCode": "            if (t + nums[i]) == target:"
                },
                {
                    "id": 10,
                    "instruction": "Return True if the target sum is found.",
                    "placeholderCode": "                return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "An early escape improves performance.",
                    "solutionCode": "                return True"
                },
                {
                    "id": 11,
                    "instruction": "Add the new sum (including current number) to 'nextDP'.",
                    "placeholderCode": "            nextDP.add(t + nums[i])",
                    "validationRegex": "^\\s+nextDP\\.add\\(t\\s*\\+\\s*nums\\[i\\]\\)$",
                    "hint": "This represents choosing to include 'nums[i]' in the subset.",
                    "solutionCode": "            nextDP.add(t + nums[i])"
                },
                {
                    "id": 12,
                    "instruction": "Add the existing sum 't' (without current number) to 'nextDP'.",
                    "placeholderCode": "            nextDP.add(t)",
                    "validationRegex": "^\\s+nextDP\\.add\\(t\\)$",
                    "hint": "This represents choosing to skip 'nums[i]' for this subset.",
                    "solutionCode": "            nextDP.add(t)"
                },
                {
                    "id": 13,
                    "instruction": "Update the main 'dp' set with the new collection of sums.",
                    "placeholderCode": "        dp = nextDP",
                    "validationRegex": "^\\s+dp\\s*=\\s*nextDP$",
                    "hint": "The 'dp' set now contains all possible sums after processing this element.",
                    "solutionCode": "        dp = nextDP"
                },
                {
                    "id": 14,
                    "instruction": "Return whether the target sum was reached.",
                    "placeholderCode": "    return True if target in dp else False",
                    "validationRegex": "^\\s+return\\s+True\\s+if\\s+target\\s+in\\s+dp\\s+else\\s+False$",
                    "hint": "If target is in the set, a partition exists.",
                    "solutionCode": "    return True if target in dp else False"
                }
            ]
        }
    }
}