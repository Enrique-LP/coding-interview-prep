{
    "id": "largest-rectangle-in-histogram",
    "title": "Largest Rectangle in Histogram",
    "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "examples": [
        {
            "input": "heights = [2,1,5,6,2,3]",
            "output": "10",
            "explanation": "The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units."
        },
        {
            "input": "heights = [2,4]",
            "output": "4"
        }
    ],
    "constraints": [
        "1 <= heights.length <= 10^5",
        "0 <= heights[i] <= 10^4"
    ],
    "difficulty": "Hard",
    "topic": "Stack",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Nested Loops",
            "description": "Check every pair of bars.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function largest_rectangle_area that takes heights.",
                    "placeholderCode": "def largest_rectangle_area(heights):",
                    "validationRegex": "^def\\s+largest_rectangle_area\\(heights\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def largest_rectangle_area(heights):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate and calculate area.",
                    "placeholderCode": "    maxArea = 0\n    for i in range(len(heights)):\n        minH = heights[i]\n        for j in range(i, len(heights)):\n            minH = min(minH, heights[j])\n            maxArea = max(maxArea, minH * (j - i + 1))",
                    "validationRegex": "^\\s+maxArea\\s*=\\s*0\\s*for\\s+i\\s+in\\s+range\\(len\\(heights\\)\\):\\s*minH\\s*=\\s*heights\\[i\\]\\s*for\\s+j\\s+in\\s+range\\(i,\\s*len\\(heights\\)\\):\\s*minH\\s*=\\s*min\\(minH,\\s*heights\\[j\\]\\)\\s*maxArea\\s*=\\s*max\\(maxArea,\\s*minH\\s*\\*\\s*\\(j\\s*-\\s*i\\s*\\+\\s*1\\)\\)$",
                    "hint": "Use nested loops. For each pair `i, j`, find min height and calculate area.",
                    "solutionCode": "    maxArea = 0\n    for i in range(len(heights)):\n        minH = heights[i]\n        for j in range(i, len(heights)):\n            minH = min(minH, heights[j])\n            maxArea = max(maxArea, minH * (j - i + 1))"
                },
                {
                    "id": 3,
                    "instruction": "Return maxArea.",
                    "placeholderCode": "    return maxArea",
                    "validationRegex": "^\\s+return\\s+maxArea$",
                    "hint": "Return the maximum area found.",
                    "solutionCode": "    return maxArea"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Monotonic Stack",
            "description": "Use stack to keep track of increasing heights.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function largest_rectangle_area that takes heights.",
                    "placeholderCode": "def largest_rectangle_area(heights):",
                    "validationRegex": "^def\\s+largest_rectangle_area\\(heights\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def largest_rectangle_area(heights):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize stack and maxArea.",
                    "placeholderCode": "    maxArea = 0\n    stack = [] # pair: (index, height)",
                    "validationRegex": "^\\s+maxArea\\s*=\\s*0\\s*stack\\s*=\\s*\\[\\]$",
                    "hint": "Initialize `maxArea` and an empty `stack`.",
                    "solutionCode": "    maxArea = 0\n    stack = [] # pair: (index, height)"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through heights.",
                    "placeholderCode": "    for i, h in enumerate(heights):\n        start = i",
                    "validationRegex": "^\\s+for\\s+i,\\s*h\\s+in\\s+enumerate\\(heights\\):\\s*start\\s*=\\s*i$",
                    "hint": "Iterate using enumerate. Initialize `start` index.",
                    "solutionCode": "    for i, h in enumerate(heights):\n        start = i"
                },
                {
                    "id": 4,
                    "instruction": "Start a loop to check if previous bars are taller than the current one.",
                    "placeholderCode": "        while stack and stack[-1][1] > h:",
                    "validationRegex": "^\\s+while\\s+stack\\s+and\\s+stack\\[-1\\]\\[1\\]\\s*>\\s*h:$",
                    "hint": "While the stack isn't empty AND the last height added is TALLER than our current height `h`...",
                    "solutionCode": "        while stack and stack[-1][1] > h:"
                },
                {
                    "id": 5,
                    "instruction": "Pop the taller bar from the stack.",
                    "placeholderCode": "            index, height = stack.pop()",
                    "validationRegex": "^\\s+index,\\s*height\\s*=\\s*stack\\.pop\\(\\)$",
                    "hint": "This taller bar can't extend any further to the right because `h` is lower. So we 'close' it and get its data.",
                    "solutionCode": "            index, height = stack.pop()"
                },
                {
                    "id": 6,
                    "instruction": "Calculate the area of the rectangle formed by the popped bar.",
                    "placeholderCode": "            maxArea = max(maxArea, height * (i - index))",
                    "validationRegex": "^\\s+maxArea\\s*=\\s*max\\(maxArea,\\s*height\\s*\\*\\s*\\(i\\s*-\\s*index\\)\\)$",
                    "hint": "The width is `current_index (i) - start_index (index)`. We update `maxArea` if this new rectangle is the biggest so far.",
                    "solutionCode": "            maxArea = max(maxArea, height * (i - index))"
                },
                {
                    "id": 7,
                    "instruction": "Update the start index for the current (shorter) bar.",
                    "placeholderCode": "            start = index",
                    "validationRegex": "^\\s+start\\s*=\\s*index$",
                    "hint": "Crucial Trick: Since `h` is shorter, it could have started way back where the taller bar we just popped started. We move `start` back.",
                    "solutionCode": "            start = index"
                },
                {
                    "id": 8,
                    "instruction": "Push the current bar to the stack.",
                    "placeholderCode": "        stack.append((start, h))",
                    "validationRegex": "^\\s+stack\\.append\\(\\s*\\(\\s*start,\\s*h\\s*\\)\\s*\\)$",
                    "hint": "Finally, we push our current height `h` with its potentially 'stretched' `start` index.",
                    "solutionCode": "        stack.append((start, h))"
                },
                {
                    "id": 9,
                    "instruction": "Iterate through the bars remaining in the stack.",
                    "placeholderCode": "    for i, h in stack:",
                    "validationRegex": "^\\s+for\\s+i,\\s*h\\s+in\\s+stack:$",
                    "hint": "Any bars still in the stack weren't 'closed' by a shorter bar, meaning they can extend all the way to the end of the histogram.",
                    "solutionCode": "    for i, h in stack:"
                },
                {
                    "id": 10,
                    "instruction": "Calculate area for the remaining bars using the total width.",
                    "placeholderCode": "        maxArea = max(maxArea, h * (len(heights) - i))",
                    "validationRegex": "^\\s+maxArea\\s*=\\s*max\\(maxArea,\\s*h\\s*\\*\\s*\\(len\\(heights\\)\\s*-\\s*i\\)\\)$",
                    "hint": "The width is `total_length - start_index`. These bars reach the right edge!",
                    "solutionCode": "        maxArea = max(maxArea, h * (len(heights) - i))"
                },
                {
                    "id": 11,
                    "instruction": "Return the maximum area found.",
                    "placeholderCode": "    return maxArea",
                    "validationRegex": "^\\s+return\\s+maxArea$",
                    "hint": "Return our winner: `maxArea`.",
                    "solutionCode": "    return maxArea"
                }
            ]
        }
    }
}