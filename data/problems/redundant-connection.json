{
    "id": "redundant-connection",
    "title": "Redundant Connection",
    "description": "In this problem, a tree is an undirected graph that is connected and has no cycles. You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph. Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.",
    "examples": [
        {
            "input": "edges = [[1,2],[1,3],[2,3]]",
            "output": "[2,3]"
        },
        {
            "input": "edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]",
            "output": "[1,4]"
        }
    ],
    "constraints": [
        "n == edges.length",
        "3 <= n <= 1000",
        "edges[i].length == 2",
        "1 <= ai < bi <= edges.length",
        "ai != bi",
        "There are no repeated edges.",
        "The given graph is connected."
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS",
            "description": "Check if adding an edge creates a cycle using DFS.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define find_redundant_connection.",
                    "placeholderCode": "def find_redundant_connection(edges):",
                    "validationRegex": "^def\\s+find_redundant_connection\\(edges\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_redundant_connection(edges):"
                },
                {
                    "id": 2,
                    "instruction": "Build graph and check cycle.",
                    "placeholderCode": "    graph = collections.defaultdict(set)\n    def dfs(u, v, visited):\n        if u == v: return True\n        visited.add(u)\n        for neighbor in graph[u]:\n            if neighbor not in visited:\n                if dfs(neighbor, v, visited):\n                    return True\n        return False\n    for u, v in edges:\n        if u in graph and v in graph and dfs(u, v, set()):\n            return [u, v]\n        graph[u].add(v)\n        graph[v].add(u)",
                    "validationRegex": "^\\s+graph\\s*=\\s*collections\\.defaultdict\\(set\\)\\s*def\\s+dfs\\(u,\\s*v,\\s*visited\\):\\s*if\\s+u\\s*==\\s*v:\\s*return\\s+True\\s*visited\\.add\\(u\\)\\s*for\\s+neighbor\\s+in\\s+graph\\[u\\]:\\s*if\\s+neighbor\\s+not\\s+in\\s+visited:\\s*if\\s+dfs\\(neighbor,\\s*v,\\s*visited\\):\\s*return\\s+True\\s*return\\s+False\\s*for\\s+u,\\s*v\\s+in\\s+edges:\\s*if\\s+u\\s+in\\s+graph\\s+and\\s+v\\s+in\\s+graph\\s+and\\s+dfs\\(u,\\s*v,\\s*set\\(\\)\\):\\s*return\\s*\\[u,\\s*v\\]\\s*graph\\[u\\]\\.add\\(v\\)\\s*graph\\[v\\]\\.add\\(u\\)$",
                    "hint": "Iterate through edges. For each edge (u, v), check if u and v are already connected using DFS. If so, return [u, v]. Else, add edge to graph.\\n\\nExample:\\nEdges=[[1,2], [1,3], [2,3]].\\nAdd [1,2]. Graph: 1-2.\\nAdd [1,3]. Graph: 1-2, 1-3.\\nCheck [2,3]. DFS(2,3)? Yes (2-1-3). Return [2,3].",
                    "solutionCode": "    graph = collections.defaultdict(set)\n    def dfs(u, v, visited):\n        if u == v: return True\n        visited.add(u)\n        for neighbor in graph[u]:\n            if neighbor not in visited:\n                if dfs(neighbor, v, visited):\n                    return True\n        return False\n    for u, v in edges:\n        if u in graph and v in graph and dfs(u, v, set()):\n            return [u, v]\n        graph[u].add(v)\n        graph[v].add(u)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Union Find",
            "description": "Use Union Find to detect cycle.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define find_redundant_connection.",
                    "placeholderCode": "def find_redundant_connection(edges):",
                    "validationRegex": "^def\\s+find_redundant_connection\\(edges\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_redundant_connection(edges):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize Union Find.",
                    "placeholderCode": "    par = [i for i in range(len(edges) + 1)]\n    rank = [1] * (len(edges) + 1)\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return False\n        if rank[p1] > rank[p2]:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n        else:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        return True",
                    "validationRegex": "^\\s+par\\s*=\\s*\\[i\\s+for\\s+i\\s+in\\s+range\\(len\\(edges\\)\\s*\\+\\s*1\\)\\]\\s*rank\\s*=\\s*\\[1\\]\\s*\\*\\s*\\(len\\(edges\\)\\s*\\+\\s*1\\)\\s*def\\s+find\\(n\\):\\s*p\\s*=\\s*par\\[n\\]\\s*while\\s+p\\s*!=\\s*par\\[p\\]:\\s*par\\[p\\]\\s*=\\s*par\\[par\\[p\\]\\]\\s*p\\s*=\\s*par\\[p\\]\\s*return\\s+p\\s*def\\s+union\\(n1,\\s*n2\\):\\s*p1,\\s*p2\\s*=\\s*find\\(n1\\),\\s*find\\(n2\\)\\s*if\\s+p1\\s*==\\s*p2:\\s*return\\s+False\\s*if\\s+rank\\[p1\\]\\s*>\\s+rank\\[p2\\]:\\s*par\\[p2\\]\\s*=\\s*p1\\s*rank\\[p1\\]\\s*\\+=\\s*rank\\[p2\\]\\s*else:\\s*par\\[p1\\]\\s*=\\s*p2\\s*rank\\[p2\\]\\s*\\+=\\s*rank\\[p1\\]\\s*return\\s+True$",
                    "hint": "Implement Union-Find with path compression and union by rank. `find` returns the representative of a set. `union` merges two sets and returns False if they are already merged (cycle detected).\\n\\nExample:\\nEdges=[[1,2], [1,3], [2,3]].\\nUnion(1,2): OK. Par=[1,1,1].\\nUnion(1,3): OK. Par=[1,1,1]. (3 points to 1)\\nUnion(2,3): Find(2)->1. Find(3)->1. Same parent. Cycle! Return [2,3].",
                    "solutionCode": "    par = [i for i in range(len(edges) + 1)]\n    rank = [1] * (len(edges) + 1)\n    def find(n):\n        p = par[n]\n        while p != par[p]:\n            par[p] = par[par[p]]\n            p = par[p]\n        return p\n    def union(n1, n2):\n        p1, p2 = find(n1), find(n2)\n        if p1 == p2:\n            return False\n        if rank[p1] > rank[p2]:\n            par[p2] = p1\n            rank[p1] += rank[p2]\n        else:\n            par[p1] = p2\n            rank[p2] += rank[p1]\n        return True"
                },
                {
                    "id": 3,
                    "instruction": "Process edges.",
                    "placeholderCode": "    for n1, n2 in edges:\n        if not union(n1, n2):\n            return [n1, n2]",
                    "validationRegex": "^\\s+for\\s+n1,\\s*n2\\s+in\\s+edges:\\s*if\\s+not\\s+union\\(n1,\\s*n2\\):\\s*return\\s*\\[n1,\\s*n2\\]$",
                    "hint": "Iterate through edges. If `union` returns False, it means the edge creates a cycle, so return it.",
                    "solutionCode": "    for n1, n2 in edges:\n        if not union(n1, n2):\n            return [n1, n2]"
                }
            ]
        }
    }
}