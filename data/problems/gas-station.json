{
    "id": "gas-station",
    "title": "Gas Station",
    "description": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique.",
    "examples": [
        {
            "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
            "output": "3",
            "explanation": "Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index."
        },
        {
            "input": "gas = [2,3,4], cost = [3,4,3]",
            "output": "-1",
            "explanation": "You can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start."
        }
    ],
    "constraints": [
        "n == gas.length == cost.length",
        "1 <= n <= 10^5",
        "0 <= gas[i], cost[i] <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "Greedy",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Iteratively simulate starting the journey from each gas station to determine if a full circuit is possible.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function can_complete_circuit that takes gas and cost.",
                    "placeholderCode": "def can_complete_circuit(gas, cost):",
                    "validationRegex": "^def\\s+can_complete_circuit\\(gas,\\s*cost\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def can_complete_circuit(gas, cost):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate through each station index as a potential starting point.",
                    "placeholderCode": "    n = len(gas)\n    for i in range(n):",
                    "validationRegex": "^\\s+n\\s*=\\s*len\\(gas\\)\\s*for\\s+i\\s+in\\s+range\\(n\\):$",
                    "hint": "Try every index `i` as the starting point.",
                    "solutionCode": "    n = len(gas)\n    for i in range(n):"
                },
                {
                    "id": 3,
                    "instruction": "For each starting station, simulate the trip around the circuit, tracking the gas tank and checking if it ever drops below zero.",
                    "placeholderCode": "        tank = 0\n        possible = True\n        for j in range(n):\n            idx = (i + j) % n\n            tank += gas[idx] - cost[idx]\n            if tank < 0:\n                possible = False\n                break",
                    "validationRegex": "^\\s+tank\\s*=\\s*0\\s*possible\\s*=\\s*True\\s*for\\s+j\\s+in\\s+range\\(n\\):\\s*idx\\s*=\\s*\\(i\\s*\\+\\s*j\\)\\s*%\\s*n\\s*tank\\s*\\+=\\s*gas\\[idx\\]\\s*-\\s*cost\\[idx\\]\\s*if\\s+tank\\s*<\\s*0:\\s*possible\\s*=\\s*False\\s*break$",
                    "hint": "Simulate the journey. Add gas, subtract cost. If tank drops below 0, this start is invalid.",
                    "solutionCode": "        tank = 0\n        possible = True\n        for j in range(n):\n            idx = (i + j) % n\n            tank += gas[idx] - cost[idx]\n            if tank < 0:\n                possible = False\n                break"
                },
                {
                    "id": 4,
                    "instruction": "If a full circuit is successfully simulated, return the current starting index.",
                    "placeholderCode": "        if possible: return i",
                    "validationRegex": "^\\s+if\\s+possible:\\s*return\\s+i$",
                    "hint": "If the loop completes without tank < 0, return the start index.",
                    "solutionCode": "        if possible: return i"
                },
                {
                    "id": 5,
                    "instruction": "If no starting point allows for a full circuit, return -1.",
                    "placeholderCode": "    return -1",
                    "validationRegex": "^\\s+return\\s+-1$",
                    "hint": "If no start index works, return -1.",
                    "solutionCode": "    return -1"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Use a greedy approach to find the unique starting station in a single pass O(n), assuming total gas is sufficient for total cost.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function can_complete_circuit that takes gas and cost.",
                    "placeholderCode": "def can_complete_circuit(gas, cost):",
                    "validationRegex": "^def\\s+can_complete_circuit\\(gas,\\s*cost\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def can_complete_circuit(gas, cost):"
                },
                {
                    "id": 2,
                    "instruction": "Check if the total amount of gas is less than the total cost of the trip; if so, returning -1 as a circuit is impossible.",
                    "placeholderCode": "    if sum(gas) < sum(cost): return -1",
                    "validationRegex": "^\\s+if\\s+sum\\(gas\\)\\s*<\\s+sum\\(cost\\):\\s*return\\s+-1$",
                    "hint": "If total gas is less than total cost, it's impossible to complete the circuit.",
                    "solutionCode": "    if sum(gas) < sum(cost): return -1"
                },
                {
                    "id": 3,
                    "instruction": "Initialize 'total' to 0 to keep track of the current gas balance in the tank.",
                    "placeholderCode": "    total = 0",
                    "validationRegex": "^\\s+total\\s*=\\s*0$",
                    "hint": "This will track your net gas as you move between stations.",
                    "solutionCode": "    total = 0"
                },
                {
                    "id": 4,
                    "instruction": "Initialize 'res' to 0 to store the potential starting station index.",
                    "placeholderCode": "    res = 0",
                    "validationRegex": "^\\s+res\\s*=\\s*0$",
                    "hint": "This variable will hold our answer.",
                    "solutionCode": "    res = 0"
                },
                {
                    "id": 5,
                    "instruction": "Initiate a loop to iterate through all gas stations by their index 'i'.",
                    "placeholderCode": "    for i in range(len(gas)):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(gas\\)\\):$",
                    "hint": "We'll check each station one by one.",
                    "solutionCode": "    for i in range(len(gas)):"
                },
                {
                    "id": 6,
                    "instruction": "Update 'total' by adding the gas gained at the current station and subtracting the cost to reach the next station.",
                    "placeholderCode": "        total += (gas[i] - cost[i])",
                    "validationRegex": "^\\s+total\\s*\\+=\\s*\\(gas\\[i\\]\\s*-\\s*cost\\[i\\]\\)$",
                    "hint": "Calculate the net change in gas for this leg of the journey.",
                    "solutionCode": "        total += (gas[i] - cost[i])"
                },
                {
                    "id": 7,
                    "instruction": "If 'total' becomes negative, it means the current starting station (and any station before it) cannot complete the current leg.",
                    "placeholderCode": "        if total < 0:",
                    "validationRegex": "^\\s+if\\s+total\\s*<\\s*0:$",
                    "hint": "Check if we ran out of gas.",
                    "solutionCode": "        if total < 0:"
                },
                {
                    "id": 8,
                    "instruction": "If 'total' is negative, reset it to 0 as we must start our search fresh from the next station.",
                    "placeholderCode": "            total = 0",
                    "validationRegex": "^\\s+total\\s*=\\s*0$",
                    "hint": "The current station cannot be the start, nor can any station within the current failed segment.",
                    "solutionCode": "            total = 0"
                },
                {
                    "id": 9,
                    "instruction": "Update 'res' to the next station index (i + 1) as the new potential starting station.",
                    "placeholderCode": "            res = i + 1",
                    "validationRegex": "^\\s+res\\s*=\\s*i\\s*\\+\\s*1$",
                    "hint": "Our next guess for the start is the station right after the failure.",
                    "solutionCode": "            res = i + 1"
                },
                {
                    "id": 10,
                    "instruction": "Return the final value of 'res' as the starting gas station's index.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Since we already checked if a solution exists, 'res' will be the unique start.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}