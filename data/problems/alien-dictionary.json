{
    "id": "alien-dictionary",
    "title": "Alien Dictionary",
    "description": "There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you. You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language. Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new rules. If there is no solution, return \"\". If there are multiple solutions, return any of them.",
    "examples": [
        {
            "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
            "output": "\"wertf\""
        },
        {
            "input": "words = [\"z\",\"x\"]",
            "output": "\"zx\""
        },
        {
            "input": "words = [\"z\",\"x\",\"z\"]",
            "output": "\"\""
        }
    ],
    "constraints": [
        "1 <= words.length <= 100",
        "1 <= words[i].length <= 100",
        "words[i] consists of only lowercase English letters."
    ],
    "difficulty": "Hard",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Build graph and topological sort.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define alienOrder.",
                    "placeholderCode": "def alienOrder(words):",
                    "validationRegex": "^def\\s+alienOrder\\(words\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def alienOrder(words):"
                },
                {
                    "id": 2,
                    "instruction": "Build adjacency list.",
                    "placeholderCode": "    adj = {c: set() for w in words for c in w}\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n        if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                adj[w1[j]].add(w2[j])\n                break",
                    "validationRegex": "^\\s+adj\\s*=\\s*{c:\\s*set\\(\\)\\s+for\\s+w\\s+in\\s+words\\s+for\\s+c\\s+in\\s+w}\\s*for\\s+i\\s+in\\s+range\\(len\\(words\\)\\s*-\\s*1\\):\\s*w1,\\s*w2\\s*=\\s*words\\[i\\],\\s*words\\[i\\s*\\+\\s*1\\]\\s*minLen\\s*=\\s*min\\(len\\(w1\\),\\s*len\\(w2\\)\\)\\s*if\\s+len\\(w1\\)\\s*>\\s+len\\(w2\\)\\s+and\\s+w1\\[:minLen\\]\\s*==\\s*w2\\[:minLen\\]:\\s*return\\s*\"\"\\s*for\\s+j\\s+in\\s+range\\(minLen\\):\\s*if\\s+w1\\[j\\]\\s*!=\\s*w2\\[j\\]:\\s*adj\\[w1\\[j\\]\\]\\.add\\(w2\\[j\\]\\)\\s*break$",
                    "hint": "Compare adjacent words. The first differing character determines the order. If a word is a prefix of the next word but longer, it's invalid.\\n\\nExample:\\nWords=[\"wrt\", \"wrf\", \"er\"].\\nCompare \"wrt\", \"wrf\": 't' != 'f'. Edge t->f.\\nCompare \"wrf\", \"er\": 'w' != 'e'. Edge w->e.",
                    "solutionCode": "    adj = {c: set() for w in words for c in w}\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        minLen = min(len(w1), len(w2))\n        if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n            return \"\"\n        for j in range(minLen):\n            if w1[j] != w2[j]:\n                adj[w1[j]].add(w2[j])\n                break"
                },
                {
                    "id": 3,
                    "instruction": "DFS for topological sort.",
                    "placeholderCode": "    visit = {}\n    res = []\n    def dfs(c):\n        if c in visit:\n            return visit[c]\n        visit[c] = True\n        for nei in adj[c]:\n            if dfs(nei):\n                return True\n        visit[c] = False\n        res.append(c)\n        return False",
                    "validationRegex": "^\\s+visit\\s*=\\s*{}\\s*res\\s*=\\s*\\[\\]\\s*def\\s+dfs\\(c\\):\\s*if\\s+c\\s+in\\s+visit:\\s*return\\s+visit\\[c\\]\\s*visit\\[c\\]\\s*=\\s*True\\s*for\\s+nei\\s+in\\s+adj\\[c\\]:\\s*if\\s+dfs\\(nei\\):\\s*return\\s+True\\s*visit\\[c\\]\\s*=\\s*False\\s*res\\.append\\(c\\)\\s*return\\s+False$",
                    "hint": "Use DFS to detect cycles and build the topological sort. `visit` stores state: True (visiting/current path), False (visited/fully processed).\\n\\nExample:\\nDFS('w'): Mark 'w' Visiting.\\nDFS('e'): Visiting... Visited. Add 'e' to Res.\\nBack to 'w': Mark 'w' Visited. Add 'w' to Res.\\nResult (reversed later): ['e', 'w'].",
                    "solutionCode": "    visit = {}\n    res = []\n    def dfs(c):\n        if c in visit:\n            return visit[c]\n        visit[c] = True\n        for nei in adj[c]:\n            if dfs(nei):\n                return True\n        visit[c] = False\n        res.append(c)\n        return False"
                },
                {
                    "id": 4,
                    "instruction": "Call DFS.",
                    "placeholderCode": "    for c in adj:\n        if dfs(c):\n            return \"\"\n    res.reverse()\n    return \"\".join(res)",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+adj:\\s*if\\s+dfs\\(c\\):\\s*return\\s*\"\"\\s*res\\.reverse\\(\\)\\s*return\\s*\"\"\\.join\\(res\\)$",
                    "hint": "Run DFS on all nodes. If a cycle is detected, return \"\". Otherwise, reverse the result list to get the correct order.",
                    "solutionCode": "    for c in adj:\n        if dfs(c):\n            return \"\"\n    res.reverse()\n    return \"\".join(res)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define alienOrder.",
                    "placeholderCode": "def alienOrder(words):",
                    "validationRegex": "^def\\s+alienOrder\\(words\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def alienOrder(words):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the adjacency list with an empty set for every unique character in all words.",
                    "placeholderCode": "    adj = {c: set() for w in words for c in w}",
                    "validationRegex": "^\\s+adj\\s*=\\s*{c:\\s*set\\(\\)\\s+for\\s+w\\s+in\\s+words\\s+for\\s+c\\s+in\\s+w}$",
                    "hint": "This ensures every character mentioned in the input is a node in the graph.",
                    "solutionCode": "    adj = {c: set() for w in words for c in w}"
                },
                {
                    "id": 3,
                    "instruction": "Start a loop to iterate through all adjacent pairs of words in the dictionary.",
                    "placeholderCode": "    for i in range(len(words) - 1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(words\\)\\s*-\\s*1\\):$",
                    "hint": "Comparing words[i] and words[i+1] reveals ordering rules.",
                    "solutionCode": "    for i in range(len(words) - 1):"
                },
                {
                    "id": 4,
                    "instruction": "Extract the current word 'w1' and the next word 'w2'.",
                    "placeholderCode": "        w1, w2 = words[i], words[i + 1]",
                    "validationRegex": "^\\s+w1,\\s*w2\\s*=\\s*words\\[i\\],\\s*words\\[i\\s*\\+\\s*1\\]$",
                    "hint": "These are the two strings to compare character by character.",
                    "solutionCode": "        w1, w2 = words[i], words[i + 1]"
                },
                {
                    "id": 5,
                    "instruction": "Find the minimum length between 'w1' and 'w2' to avoid index out of bounds.",
                    "placeholderCode": "        minLen = min(len(w1), len(w2))",
                    "validationRegex": "^\\s+minLen\\s*=\\s*min\\(len\\(w1\\),\\s*len\\(w2\\)\\)$",
                    "hint": "Comparison only happens over the shared prefix/length.",
                    "solutionCode": "        minLen = min(len(w1), len(w2))"
                },
                {
                    "id": 6,
                    "instruction": "Check the prefix condition: if 'w1' is longer than 'w2' and they share the same prefix, the order is invalid.",
                    "placeholderCode": "        if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:",
                    "validationRegex": "^\\s+if\\s+len\\(w1\\)\\s*>\\s+len\\(w2\\)\\s+and\\s+w1\\[:minLen\\]\\s*==\\s*w2\\[:minLen\\]:$",
                    "hint": "A sorted dictionary cannot have 'apple' before 'app'.",
                    "solutionCode": "        if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:"
                },
                {
                    "id": 7,
                    "instruction": "Return an empty string if the prefix condition fails.",
                    "placeholderCode": "            return \"\"",
                    "validationRegex": "^\\s+return\\s*\"\"$",
                    "hint": "This signifies an inconsistent ordering in the input.",
                    "solutionCode": "            return \"\""
                },
                {
                    "id": 8,
                    "instruction": "Start a loop to compare characters of 'w1' and 'w2' up to the minimum length.",
                    "placeholderCode": "        for j in range(minLen):",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(minLen\\):$",
                    "hint": "Scan until a difference is found.",
                    "solutionCode": "        for j in range(minLen):"
                },
                {
                    "id": 9,
                    "instruction": "If the characters at index 'j' are different, it defines an order.",
                    "placeholderCode": "            if w1[j] != w2[j]:",
                    "validationRegex": "^\\s+if\\s+w1\\[j\\]\\s*!=\\s*w2\\[j\\]:$",
                    "hint": "The first differing character tells us that 'w1[j]' comes before 'w2[j]'.",
                    "solutionCode": "            if w1[j] != w2[j]:"
                },
                {
                    "id": 10,
                    "instruction": "Add 'w2[j]' as a neighbor of 'w1[j]' in the adjacency list.",
                    "placeholderCode": "                adj[w1[j]].add(w2[j])",
                    "validationRegex": "^\\s+adj\\[w1\\[j\\]\\]\\.add\\(w2\\[j\\]\\)$",
                    "hint": "Represent 'w1[j]' -> 'w2[j]' as a directed edge in the graph.",
                    "solutionCode": "                adj[w1[j]].add(w2[j])"
                },
                {
                    "id": 11,
                    "instruction": "Break the loop as only the first differing character matters for the ordering.",
                    "placeholderCode": "                break",
                    "validationRegex": "^\\s+break$",
                    "hint": "Subsequent characters do not provide information about the relative order of these two words.",
                    "solutionCode": "                break"
                },
                {
                    "id": 12,
                    "instruction": "Initialize the 'visit' dictionary to track the state of each node.",
                    "placeholderCode": "    visit = {}",
                    "validationRegex": "^\\s+visit\\s*=\\s*{}$",
                    "hint": "Nodes can be in three states: not visited (not in dict), visiting (True), or visited (False).",
                    "solutionCode": "    visit = {}"
                },
                {
                    "id": 13,
                    "instruction": "Initialize an empty list 'res' to store the characters in reverse topological order.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]$",
                    "hint": "Characters are added to this list after all their neighbors have been processed.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 14,
                    "instruction": "Define the helper function 'dfs' to perform the topological search.",
                    "placeholderCode": "    def dfs(c):",
                    "validationRegex": "^\\s+def\\s+dfs\\(c\\):$",
                    "hint": "The function takes a character 'c' as input and returns True if a cycle is detected.",
                    "solutionCode": "    def dfs(c):"
                },
                {
                    "id": 15,
                    "instruction": "Check if the character 'c' has already been encountered in the current search or a previous one.",
                    "placeholderCode": "        if c in visit:",
                    "validationRegex": "^\\s+if\\s+c\\s+in\\s+visit:$",
                    "hint": "This handles both detecting cycles and avoiding redundant work.",
                    "solutionCode": "        if c in visit:"
                },
                {
                    "id": 16,
                    "instruction": "Return the visit status of character 'c'.",
                    "placeholderCode": "            return visit[c]",
                    "validationRegex": "^\\s+return\\s+visit\\[c\\]$",
                    "hint": "Returns True if we are already visiting this node (cycle), or False if it's already fully processed.",
                    "solutionCode": "            return visit[c]"
                },
                {
                    "id": 17,
                    "instruction": "Mark the character 'c' as currently being visited (entering the call stack).",
                    "placeholderCode": "        visit[c] = True",
                    "validationRegex": "^\\s+visit\\[c\\]\\s*=\\s*True$",
                    "hint": "Setting it to True helps in detecting cycles in subsequent recursive calls.",
                    "solutionCode": "        visit[c] = True"
                },
                {
                    "id": 18,
                    "instruction": "Iterate through each neighbor 'nei' of character 'c' in the adjacency list.",
                    "placeholderCode": "        for nei in adj[c]:",
                    "validationRegex": "^\\s+for\\s+nei\\s+in\\s+adj\\[c\\]:$",
                    "hint": "Explore all characters that are declared to come AFTER 'c'.",
                    "solutionCode": "        for nei in adj[c]:"
                },
                {
                    "id": 19,
                    "instruction": "Recursively call 'dfs' on the neighbor to continue the search.",
                    "placeholderCode": "            if dfs(nei):",
                    "validationRegex": "^\\s+if\\s+dfs\\(nei\\):$",
                    "hint": "Check if a cycle exists in the path starting from 'nei'.",
                    "solutionCode": "            if dfs(nei):"
                },
                {
                    "id": 20,
                    "instruction": "Return True if the recursive call detects a cycle.",
                    "placeholderCode": "                return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "Propagate the cycle detection back up the call stack.",
                    "solutionCode": "                return True"
                },
                {
                    "id": 21,
                    "instruction": "Mark the character 'c' as fully processed (exiting the call stack).",
                    "placeholderCode": "        visit[c] = False",
                    "validationRegex": "^\\s+visit\\[c\\]\\s*=\\s*False$",
                    "hint": "Reset the status to False to signify this node and its dependencies are finished.",
                    "solutionCode": "        visit[c] = False"
                },
                {
                    "id": 22,
                    "instruction": "Append the character 'c' to the 'res' list.",
                    "placeholderCode": "        res.append(c)",
                    "validationRegex": "^\\s+res\\.append\\(c\\)$",
                    "hint": "Since this is post-order traversal, the result list will be in reverse order.",
                    "solutionCode": "        res.append(c)"
                },
                {
                    "id": 23,
                    "instruction": "Return False to indicate that no cycle was detected from node 'c'.",
                    "placeholderCode": "        return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "This signals to the caller that the search from this node was successful.",
                    "solutionCode": "        return False"
                },
                {
                    "id": 24,
                    "instruction": "Initiate a loop to apply DFS to every character node in the dictionary.",
                    "placeholderCode": "    for c in adj:",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+adj:$",
                    "hint": "Ensure all components of the graph are covered, including disconnected ones.",
                    "solutionCode": "    for c in adj:"
                },
                {
                    "id": 25,
                    "instruction": "Call the 'dfs' function for each character and check if a cycle is detected.",
                    "placeholderCode": "        if dfs(c):",
                    "validationRegex": "^\\s+if\\s+dfs\\(c\\):$",
                    "hint": "The DFS returns True if there's a contradiction in the character order.",
                    "solutionCode": "        if dfs(c):"
                },
                {
                    "id": 26,
                    "instruction": "Return an empty string if a cycle is detected.",
                    "placeholderCode": "            return \"\"",
                    "validationRegex": "^\\s+return\\s*\"\"$",
                    "hint": "An empty string indicates that no valid ordering exists for the alien words.",
                    "solutionCode": "            return \"\""
                },
                {
                    "id": 27,
                    "instruction": "Reverse the 'res' list to obtain the correct topological order.",
                    "placeholderCode": "    res.reverse()",
                    "validationRegex": "^\\s+res\\.reverse\\(\\)$",
                    "hint": "The topological sort order is the reverse of the post-order sequence.",
                    "solutionCode": "    res.reverse()"
                },
                {
                    "id": 28,
                    "instruction": "Join the characters in 'res' into a single string and return it.",
                    "placeholderCode": "    return \"\".join(res)",
                    "validationRegex": "^\\s+return\\s*\"\"\\.join\\(res\\)$",
                    "hint": "The final string represents the lexicographical order of the new alien language.",
                    "solutionCode": "    return \"\".join(res)"
                }
            ]
        }
    }
}