{
    "id": "reverse-nodes-in-k-group",
    "title": "Reverse Nodes in k-Group",
    "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.",
    "examples": [
        {
            "input": "head = [1,2,3,4,5], k = 2",
            "output": "[2,1,4,3,5]"
        },
        {
            "input": "head = [1,2,3,4,5], k = 3",
            "output": "[3,2,1,4,5]"
        }
    ],
    "constraints": [
        "The number of nodes in the list is n.",
        "1 <= k <= n <= 5000",
        "0 <= Node.val <= 1000"
    ],
    "difficulty": "Hard",
    "topic": "Linked List",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Recursive",
            "description": "Reverse k nodes and recursively call for rest.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function reverse_k_group that takes head and k.",
                    "placeholderCode": "def reverse_k_group(head, k):",
                    "validationRegex": "^def\\s+reverse_k_group\\(head,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def reverse_k_group(head, k):"
                },
                {
                    "id": 2,
                    "instruction": "Check if k nodes exist.",
                    "placeholderCode": "    curr = head\n    count = 0\n    while curr and count < k:\n        curr = curr.next\n        count += 1\n    if count < k: return head",
                    "validationRegex": "^\\s+curr\\s*=\\s*head\\s*count\\s*=\\s*0\\s*while\\s+curr\\s+and\\s+count\\s*<\\s*k:\\s*curr\\s*=\\s*curr\\.next\\s*count\\s*\\+=\\s*1\\s*if\\s+count\\s*<\\s*k:\\s*return\\s+head$",
                    "hint": "Count nodes. If less than k, return head.",
                    "solutionCode": "    curr = head\n    count = 0\n    while curr and count < k:\n        curr = curr.next\n        count += 1\n    if count < k: return head"
                },
                {
                    "id": 3,
                    "instruction": "Reverse k nodes.",
                    "placeholderCode": "    new_head = self.reverse(head, k)\n    head.next = self.reverse_k_group(curr, k)\n    return new_head",
                    "validationRegex": "^\\s+new_head\\s*=\\s*self\\.reverse\\(head,\\s*k\\)\\s*head\\.next\\s*=\\s*self\\.reverse_k_group\\(curr,\\s*k\\)\\s*return\\s+new_head$",
                    "hint": "Reverse current group and recursively call for next group.",
                    "solutionCode": "    new_head = self.reverse(head, k)\n    head.next = self.reverse_k_group(curr, k)\n    return new_head"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Iterative",
            "description": "Reverse groups iteratively.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function reverse_k_group that takes head and k.",
                    "placeholderCode": "def reverse_k_group(head, k):",
                    "validationRegex": "^def\\s+reverse_k_group\\(head,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def reverse_k_group(head, k):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dummy.",
                    "placeholderCode": "    dummy = ListNode(0, head)\n    groupPrev = dummy",
                    "validationRegex": "^\\s+dummy\\s*=\\s*ListNode\\(0,\\s*head\\)\\s*groupPrev\\s*=\\s*dummy$",
                    "hint": "Init dummy node and `groupPrev`.",
                    "solutionCode": "    dummy = ListNode(0, head)\n    groupPrev = dummy""validationRegex": "^\\s+return\\s+dummy\\.next$",
                    "hint": "Return `dummy.next`.",
                    "solutionCode": "    return dummy.next"
                }
            ]
        }
    }
}