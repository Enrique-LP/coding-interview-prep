{
    "id": "reverse-nodes-in-k-group",
    "title": "Reverse Nodes in k-Group",
    "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.",
    "examples": [
        {
            "input": "head = [1,2,3,4,5], k = 2",
            "output": "[2,1,4,3,5]"
        },
        {
            "input": "head = [1,2,3,4,5], k = 3",
            "output": "[3,2,1,4,5]"
        }
    ],
    "constraints": [
        "The number of nodes in the list is n.",
        "1 <= k <= n <= 5000",
        "0 <= Node.val <= 1000"
    ],
    "difficulty": "Hard",
    "topic": "Linked List",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Recursive",
            "description": "Reverse k nodes and recursively call for rest.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function reverse_k_group that takes head and k.",
                    "placeholderCode": "def reverse_k_group(head, k):",
                    "validationRegex": "^def\\s+reverse_k_group\\(head,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def reverse_k_group(head, k):"
                },
                {
                    "id": 2,
                    "instruction": "Check if k nodes exist.",
                    "placeholderCode": "    curr = head\n    count = 0\n    while curr and count < k:\n        curr = curr.next\n        count += 1\n    if count < k: return head",
                    "validationRegex": "^\\s+curr\\s*=\\s*head\\s*count\\s*=\\s*0\\s*while\\s+curr\\s+and\\s+count\\s*<\\s*k:\\s*curr\\s*=\\s*curr\\.next\\s*count\\s*\\+=\\s*1\\s*if\\s+count\\s*<\\s*k:\\s*return\\s+head$",
                    "hint": "Count nodes. If less than k, return head.",
                    "solutionCode": "    curr = head\n    count = 0\n    while curr and count < k:\n        curr = curr.next\n        count += 1\n    if count < k: return head"
                },
                {
                    "id": 3,
                    "instruction": "Reverse k nodes.",
                    "placeholderCode": "    new_head = self.reverse(head, k)\n    head.next = self.reverse_k_group(curr, k)\n    return new_head",
                    "validationRegex": "^\\s+new_head\\s*=\\s*self\\.reverse\\(head,\\s*k\\)\\s*head\\.next\\s*=\\s*self\\.reverse_k_group\\(curr,\\s*k\\)\\s*return\\s+new_head$",
                    "hint": "Reverse current group and recursively call for next group.",
                    "solutionCode": "    new_head = self.reverse(head, k)\n    head.next = self.reverse_k_group(curr, k)\n    return new_head"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Iterative",
            "description": "Reverse groups iteratively using a dummy node and a helper to find the k-th node.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function 'reverse_k_group' that takes 'head' and 'k'.",
                    "placeholderCode": "def reverse_k_group(head, k):",
                    "validationRegex": "^def\\s+reverse_k_group\\(head,\\s*k\\):$",
                    "hint": "This is the main function to reverse the list in groups.",
                    "solutionCode": "def reverse_k_group(head, k):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize a dummy node pointing to the head.",
                    "placeholderCode": "    dummy = ListNode(0, head)",
                    "validationRegex": "^\\s+dummy\\s*=\\s*ListNode\\(0,\\s*head\\)$",
                    "hint": "A dummy node helps manage the new head of the list.",
                    "solutionCode": "    dummy = ListNode(0, head)"
                },
                {
                    "id": 3,
                    "instruction": "Initialize 'groupPrev' to point to the dummy node.",
                    "placeholderCode": "    groupPrev = dummy",
                    "validationRegex": "^\\s+groupPrev\\s*=\\s*dummy$",
                    "hint": "This pointer track the node immediately before the current group.",
                    "solutionCode": "    groupPrev = dummy"
                },
                {
                    "id": 4,
                    "instruction": "Start an infinite loop to process each group of k nodes.",
                    "placeholderCode": "    while True:",
                    "validationRegex": "^\\s+while\\s+True:$",
                    "hint": "We will exit the loop manually when we don't have k nodes left.",
                    "solutionCode": "    while True:"
                },
                {
                    "id": 5,
                    "instruction": "Find the k-th node from the current 'groupPrev'.",
                    "placeholderCode": "        kth = self.getKth(groupPrev, k)",
                    "validationRegex": "^\\s+kth\\s*=\\s*self\\.getKth\\(groupPrev,\\s*k\\)$",
                    "hint": "You'll need a helper method to traverse k steps forward.",
                    "solutionCode": "        kth = self.getKth(groupPrev, k)"
                },
                {
                    "id": 6,
                    "instruction": "Check if the k-th node exists.",
                    "placeholderCode": "        if not kth:",
                    "validationRegex": "^\\s+if\\s+not\\s+kth:$",
                    "hint": "If kth is None, it means we don't have a full group left to reverse.",
                    "solutionCode": "        if not kth:"
                },
                {
                    "id": 7,
                    "instruction": "Break the loop if a full group of k nodes is not found.",
                    "placeholderCode": "            break",
                    "validationRegex": "^\\s+break$",
                    "hint": "Exit the loop to conclude the process.",
                    "solutionCode": "            break"
                },
                {
                    "id": 8,
                    "instruction": "Identify the node immediately after the current group.",
                    "placeholderCode": "        groupNext = kth.next",
                    "validationRegex": "^\\s+groupNext\\s*=\\s*kth\\.next$",
                    "hint": "We need to save this to link the reversed group later.",
                    "solutionCode": "        groupNext = kth.next"
                },
                {
                    "id": 9,
                    "instruction": "Initialize 'prev' and 'curr' for the group reversal process.",
                    "placeholderCode": "        prev, curr = kth.next, groupPrev.next",
                    "validationRegex": "^\\s+prev,\\s*curr\\s*=\\s*kth\\.next,\\s*groupPrev\\.next$",
                    "hint": "'prev' starts as groupNext to link the group's end properly.",
                    "solutionCode": "        prev, curr = kth.next, groupPrev.next"
                },
                {
                    "id": 10,
                    "instruction": "Start a loop to reverse the nodes within the k-group.",
                    "placeholderCode": "        while curr != groupNext:",
                    "validationRegex": "^\\s+while\\s+curr\\s*!=\\s*groupNext:$",
                    "hint": "We repeat this until we reach the start of the next group.",
                    "solutionCode": "        while curr != groupNext:"
                },
                {
                    "id": 11,
                    "instruction": "Temporarily store the next node.",
                    "placeholderCode": "            tmp = curr.next",
                    "validationRegex": "^\\s+tmp\\s*=\\s*curr\\.next$",
                    "hint": "Don't lose the link to the rest of the list.",
                    "solutionCode": "            tmp = curr.next"
                },
                {
                    "id": 12,
                    "instruction": "Point the current node's next to the previous node.",
                    "placeholderCode": "            curr.next = prev",
                    "validationRegex": "^\\s+curr\\.next\\s*=\\s*prev$",
                    "hint": "This is the actual reversal step.",
                    "solutionCode": "            curr.next = prev"
                },
                {
                    "id": 13,
                    "instruction": "Move 'prev' pointer forward to the current node.",
                    "placeholderCode": "            prev = curr",
                    "validationRegex": "^\\s+prev\\s*=\\s*curr$",
                    "hint": "Prepare 'prev' for the next iteration.",
                    "solutionCode": "            prev = curr"
                },
                {
                    "id": 14,
                    "instruction": "Move 'curr' pointer forward to the next node.",
                    "placeholderCode": "            curr = tmp",
                    "validationRegex": "^\\s+curr\\s*=\\s*tmp$",
                    "hint": "Advance 'curr' using our temporary variable.",
                    "solutionCode": "            curr = tmp"
                },
                {
                    "id": 15,
                    "instruction": "Identify the node that will become the new end of the group.",
                    "placeholderCode": "        tmp = groupPrev.next",
                    "validationRegex": "^\\s+tmp\\s*=\\s*groupPrev\\.next$",
                    "hint": "The current head of the group will be its tail after reversal.",
                    "solutionCode": "        tmp = groupPrev.next"
                },
                {
                    "id": 16,
                    "instruction": "Connect the end of the previous group to the new head of this group.",
                    "placeholderCode": "        groupPrev.next = kth",
                    "validationRegex": "^\\s+groupPrev\\.next\\s*=\\s*kth$",
                    "hint": "Update the link from the preceding group.",
                    "solutionCode": "        groupPrev.next = kth"
                },
                {
                    "id": 17,
                    "instruction": "Move 'groupPrev' to the end of the newly reversed group.",
                    "placeholderCode": "        groupPrev = tmp",
                    "validationRegex": "^\\s+groupPrev\\s*=\\s*tmp$",
                    "hint": "This node is now the predecessor for the next group.",
                    "solutionCode": "        groupPrev = tmp"
                },
                {
                    "id": 18,
                    "instruction": "Return the modified linked list through the dummy's next pointer.",
                    "placeholderCode": "    return dummy.next",
                    "validationRegex": "^\\s+return\\s+dummy\\.next$",
                    "hint": "The dummy node's next points to the final modified head.",
                    "solutionCode": "    return dummy.next"
                },
                {
                    "id": 19,
                    "instruction": "Define the helper method 'getKth' that takes 'curr' and 'k'.",
                    "placeholderCode": "def getKth(self, curr, k):",
                    "validationRegex": "^def\\s+getKth\\(self,\\s*curr,\\s*k\\):$",
                    "hint": "This method helps find the node 'k' positions ahead.",
                    "solutionCode": "def getKth(self, curr, k):"
                },
                {
                    "id": 20,
                    "instruction": "Iterate while the current node exists and k is greater than zero.",
                    "placeholderCode": "    while curr and k > 0:",
                    "validationRegex": "^\\s+while\\s+curr\\s+and\\s+k\\s*>\\s*0:$",
                    "hint": "We need both conditions to safely traverse the list.",
                    "solutionCode": "    while curr and k > 0:"
                },
                {
                    "id": 21,
                    "instruction": "Move the 'curr' pointer forward.",
                    "placeholderCode": "        curr = curr.next",
                    "validationRegex": "^\\s+curr\\s*=\\s*curr\\.next$",
                    "hint": "Advance one node at a time.",
                    "solutionCode": "        curr = curr.next"
                },
                {
                    "id": 22,
                    "instruction": "Decrement k.",
                    "placeholderCode": "        k -= 1",
                    "validationRegex": "^\\s+k\\s*-=\\s*1$",
                    "hint": "Track how many more steps we need to take.",
                    "solutionCode": "        k -= 1"
                },
                {
                    "id": 23,
                    "instruction": "Return the k-th node found.",
                    "placeholderCode": "    return curr",
                    "validationRegex": "^\\s+return\\s+curr$",
                    "hint": "This will return the node at the end of the group or None.",
                    "solutionCode": "    return curr"
                }
            ]
        }
    }
}