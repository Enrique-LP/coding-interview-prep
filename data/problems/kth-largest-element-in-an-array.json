{
    "id": "kth-largest-element-in-an-array",
    "title": "Kth Largest Element in an Array",
    "description": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.",
    "examples": [
        {
            "input": "nums = [3,2,1,5,6,4], k = 2",
            "output": "5"
        },
        {
            "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
            "output": "4"
        }
    ],
    "constraints": [
        "1 <= k <= nums.length <= 10^5",
        "-10^4 <= nums[i] <= 10^4"
    ],
    "difficulty": "Medium",
    "topic": "Heap / Priority Queue",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Sorting",
            "description": "Sort and pick kth element.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_kth_largest that takes nums and k.",
                    "placeholderCode": "def find_kth_largest(nums, k):",
                    "validationRegex": "^def\\s+find_kth_largest\\(nums,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_kth_largest(nums, k):"
                },
                {
                    "id": 2,
                    "instruction": "Sort and return.",
                    "placeholderCode": "    nums.sort()\n    return nums[len(nums) - k]",
                    "validationRegex": "^\\s+nums\\.sort\\(\\)\\s*return\\s+nums\\[len\\(nums\\)\\s*-\\s*k\\]$",
                    "hint": "Sort the array and return the element at index len(nums) - k.",
                    "solutionCode": "    nums.sort()\n    return nums[len(nums) - k]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "QuickSelect",
            "description": "Use QuickSelect algorithm (average O(n)).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_kth_largest that takes nums and k.",
                    "placeholderCode": "def find_kth_largest(nums, k):",
                    "validationRegex": "^def\\s+find_kth_largest\\(nums,\\s*k\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_kth_largest(nums, k):"
                },
                {
                    "id": 2,
                    "instruction": "Set target index.",
                    "placeholderCode": "    k = len(nums) - k",
                    "validationRegex": "^\\s+k\\s*=\\s*len\\(nums\\)\\s*-\\s*k$",
                    "hint": "Convert kth largest to index in sorted array.",
                    "solutionCode": "    k = len(nums) - k"
                },
                {
                    "id": 3,
                    "instruction": "Define the nested 'quickSelect' function.",
                    "placeholderCode": "    def quickSelect(l, r):",
                    "validationRegex": "^\\s+def\\s+quickSelect\\(\\s*l\\s*,\\s*r\\s*\\)\\s*:$",
                    "hint": "Define a helper for range-based searching.",
                    "solutionCode": "    def quickSelect(l, r):"
                },
                {
                    "id": 4,
                    "instruction": "Initialize 'pivot' from the right edge and partition pointer 'p' at the left edge.",
                    "placeholderCode": "        pivot, p = nums[r], l",
                    "validationRegex": "^\\s+pivot\\s*,\\s*p\\s*=\\s*nums\\[r\\]\\s*,\\s*l$",
                    "hint": "Standard QuickSelect partition initialization.",
                    "solutionCode": "        pivot, p = nums[r], l"
                },
                {
                    "id": 5,
                    "instruction": "Loop through the range from 'l' to 'r'.",
                    "placeholderCode": "        for i in range(l, r):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(\\s*l\\s*,\\s*r\\s*\\)\\s*:$",
                    "hint": "Iterate to compare elements with the pivot.",
                    "solutionCode": "        for i in range(l, r):"
                },
                {
                    "id": 6,
                    "instruction": "Check if the current element is less than or equal to the pivot.",
                    "placeholderCode": "            if nums[i] <= pivot:",
                    "validationRegex": "^\\s+if\\s+nums\\[i\\]\\s*<=\\s*pivot\\s*:$",
                    "hint": "Condition to move smaller elements to the left partition.",
                    "solutionCode": "            if nums[i] <= pivot:"
                },
                {
                    "id": 7,
                    "instruction": "Swap the current element with the element at the partition pointer.",
                    "placeholderCode": "                nums[p], nums[i] = nums[i], nums[p]",
                    "validationRegex": "^\\s+nums\\[p\\]\\s*,\\s*nums\\[i\\]\\s*=\\s*nums\\[i\\]\\s*,\\s*nums\\[p\\]$",
                    "hint": "Typical swap logic for partitioning.",
                    "solutionCode": "                nums[p], nums[i] = nums[i], nums[p]"
                },
                {
                    "id": 8,
                    "instruction": "Increment the partition pointer.",
                    "placeholderCode": "                p += 1",
                    "validationRegex": "^\\s+p\\s*\\+=\\s*1$",
                    "hint": "Move the boundary for smaller elements.",
                    "solutionCode": "                p += 1"
                },
                {
                    "id": 9,
                    "instruction": "Move the pivot into its final sorted position.",
                    "placeholderCode": "        nums[p], nums[r] = nums[r], nums[p]",
                    "validationRegex": "^\\s+nums\\[p\\]\\s*,\\s*nums\\[r\\]\\s*=\\s*nums\\[r\\]\\s*,\\s*nums\\[p\\]$",
                    "hint": "The pivot stays at index 'p' permanently.",
                    "solutionCode": "        nums[p], nums[r] = nums[r], nums[p]"
                },
                {
                    "id": 10,
                    "instruction": "If the pivot index 'p' is greater than our target 'k', search the left side.",
                    "placeholderCode": "        if p > k: return quickSelect(l, p - 1)",
                    "validationRegex": "^\\s+if\\s+p\\s*>\\s*k\\s*:\\s*return\\s+quickSelect\\(\\s*l\\s*,\\s*p\\s*-\\s*1\\s*\\)$",
                    "hint": "Recurse on the lower half.",
                    "solutionCode": "        if p > k: return quickSelect(l, p - 1)"
                },
                {
                    "id": 11,
                    "instruction": "If the pivot index 'p' is less than 'k', search the right side.",
                    "placeholderCode": "        elif p < k: return quickSelect(p + 1, r)",
                    "validationRegex": "^\\s+elif\\s+p\\s*<\\s*k\\s*:\\s*return\\s+quickSelect\\(\\s*p\\s*\\+\\s*1\\s*,\\s*r\\s*\\)$",
                    "hint": "Recurse on the upper half.",
                    "solutionCode": "        elif p < k: return quickSelect(p + 1, r)"
                },
                {
                    "id": 12,
                    "instruction": "Otherwise, the target index 'k' matches 'p'; return the element.",
                    "placeholderCode": "        else: return nums[p]",
                    "validationRegex": "^\\s+else\\s*:\\s*return\\s+nums\\[p\\]$",
                    "hint": "We found the kth largest element.",
                    "solutionCode": "        else: return nums[p]"
                },
                {
                    "id": 13,
                    "instruction": "Initiate the recursive algorithm from index 0 to the end of the array.",
                    "placeholderCode": "    return quickSelect(0, len(nums) - 1)",
                    "validationRegex": "^\\s+return\\s+quickSelect\\(0,\\s*len\\(nums\\)\\s*-\\s*1\\)$",
                    "hint": "Start the divide-and-conquer process.",
                    "solutionCode": "    return quickSelect(0, len(nums) - 1)"
                }
            ]
        }
    }
}