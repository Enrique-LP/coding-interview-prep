{
    "id": "longest-increasing-path-in-a-matrix",
    "title": "Longest Increasing Path in a Matrix",
    "description": "Given an m x n integers matrix, return the length of the longest increasing path in matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).",
    "examples": [
        {
            "input": "matrix = [[9,9,4],[6,6,8],[2,1,1]]",
            "output": "4",
            "explanation": "The longest increasing path is [1, 2, 6, 9]."
        },
        {
            "input": "matrix = [[3,4,5],[3,2,6],[2,2,1]]",
            "output": "4",
            "explanation": "The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed."
        }
    ],
    "constraints": [
        "m == matrix.length",
        "n == matrix[i].length",
        "1 <= m, n <= 200",
        "0 <= matrix[i][j] <= 2^31 - 1"
    ],
    "difficulty": "Hard",
    "topic": "2-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "DFS from each cell with memoization to find the longest increasing path.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function longest_increasing_path that takes matrix.",
                    "placeholderCode": "def longest_increasing_path(matrix):",
                    "validationRegex": "^def\\s+longest_increasing_path\\(matrix\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def longest_increasing_path(matrix):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize dimensions and memo.",
                    "placeholderCode": "    rows, cols = len(matrix), len(matrix[0])\n    dp = {}",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(matrix\\),\\s*len\\(matrix\\[0\\]\\)\\s*dp\\s*=\\s*\\{\\}$",
                    "hint": "Get matrix dimensions and initialize a dictionary `dp` for memoization.",
                    "solutionCode": "    rows, cols = len(matrix), len(matrix[0])\n    dp = {}"
                },
                {
                    "id": 3,
                    "instruction": "Define DFS helper.",
                    "placeholderCode": "    def dfs(r, c, prevVal):\n        if r < 0 or r == rows or c < 0 or c == cols or matrix[r][c] <= prevVal:\n            return 0\n        if (r, c) in dp: return dp[(r, c)]",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*prevVal\\):\\s*if\\s+r\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*<\\s*0\\s+or\\s+c\\s*==\\s*cols\\s+or\\s+matrix\\[r\\]\\[c\\]\\s*<=\\s*prevVal:\\s*return\\s+0\\s*if\\s*\\(r,\\s*c\\)\\s+in\\s+dp:\\s*return\\s+dp\\[\\(r,\\s*c\\)\\]$",
                    "hint": "DFS function. Check bounds and if current value is greater than previous value. Check memo.",
                    "solutionCode": "    def dfs(r, c, prevVal):\n        if r < 0 or r == rows or c < 0 or c == cols or matrix[r][c] <= prevVal:\n            return 0\n        if (r, c) in dp: return dp[(r, c)]"
                },
                {
                    "id": 4,
                    "instruction": "Check all 4 directions.",
                    "placeholderCode": "        res = 1\n        res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))\n        res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))\n        res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))\n        res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))",
                    "validationRegex": "^\\s+res\\s*=\\s*1\\s*res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*matrix\\[r\\]\\[c\\]\\)\\)\\s*res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(r\\s*-\\s*1,\\s*c,\\s*matrix\\[r\\]\\[c\\]\\)\\)\\s*res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*matrix\\[r\\]\\[c\\]\\)\\)\\s*res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(r,\\s*c\\s*-\\s*1,\\s*matrix\\[r\\]\\[c\\]\\)\\)$",
                    "hint": "Recursively call DFS for all 4 neighbors. Add 1 to the result.",
                    "solutionCode": "        res = 1\n        res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))\n        res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))\n        res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))\n        res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))"
                },
                {
                    "id": 5,
                    "instruction": "Memoize and return.",
                    "placeholderCode": "        dp[(r, c)] = res\n        return res",
                    "validationRegex": "^\\s+dp\\[\\(r,\\s*c\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Store result in memo and return.",
                    "solutionCode": "        dp[(r, c)] = res\n        return res"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through all cells.",
                    "placeholderCode": "    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, -1)\n    return max(dp.values())",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):\\s*for\\s+c\\s+in\\s+range\\(cols\\):\\s*dfs\\(r,\\s*c,\\s*-1\\)\\s*return\\s+max\\(dp\\.values\\(\\)\\)$",
                    "hint": "Run DFS from every cell to ensure all paths are covered. Return the maximum value found in dp.",
                    "solutionCode": "    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, -1)\n    return max(dp.values())"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Efficient DFS with memoization to ensure each cell is processed only once, achieving O(m*n) time complexity.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function longest_increasing_path that takes matrix.",
                    "placeholderCode": "def longest_increasing_path(matrix):",
                    "validationRegex": "^def\\s+longest_increasing_path\\(matrix\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def longest_increasing_path(matrix):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the variables 'rows' and 'cols' with the dimensions of the input matrix.",
                    "placeholderCode": "    rows, cols = len(matrix), len(matrix[0])",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(matrix\\),\\s*len\\(matrix\\[0\\]\\)$",
                    "hint": "Capturing dimensions will help in boundary checks during DFS.",
                    "solutionCode": "    rows, cols = len(matrix), len(matrix[0])"
                },
                {
                    "id": 3,
                    "instruction": "Initialize an empty dictionary 'dp' to store the longest path length found for each cell.",
                    "placeholderCode": "    dp = {}",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\{\\}$",
                    "hint": "Memoization prevents redundant calculations and is key to the O(m*n) complexity.",
                    "solutionCode": "    dp = {}"
                },
                {
                    "id": 4,
                    "instruction": "Define a the recursive DFS helper function 'dfs' that takes current coordinates and the previous cell value.",
                    "placeholderCode": "    def dfs(r, c, prevVal):",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*prevVal\\):$",
                    "hint": "This function will explore paths starting from (r, c) only if the value is greater than 'prevVal'.",
                    "solutionCode": "    def dfs(r, c, prevVal):"
                },
                {
                    "id": 5,
                    "instruction": "Add a base case to check for out-of-bounds coordinates or if the current cell value is not greater than the previous cell value.",
                    "placeholderCode": "        if r < 0 or r == rows or c < 0 or c == cols or matrix[r][c] <= prevVal:",
                    "validationRegex": "^\\s+if\\s+r\\s*<\\s*0\\s+or\\s+r\\s*==\\s*rows\\s+or\\s+c\\s*<\\s*0\\s+or\\s+c\\s*==\\s*cols\\s+or\\s+matrix\\[r\\]\\[c\\]\\s*<=\\s*prevVal:$",
                    "hint": "The path must be strictly increasing and stay within the matrix boundaries.",
                    "solutionCode": "        if r < 0 or r == rows or c < 0 or c == cols or matrix[r][c] <= prevVal:"
                },
                {
                    "id": 6,
                    "instruction": "If any of the base case conditions are met, return a path length of 0.",
                    "placeholderCode": "            return 0",
                    "validationRegex": "^\\s+return\\s+0$",
                    "hint": "A length of 0 indicates that no valid increasing path continues from this direction.",
                    "solutionCode": "            return 0"
                },
                {
                    "id": 7,
                    "instruction": "Check if the result for the current cell (r, c) has already been computed and stored in the DP table.",
                    "placeholderCode": "        if (r, c) in dp: return dp[(r, c)]",
                    "validationRegex": "^\\s+if\\s*\\(r,\\s*c\\)\\s+in\\s+dp:\\s*return\\s+dp\\[\\(r,\\s*c\\)\\]$",
                    "hint": "If the state is already in 'dp', returning it immediately avoids redundant recursive calls.",
                    "solutionCode": "        if (r, c) in dp: return dp[(r, c)]"
                },
                {
                    "id": 8,
                    "instruction": "Initialize 'res' to 1, representing the minimum possible path length for the current cell.",
                    "placeholderCode": "        res = 1",
                    "validationRegex": "^\\s+res\\s*=\\s*1$",
                    "hint": "Even if no neighbors are larger, the cell itself forms a path of length 1.",
                    "solutionCode": "        res = 1"
                },
                {
                    "id": 9,
                    "instruction": "Update 'res' with the potential path through the neighbor below (r + 1, c).",
                    "placeholderCode": "        res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))",
                    "validationRegex": "^\\s+res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*matrix\\[r\\]\\[c\\]\\)\\)$",
                    "hint": "We call DFS recursively for the neighbor and add 1 to its result.",
                    "solutionCode": "        res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))"
                },
                {
                    "id": 10,
                    "instruction": "Update 'res' with the potential path through the neighbor above (r - 1, c).",
                    "placeholderCode": "        res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))",
                    "validationRegex": "^\\s+res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(r\\s*-\\s*1,\\s*c,\\s*matrix\\[r\\]\\[c\\]\\)\\)$",
                    "hint": "We take the maximum between our current 'res' and the new path found.",
                    "solutionCode": "        res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))"
                },
                {
                    "id": 11,
                    "instruction": "Update 'res' with the potential path through the neighbor to the right (r, c + 1).",
                    "placeholderCode": "        res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))",
                    "validationRegex": "^\\s+res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*matrix\\[r\\]\\[c\\]\\)\\)$",
                    "hint": "Continue checking all four cardinal directions.",
                    "solutionCode": "        res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))"
                },
                {
                    "id": 12,
                    "instruction": "Update 'res' with the potential path through the neighbor to the left (r, c - 1).",
                    "placeholderCode": "        res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))",
                    "validationRegex": "^\\s+res\\s*=\\s*max\\(res,\\s*1\\s*\\+\\s*dfs\\(r,\\s*c\\s*-\\s*1,\\s*matrix\\[r\\]\\[c\\]\\)\\)$",
                    "hint": "This is the final directional check in the DFS.",
                    "solutionCode": "        res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))"
                },
                {
                    "id": 13,
                    "instruction": "Store the computed maximum path length for the current cell in the DP table.",
                    "placeholderCode": "        dp[(r, c)] = res",
                    "validationRegex": "^\\s+dp\\[\\(r,\\s*c\\)\\]\\s*=\\s*res$",
                    "hint": "Caching the result is essential for the DFS with memoization strategy.",
                    "solutionCode": "        dp[(r, c)] = res"
                },
                {
                    "id": 14,
                    "instruction": "Return the calculated maximum path length for the current cell.",
                    "placeholderCode": "        return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "This value will be used by the caller to build up the path length.",
                    "solutionCode": "        return res"
                },
                {
                    "id": 15,
                    "instruction": "Initiate a loop to iterate through each row of the matrix.",
                    "placeholderCode": "    for r in range(rows):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):$",
                    "hint": "We need to check every cell to ensure we find the global maximum.",
                    "solutionCode": "    for r in range(rows):"
                },
                {
                    "id": 16,
                    "instruction": "Initiate a nested loop to iterate through each column of the matrix.",
                    "placeholderCode": "        for c in range(cols):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):$",
                    "hint": "This nested loop ensures we visit every cell (r, c).",
                    "solutionCode": "        for c in range(cols):"
                },
                {
                    "id": 17,
                    "instruction": "Call the 'dfs' helper function for the current cell, starting with a previous value of -1.",
                    "placeholderCode": "            dfs(r, c, -1)",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c,\\s*-1\\)$",
                    "hint": "-1 is used as 'prevVal' because any cell value (>=0) will be strictly greater than it.",
                    "solutionCode": "            dfs(r, c, -1)"
                },
                {
                    "id": 18,
                    "instruction": "Find and return the maximum value stored in the 'dp' dictionary.",
                    "placeholderCode": "    return max(dp.values())",
                    "validationRegex": "^\\s+return\\s+max\\(dp\\.values\\(\\)\\)$",
                    "hint": "After processing all cells, 'dp' contains the longest path starting from each cell.",
                    "solutionCode": "    return max(dp.values())"
                }
            ]
        }
    }
}