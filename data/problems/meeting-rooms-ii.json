{
    "id": "meeting-rooms-ii",
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.",
    "examples": [
        {
            "input": "intervals = [[0,30],[5,10],[15,20]]",
            "output": "2"
        },
        {
            "input": "intervals = [[7,10],[2,4]]",
            "output": "1"
        }
    ],
    "constraints": [
        "1 <= intervals.length <= 10^4",
        "0 <= starti < endi <= 10^6"
    ],
    "difficulty": "Medium",
    "topic": "Intervals",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Chronological Ordering",
            "description": "Sort start and end times separately.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_meeting_rooms that takes intervals.",
                    "placeholderCode": "def min_meeting_rooms(intervals):",
                    "validationRegex": "^def\\s+min_meeting_rooms\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_meeting_rooms(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Separate and sort start and end times.",
                    "placeholderCode": "    start = sorted([i[0] for i in intervals])\n    end = sorted([i[1] for i in intervals])",
                    "validationRegex": "^\\s+start\\s*=\\s*sorted\\(\\[i\\[0\\]\\s+for\\s+i\\s+in\\s+intervals\\]\\)\\s*end\\s*=\\s*sorted\\(\\[i\\[1\\]\\s+for\\s+i\\s+in\\s+intervals\\]\\)$",
                    "hint": "Extract start times and end times into separate lists and sort them.",
                    "solutionCode": "    start = sorted([i[0] for i in intervals])\n    end = sorted([i[1] for i in intervals])"
                },
                {
                    "id": 3,
                    "instruction": "Iterate and count rooms.",
                    "placeholderCode": "    res, count = 0, 0\n    s, e = 0, 0\n    while s < len(intervals):\n        if start[s] < end[e]:\n            s += 1\n            count += 1\n        else:\n            e += 1\n            count -= 1\n        res = max(res, count)",
                    "validationRegex": "^\\s+res,\\s*count\\s*=\\s*0,\\s*0\\s*s,\\s*e\\s*=\\s*0,\\s*0\\s*while\\s+s\\s*<\\s+len\\(intervals\\):\\s*if\\s+start\\[s\\]\\s*<\\s+end\\[e\\]:\\s*s\\s*\\+=\\s*1\\s*count\\s*\\+=\\s*1\\s*else:\\s*e\\s*\\+=\\s*1\\s*count\\s*-=\\s*1\\s*res\\s*=\\s*max\\(res,\\s*count\\)$",
                    "hint": "Use two pointers. If next meeting starts before current meeting ends, we need a new room (increment count). Else, a meeting ended (decrement count). Track max count.",
                    "solutionCode": "    res, count = 0, 0\n    s, e = 0, 0\n    while s < len(intervals):\n        if start[s] < end[e]:\n            s += 1\n            count += 1\n        else:\n            e += 1\n            count -= 1\n        res = max(res, count)"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the maximum number of rooms needed.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Chronological Ordering",
            "description": "Same as brute force, O(n log n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function min_meeting_rooms that takes intervals.",
                    "placeholderCode": "def min_meeting_rooms(intervals):",
                    "validationRegex": "^def\\s+min_meeting_rooms\\(intervals\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def min_meeting_rooms(intervals):"
                },
                {
                    "id": 2,
                    "instruction": "Separate and sort start and end times.",
                    "placeholderCode": "    start = sorted([i[0] for i in intervals])\n    end = sorted([i[1] for i in intervals])",
                    "validationRegex": "^\\s+start\\s*=\\s*sorted\\(\\[i\\[0\\]\\s+for\\s+i\\s+in\\s+intervals\\]\\)\\s*end\\s*=\\s*sorted\\(\\[i\\[1\\]\\s+for\\s+i\\s+in\\s+intervals\\]\\)$",
                    "hint": "Sort start and end times.",
                    "solutionCode": "    start = sorted([i[0] for i in intervals])\n    end = sorted([i[1] for i in intervals])"
                },
                {
                    "id": 3,
                    "instruction": "Iterate and count rooms.",
                    "placeholderCode": "    res, count = 0, 0\n    s, e = 0, 0\n    while s < len(intervals):\n        if start[s] < end[e]:\n            s += 1\n            count += 1\n        else:\n            e += 1\n            count -= 1\n        res = max(res, count)",
                    "validationRegex": "^\\s+res,\\s*count\\s*=\\s*0,\\s*0\\s*s,\\s*e\\s*=\\s*0,\\s*0\\s*while\\s+s\\s*<\\s+len\\(intervals\\):\\s*if\\s+start\\[s\\]\\s*<\\s+end\\[e\\]:\\s*s\\s*\\+=\\s*1\\s*count\\s*\\+=\\s*1\\s*else:\\s*e\\s*\\+=\\s*1\\s*count\\s*-=\\s*1\\s*res\\s*=\\s*max\\(res,\\s*count\\)$",
                    "hint": "Two pointers approach.",
                    "solutionCode": "    res, count = 0, 0\n    s, e = 0, 0\n    while s < len(intervals):\n        if start[s] < end[e]:\n            s += 1\n            count += 1\n        else:\n            e += 1\n            count -= 1\n        res = max(res, count)"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return result.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}