{
    "id": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "examples": [
        {
            "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
            "output": "6",
            "explanation": "The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped."
        },
        {
            "input": "height = [4,2,0,3,2,5]",
            "output": "9"
        }
    ],
    "constraints": [
        "n == height.length",
        "1 <= n <= 2 * 10^4",
        "0 <= height[i] <= 10^5"
    ],
    "difficulty": "Hard",
    "topic": "Two Pointers",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Dynamic Programming",
            "description": "Precompute max left and max right for each position.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function trap that takes height.",
                    "placeholderCode": "def trap(height):",
                    "validationRegex": "^def\\s+trap\\(height\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def trap(height):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize max arrays.",
                    "placeholderCode": "    n = len(height)\n    maxLeft = [0] * n\n    maxRight = [0] * n\n    leftVal = 0\n    for i in range(n):\n        maxLeft[i] = leftVal\n        leftVal = max(leftVal, height[i])\n    rightVal = 0\n    for i in range(n - 1, -1, -1):\n        maxRight[i] = rightVal\n        rightVal = max(rightVal, height[i])",
                    "validationRegex": "^\\s+n\\s*=\\s*len\\(height\\)\\s*maxLeft\\s*=\\s*\\[0\\]\\s*\\*\\s*n\\s*maxRight\\s*=\\s*\\[0\\]\\s*\\*\\s*n\\s*leftVal\\s*=\\s*0\\s*for\\s+i\\s+in\\s+range\\(n\\):\\s*maxLeft\\[i\\]\\s*=\\s*leftVal\\s*leftVal\\s*=\\s*max\\(leftVal,\\s*height\\[i\\]\\)\\s*rightVal\\s*=\\s*0\\s*for\\s+i\\s+in\\s+range\\(n\\s*-\\s*1,\\s*-1,\\s*-1\\):\\s*maxRight\\[i\\]\\s*=\\s*rightVal\\s*rightVal\\s*=\\s*max\\(rightVal,\\s*height\\[i\\]\\)$",
                    "hint": "Create `maxLeft` and `maxRight` arrays. Fill them by iterating forward and backward.",
                    "solutionCode": "    n = len(height)\n    maxLeft = [0] * n\n    maxRight = [0] * n\n    leftVal = 0\n    for i in range(n):\n        maxLeft[i] = leftVal\n        leftVal = max(leftVal, height[i])\n    rightVal = 0\n    for i in range(n - 1, -1, -1):\n        maxRight[i] = rightVal\n        rightVal = max(rightVal, height[i])"
                },
                {
                    "id": 3,
                    "instruction": "Calculate trapped water.",
                    "placeholderCode": "    res = 0\n    for i in range(n):\n        val = min(maxLeft[i], maxRight[i]) - height[i]\n        if val > 0: res += val",
                    "validationRegex": "^\\s+res\\s*=\\s*0\\s*for\\s+i\\s+in\\s+range\\(n\\):\\s*val\\s*=\\s*min\\(maxLeft\\[i\\],\\s*maxRight\\[i\\],\\)\\s*-\\s*height\\[i\\]\\s*if\\s+val\\s*>\\s*0:\\s*res\\s*\\+=\\s*val$",
                    "hint": "Water at `i` is `min(maxLeft[i], maxRight[i]) - height[i]`.",
                    "solutionCode": "    res = 0\n    for i in range(n):\n        val = min(maxLeft[i], maxRight[i]) - height[i]\n        if val > 0: res += val"
                },
                {
                    "id": 4,
                    "instruction": "Return result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the total accumulated water.",
                    "solutionCode": "    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Two Pointers",
            "description": "Move pointers inward, tracking max left and right.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function trap that takes height.",
                    "placeholderCode": "def trap(height):",
                    "validationRegex": "^def\\s+trap\\(height\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def trap(height):"
                },
                {
                    "id": 2,
                    "instruction": "Handle edge case for empty input.",
                    "placeholderCode": "    if not height: return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+height:\\s*return\\s+0$",
                    "hint": "If the input array is empty, no water can be trapped.",
                    "solutionCode": "    if not height: return 0"
                },
                {
                    "id": 3,
                    "instruction": "Initialize left and right pointers.",
                    "placeholderCode": "    l, r = 0, len(height) - 1",
                    "validationRegex": "^\\s+l,\\s*r\\s*=\\s*0,\\s*len\\(height\\)\\s*-\\s*1$",
                    "hint": "Start pointers at the beginning (0) and end (n-1) of the array.",
                    "solutionCode": "    l, r = 0, len(height) - 1"
                },
                {
                    "id": 4,
                    "instruction": "Initialize max height trackers.",
                    "placeholderCode": "    leftMax, rightMax = height[l], height[r]",
                    "validationRegex": "^\\s+leftMax,\\s*rightMax\\s*=\\s*height\\[l\\],\\s*height\\[r\\]$",
                    "hint": "We need to track the highest bar seen so far from the left and from the right. Initialize them with the starting values.",
                    "solutionCode": "    leftMax, rightMax = height[l], height[r]"
                },
                {
                    "id": 5,
                    "instruction": "Initialize the result variable.",
                    "placeholderCode": "    res = 0",
                    "validationRegex": "^\\s+res\\s*=\\s*0$",
                    "hint": "This variable will accumulate the total amount of trapped water.",
                    "solutionCode": "    res = 0"
                },
                {
                    "id": 6,
                    "instruction": "Iterate while left pointer is less than right pointer.",
                    "placeholderCode": "    while l < r:",
                    "validationRegex": "^\\s+while\\s+l\\s*<\\s*r:$",
                    "hint": "Continue the process until the two pointers meet.",
                    "solutionCode": "    while l < r:"
                },
                {
                    "id": 7,
                    "instruction": "Check which max height is smaller.",
                    "placeholderCode": "        if leftMax < rightMax:",
                    "validationRegex": "^\\s+if\\s+leftMax\\s*<\\s*rightMax:$",
                    "hint": "The amount of water trapped is determined by the shorter of the two walls. We always process the side with the smaller max height.",
                    "solutionCode": "        if leftMax < rightMax:"
                },
                {
                    "id": 8,
                    "instruction": "Move the left pointer inward.",
                    "placeholderCode": "            l += 1",
                    "validationRegex": "^\\s+l\\s*\\+=\\s*1$",
                    "hint": "We process position `l+1`.",
                    "solutionCode": "            l += 1"
                },
                {
                    "id": 9,
                    "instruction": "Update the max height on the left.",
                    "placeholderCode": "            leftMax = max(leftMax, height[l])",
                    "validationRegex": "^\\s+leftMax\\s*=\\s*max\\(leftMax,\\s*height\\[l\\]\\)$",
                    "hint": "Is the new wall at `l` taller than our current `leftMax`? Update if so.",
                    "solutionCode": "            leftMax = max(leftMax, height[l])"
                },
                {
                    "id": 10,
                    "instruction": "Add trapped water for the current position.",
                    "placeholderCode": "            res += leftMax - height[l]",
                    "validationRegex": "^\\s+res\\s*\\+=\\s*leftMax\\s*-\\s*height\\[l\\]$",
                    "hint": "Since `leftMax < rightMax`, the water level is bounded by `leftMax`. Water trapped = `leftMax` (water level) - `height[l]` (bar height).",
                    "solutionCode": "            res += leftMax - height[l]"
                },
                {
                    "id": 11,
                    "instruction": "Process the right side (if rightMax <= leftMax).",
                    "placeholderCode": "        else:\n            r -= 1",
                    "validationRegex": "^\\s+else:\\s*r\\s*-=\\s*1$",
                    "hint": "If `leftMax >= rightMax`, we process from the right side. Move `r` inward.",
                    "solutionCode": "        else:\n            r -= 1"
                },
                {
                    "id": 12,
                    "instruction": "Update the max height on the right.",
                    "placeholderCode": "            rightMax = max(rightMax, height[r])",
                    "validationRegex": "^\\s+rightMax\\s*=\\s*max\\(rightMax,\\s*height\\[r\\]\\)$",
                    "hint": "Check if the new wall at `r` is the tallest seen from the right so far.",
                    "solutionCode": "            rightMax = max(rightMax, height[r])"
                },
                {
                    "id": 13,
                    "instruction": "Add trapped water for the right side.",
                    "placeholderCode": "            res += rightMax - height[r]",
                    "validationRegex": "^\\s+res\\s*\\+=\\s*rightMax\\s*-\\s*height\\[r\\]$",
                    "hint": "Here, water level is bounded by `rightMax`. Add `rightMax - height[r]` to the result.",
                    "solutionCode": "            res += rightMax - height[r]"
                },
                {
                    "id": 14,
                    "instruction": "Return the result.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the total trapped water.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}