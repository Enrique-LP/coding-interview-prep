{
    "id": "kth-largest-element-in-a-stream",
    "title": "Kth Largest Element in a Stream",
    "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.",
    "examples": [
        {
            "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
            "output": "[null, 4, 5, 5, 8, 8]",
            "explanation": "KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8"
        }
    ],
    "constraints": [
        "1 <= k <= 10^4",
        "0 <= nums.length <= 10^4",
        "-10^4 <= nums[i] <= 10^4",
        "-10^4 <= val <= 10^4",
        "At most 10^4 calls will be made to add.",
        "It is guaranteed that there will be at least k elements in the array when you search for the kth element."
    ],
    "difficulty": "Easy",
    "topic": "Heap / Priority Queue",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Sort the list every time add is called.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the KthLargest class.",
                    "placeholderCode": "class KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.nums = nums",
                    "validationRegex": "^class\\s+KthLargest:\\s+def\\s+__init__\\(self,\\s*k,\\s*nums\\):\\s*self\\.k\\s*=\\s*k\\s*self\\.nums\\s*=\\s*nums$",
                    "hint": "Initialize the class with k and the list of numbers.",
                    "solutionCode": "class KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.nums = nums"
                },
                {
                    "id": 2,
                    "instruction": "Implement the add method.",
                    "placeholderCode": "    def add(self, val):\n        self.nums.append(val)\n        self.nums.sort(reverse=True)\n        return self.nums[self.k - 1]",
                    "validationRegex": "^\\s+def\\s+add\\(self,\\s*val\\):\\s*self\\.nums\\.append\\(val\\)\\s*self\\.nums\\.sort\\(reverse=True\\)\\s*return\\s+self\\.nums\\[self\\.k\\s*-\\s*1\\]$",
                    "hint": "Append the new value, sort the list in descending order, and return the kth element.",
                    "solutionCode": "    def add(self, val):\n        self.nums.append(val)\n        self.nums.sort(reverse=True)\n        return self.nums[self.k - 1]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Maintain a min heap of size k.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Import the heapq module and define the KthLargest class.",
                    "placeholderCode": "import heapq\n\nclass KthLargest:",
                    "validationRegex": "^import\\s+heapq\\s*class\\s+KthLargest:$",
                    "hint": "Start with the import outside the class definition.",
                    "solutionCode": "import heapq\n\nclass KthLargest:"
                },
                {
                    "id": 2,
                    "instruction": "Define the constructor method __init__ with k and nums.",
                    "placeholderCode": "    def __init__(self, k, nums):",
                    "validationRegex": "^\\s+def\\s+__init__\\(self,\\s*k,\\s*nums\\):$",
                    "hint": "Initialize the object with its parameters.",
                    "solutionCode": "    def __init__(self, k, nums):"
                },
                {
                    "id": 3,
                    "instruction": "Store the value of k in the instance attribute.",
                    "placeholderCode": "        self.k = k",
                    "validationRegex": "^\\s+self\\.k\\s*=\\s*k$",
                    "hint": "We need to keep k to ensure the heap never exceeds this size.",
                    "solutionCode": "        self.k = k"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the min-heap with the provided nums list.",
                    "placeholderCode": "        self.minHeap = nums",
                    "validationRegex": "^\\s+self\\.minHeap\\s*=\\s*nums$",
                    "hint": "Assign the input list to our internal heap state.",
                    "solutionCode": "        self.minHeap = nums"
                },
                {
                    "id": 5,
                    "instruction": "Transform the list into a valid min-heap in-place.",
                    "placeholderCode": "        heapq.heapify(self.minHeap)",
                    "validationRegex": "^\\s+heapq\\.heapify\\(self\\.minHeap\\)$",
                    "hint": "Use the heapify function to organize self.minHeap.",
                    "solutionCode": "        heapq.heapify(self.minHeap)"
                },
                {
                    "id": 6,
                    "instruction": "Initialize a loop that runs as long as the heap size is greater than k.",
                    "placeholderCode": "        while len(self.minHeap) > self.k:",
                    "validationRegex": "^\\s+while\\s+len\\(self\\.minHeap\\)\\s*>\\s*self\\.k:$",
                    "hint": "We only want to keep the k largest elements in our min-heap.",
                    "solutionCode": "        while len(self.minHeap) > self.k:"
                },
                {
                    "id": 7,
                    "instruction": "Pop the smallest element from the heap during each iteration.",
                    "placeholderCode": "            heapq.heappop(self.minHeap)",
                    "validationRegex": "^\\s+heapq\\.heappop\\(self\\.minHeap\\)$",
                    "hint": "This removes the smallest values, ensuring only the k largest remain.",
                    "solutionCode": "            heapq.heappop(self.minHeap)"
                },
                {
                    "id": 8,
                    "instruction": "Define the add method to insert new values into the stream.",
                    "placeholderCode": "    def add(self, val):",
                    "validationRegex": "^\\s+def\\s+add\\(self,\\s*val\\):$",
                    "hint": "This method handles subsequent additions to the stream.",
                    "solutionCode": "    def add(self, val):"
                },
                {
                    "id": 9,
                    "instruction": "Push the new value to the heap.",
                    "placeholderCode": "        heapq.heappush(self.minHeap, val)",
                    "validationRegex": "^\\s+heapq\\.heappush\\(self\\.minHeap,\\s*val\\)$",
                    "hint": "Add the new value while maintaining the heap property.",
                    "solutionCode": "        heapq.heappush(self.minHeap, val)"
                },
                {
                    "id": 10,
                    "instruction": "Remove the smallest element if the heap size exceeds k.",
                    "placeholderCode": "        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)",
                    "validationRegex": "^\\s+if\\s+len\\(self\\.minHeap\\)\\s*>\\s*self\\.k:\\s*heapq\\.heappop\\(self\\.minHeap\\)$",
                    "hint": "Keep only the k largest elements in the heap.",
                    "solutionCode": "        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)"
                },
                {
                    "id": 11,
                    "instruction": "Return the current kth largest element (the root of the min-heap).",
                    "placeholderCode": "        return self.minHeap[0]",
                    "validationRegex": "^\\s+return\\s+self\\.minHeap\\[0\\]$",
                    "hint": "In a min-heap of size k, the smallest of those k elements is the kth largest overall.",
                    "solutionCode": "        return self.minHeap[0]"
                }
            ]
        }
    }
}