{
    "id": "kth-largest-element-in-a-stream",
    "title": "Kth Largest Element in a Stream",
    "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.",
    "examples": [
        {
            "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
            "output": "[null, 4, 5, 5, 8, 8]",
            "explanation": "KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8"
        }
    ],
    "constraints": [
        "1 <= k <= 10^4",
        "0 <= nums.length <= 10^4",
        "-10^4 <= nums[i] <= 10^4",
        "-10^4 <= val <= 10^4",
        "At most 10^4 calls will be made to add.",
        "It is guaranteed that there will be at least k elements in the array when you search for the kth element."
    ],
    "difficulty": "Easy",
    "topic": "Heap / Priority Queue",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Sort the list every time add is called.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the KthLargest class.",
                    "placeholderCode": "class KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.nums = nums",
                    "validationRegex": "^class\\s+KthLargest:\\s+def\\s+__init__\\(self,\\s*k,\\s*nums\\):\\s*self\\.k\\s*=\\s*k\\s*self\\.nums\\s*=\\s*nums$",
                    "hint": "Initialize the class with k and the list of numbers.",
                    "solutionCode": "class KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.nums = nums"
                },
                {
                    "id": 2,
                    "instruction": "Implement the add method.",
                    "placeholderCode": "    def add(self, val):\n        self.nums.append(val)\n        self.nums.sort(reverse=True)\n        return self.nums[self.k - 1]",
                    "validationRegex": "^\\s+def\\s+add\\(self,\\s*val\\):\\s*self\\.nums\\.append\\(val\\)\\s*self\\.nums\\.sort\\(reverse=True\\)\\s*return\\s+self\\.nums\\[self\\.k\\s*-\\s*1\\]$",
                    "hint": "Append the new value, sort the list in descending order, and return the kth element.",
                    "solutionCode": "    def add(self, val):\n        self.nums.append(val)\n        self.nums.sort(reverse=True)\n        return self.nums[self.k - 1]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Maintain a min heap of size k.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Import the 'heapq' library to use heap operations.",
                    "placeholderCode": "import heapq",
                    "validationRegex": "^import\\s+heapq$",
                    "hint": "The 'heapq' module provides functions for implementing min-heaps.",
                    "solutionCode": "import heapq"
                },
                {
                    "id": 2,
                    "instruction": "Define the KthLargest class.",
                    "placeholderCode": "class KthLargest:",
                    "validationRegex": "^class\\s+KthLargest:$",
                    "hint": "Use the 'class' keyword followed by the name.",
                    "solutionCode": "class KthLargest:"
                },
                {
                    "id": 3,
                    "instruction": "Define the constructor method __init__ with k and nums as arguments.",
                    "placeholderCode": "    def __init__(self, k, nums):",
                    "validationRegex": "^\\s+def\\s+__init__\\(self,\\s*k,\\s*nums\\):$",
                    "hint": "The constructor is used to initialize the object's attributes.",
                    "solutionCode": "    def __init__(self, k, nums):"
                },
                {
                    "id": 4,
                    "instruction": "Store the value of k as an attribute of the instance.",
                    "placeholderCode": "        self.k = k",
                    "validationRegex": "^\\s+self\\.k\\s*=\\s*k$",
                    "hint": "Use 'self' to store attributes that will be accessible in other methods.",
                    "solutionCode": "        self.k = k"
                },
                {
                    "id": 5,
                    "instruction": "Store the provided nums list as the initial min-heap.",
                    "placeholderCode": "        self.minHeap = nums",
                    "validationRegex": "^\\s+self\\.minHeap\\s*=\\s*nums$",
                    "hint": "Assign the input list to internal state.",
                    "solutionCode": "        self.minHeap = nums"
                },
                {
                    "id": 6,
                    "instruction": "Convert the minHeap list into a valid heap in-place.",
                    "placeholderCode": "        heapq.heapify(self.minHeap)",
                    "validationRegex": "^\\s+heapq\\.heapify\\(self\\.minHeap\\)$",
                    "hint": "The heapify function reorders the list to satisfy the heap property.",
                    "solutionCode": "        heapq.heapify(self.minHeap)"
                },
                {
                    "id": 7,
                    "instruction": "Loop while the size of the heap is greater than k.",
                    "placeholderCode": "        while len(self.minHeap) > self.k:",
                    "validationRegex": "^\\s+while\\s+len\\(self\\.minHeap\\)\\s*>\\s*self\\.k:$",
                    "hint": "We only need to keep the k largest elements; the smallest one is at the root of a min-heap.",
                    "solutionCode": "        while len(self.minHeap) > self.k:"
                },
                {
                    "id": 8,
                    "instruction": "Remove the smallest element from the heap until only k elements remain.",
                    "placeholderCode": "            heapq.heappop(self.minHeap)",
                    "validationRegex": "^\\s+heapq\\.heappop\\(self\\.minHeap\\)$",
                    "hint": "Use heappop to remove the smallest element from the min-heap.",
                    "solutionCode": "            heapq.heappop(self.minHeap)"
                },
                {
                    "id": 9,
                    "instruction": "Implement the add method.",
                    "placeholderCode": "    def add(self, val):\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]",
                    "validationRegex": "^\\s+def\\s+add\\(self,\\s*val\\):\\s*heapq\\.heappush\\(self\\.minHeap,\\s*val\\)\\s*if\\s+len\\(self\\.minHeap\\)\\s*>\\s*self\\.k:\\s*heapq\\.heappop\\(self\\.minHeap\\)\\s*return\\s+self\\.minHeap\\[0\\]$",
                    "hint": "Push the new value to the heap. If the heap size exceeds k, pop the smallest element.\\n\\nExample:\\nHeap=[4, 5, 8], k=3. Add 10.\\nHeap becomes [4, 5, 8, 10]. Pop smallest (4).\\nHeap=[5, 8, 10]. Return 5 (root).",
                    "solutionCode": "    def add(self, val):\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]"
                }
            ]
        }
    }
}