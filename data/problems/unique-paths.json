{
    "id": "unique-paths",
    "title": "Unique Paths",
    "description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
    "examples": [
        {
            "input": "m = 3, n = 7",
            "output": "28"
        },
        {
            "input": "m = 3, n = 2",
            "output": "3"
        }
    ],
    "constraints": [
        "1 <= m, n <= 100"
    ],
    "difficulty": "Medium",
    "topic": "2-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively sum the number of paths from target coordinates by moving either right or down.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function unique_paths that takes m and n.",
                    "placeholderCode": "def unique_paths(m, n):",
                    "validationRegex": "^def\\s+unique_paths\\(m,\\s*n\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def unique_paths(m, n):"
                },
                {
                    "id": 2,
                    "instruction": "Define recursive helper with memoization.",
                    "placeholderCode": "    memo = {}\n    def dfs(r, c):\n        if r == m - 1 and c == n - 1: return 1\n        if r >= m or c >= n: return 0\n        if (r, c) in memo: return memo[(r, c)]",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(r,\\s*c\\):\\s*if\\s+r\\s*==\\s*m\\s*-\\s*1\\s+and\\s+c\\s*==\\s*n\\s*-\\s*1:\\s*return\\s+1\\s*if\\s+r\\s*>=\\s*m\\s+or\\s+c\\s*>=\\s*n:\\s*return\\s+0\\s*if\\s*\\(r,\\s*c\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(r,\\s*c\\)\\]$",
                    "hint": "Recursive function `dfs(r, c)` returns paths from (r, c) to bottom-right. Base cases: reached target -> 1, out of bounds -> 0. Check memo.",
                    "solutionCode": "    memo = {}\n    def dfs(r, c):\n        if r == m - 1 and c == n - 1: return 1\n        if r >= m or c >= n: return 0\n        if (r, c) in memo: return memo[(r, c)]"
                },
                {
                    "id": 3,
                    "instruction": "Sum paths from right and down.",
                    "placeholderCode": "        res = dfs(r + 1, c) + dfs(r, c + 1)\n        memo[(r, c)] = res\n        return res",
                    "validationRegex": "^\\s+res\\s*=\\s*dfs\\(r\\s*\\+\\s*1,\\s*c\\)\\s*\\+\\s*dfs\\(r,\\s*c\\s*\\+\\s*1\\)\\s*memo\\[\\(r,\\s*c\\)\\]\\s*=\\s*res\\s*return\\s+res$",
                    "hint": "Paths from current cell = paths from cell below + paths from cell to the right.",
                    "solutionCode": "        res = dfs(r + 1, c) + dfs(r, c + 1)\n        memo[(r, c)] = res\n        return res"
                },
                {
                    "id": 4,
                    "instruction": "Call helper.",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start recursion from top-left corner (0, 0).",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Iterative dynamic programming using a single row to save memory while calculating path counts from bottom-up.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function unique_paths that takes m and n.",
                    "placeholderCode": "def unique_paths(m, n):",
                    "validationRegex": "^def\\s+unique_paths\\(m,\\s*n\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def unique_paths(m, n):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize row with 1s.",
                    "placeholderCode": "    row = [1] * n",
                    "validationRegex": "^\\s+row\\s*=\\s*\\[1\\]\\s*\\*\\s*n$",
                    "hint": "Initialize a row of size n with 1s. This represents the bottom row.",
                    "solutionCode": "    row = [1] * n"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through each row upwards starting from the second to last one.",
                    "placeholderCode": "    for i in range(m - 1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(m\\s*-\\s*1\\):$",
                    "hint": "We process rows one by one from bottom to top.",
                    "solutionCode": "    for i in range(m - 1):"
                },
                {
                    "id": 4,
                    "instruction": "Initialize a temporary row 'newRow' for the current row's path counts.",
                    "placeholderCode": "        newRow = [1] * n",
                    "validationRegex": "^\\s+newRow\\s*=\\s*\\[1\\]\\s*\\*\\s*n$",
                    "hint": "Pre-fill with 1s since the last column's value is always 1.",
                    "solutionCode": "        newRow = [1] * n"
                },
                {
                    "id": 5,
                    "instruction": "Iterate backwards through the columns of the current row.",
                    "placeholderCode": "        for j in range(n - 2, -1, -1):",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(n\\s*-\\s*2,\\s*-1,\\s*-1\\):$",
                    "hint": "Start from the second to last column because we need the value to the right.",
                    "solutionCode": "        for j in range(n - 2, -1, -1):"
                },
                {
                    "id": 6,
                    "instruction": "Update the count at the current cell by adding paths from the right cell and the cell below.",
                    "placeholderCode": "            newRow[j] = newRow[j + 1] + row[j]",
                    "validationRegex": "^\\s+newRow\\[j\\]\\s*=\\s*newRow\\[j\\s*\\+\\s*1\\]\\s*\\+\\s*row\\[j\\]$",
                    "hint": "The value to the right is in 'newRow[j+1]' and the value below is in 'row[j]'.",
                    "solutionCode": "            newRow[j] = newRow[j + 1] + row[j]"
                },
                {
                    "id": 7,
                    "instruction": "Set the current row to be the new row for the next iteration.",
                    "placeholderCode": "        row = newRow",
                    "validationRegex": "^\\s+row\\s*=\\s*newRow$",
                    "hint": "Prepare for the next row above.",
                    "solutionCode": "        row = newRow"
                },
                {
                    "id": 8,
                    "instruction": "Return the first element of the row, representing total paths from top-left.",
                    "placeholderCode": "    return row[0]",
                    "validationRegex": "^\\s+return\\s+row\\[0\\]$",
                    "hint": "The result is stored in the first element of the final calculated row (index 0, 0).",
                    "solutionCode": "    return row[0]"
                }
            ]
        }
    }
}