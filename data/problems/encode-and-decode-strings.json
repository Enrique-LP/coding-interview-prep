{
    "id": "encode-and-decode-strings",
    "title": "Encode and Decode Strings",
    "description": "Design an algorithm to encode a list of strings to a string. The encoded string is then sent to the other person who is called to decode it to the original list of strings.",
    "examples": [
        {
            "input": "[\"lint\",\"code\",\"love\",\"you\"]",
            "output": "[\"lint\",\"code\",\"love\",\"you\"]",
            "explanation": "One possible encoding is \"4#lint4#code4#love3#you\"."
        },
        {
            "input": "[\"we\", \"say\", \":\", \"yes\"]",
            "output": "[\"we\", \"say\", \":\", \"yes\"]"
        }
    ],
    "constraints": [
        "0 <= strs.length <= 200",
        "strs[i] contains any possible characters out of 256 valid ascii characters."
    ],
    "difficulty": "Medium",
    "topic": "String",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Delimiter",
            "description": "Use a non-ascii delimiter. (Might fail if delimiter is in string)",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define encode function.",
                    "placeholderCode": "def encode(strs):\n    return \"π\".join(strs)",
                    "validationRegex": "^def\\s+encode\\(strs\\):\\s*return\\s+\"π\"\\.join\\(strs\\)$",
                    "hint": "Use a special character like 'π' to join strings.",
                    "solutionCode": "def encode(strs):\n    return \"π\".join(strs)"
                },
                {
                    "id": 2,
                    "instruction": "Define decode function.",
                    "placeholderCode": "def decode(s):\n    return s.split(\"π\")",
                    "validationRegex": "^def\\s+decode\\(s\\):\\s*return\\s+s\\.split\\(\"π\"\\)$",
                    "hint": "Split the string by the same special character.",
                    "solutionCode": "def decode(s):\n    return s.split(\"π\")"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Length Prefix",
            "description": "Prefix each string with its length and a delimiter.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the encode function.",
                    "placeholderCode": "def encode(strs):",
                    "validationRegex": "^def\\s+encode\\(strs\\):$",
                    "hint": "Define a function named `encode` that takes a list of strings `strs`.",
                    "solutionCode": "def encode(strs):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the result string.",
                    "placeholderCode": "    res = \"\"",
                    "validationRegex": "^\\s+res\\s*=\\s*\"\"$",
                    "hint": "Start with an empty string to accumulate our encoded result.",
                    "solutionCode": "    res = \"\""
                },
                {
                    "id": 3,
                    "instruction": "Iterate through each string.",
                    "placeholderCode": "    for s in strs:",
                    "validationRegex": "^\\s+for\\s+s\\s+in\\s+strs:$",
                    "hint": "Loop through every string in the provided list.",
                    "solutionCode": "    for s in strs:"
                },
                {
                    "id": 4,
                    "instruction": "Append length, delimiter, and string.",
                    "placeholderCode": "        res += str(len(s)) + \"#\" + s",
                    "validationRegex": "^\\s+res\\s*\\+=\\s*str\\(len\\(s\\)\\)\\s*\\+\\s*\"#\"\\s*\\+\\s*s$",
                    "hint": "Core Logic: Prefix every string with its length and a '#' delimiter. Example: 'lint' -> '4#lint'. This tells the decoder exactly where the string ends.",
                    "solutionCode": "        res += str(len(s)) + \"#\" + s"
                },
                {
                    "id": 5,
                    "instruction": "Return the encoded string.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the final concatenated string.",
                    "solutionCode": "    return res"
                },
                {
                    "id": 6,
                    "instruction": "Define the decode function.",
                    "placeholderCode": "def decode(s):",
                    "validationRegex": "^def\\s+decode\\(s\\):$",
                    "hint": "Define a function named `decode` that takes the encoded string `s`.",
                    "solutionCode": "def decode(s):"
                },
                {
                    "id": 7,
                    "instruction": "Initialize result list and pointer.",
                    "placeholderCode": "    res, i = [], 0",
                    "validationRegex": "^\\s+res,\\s*i\\s*=\\s*\\[\\],\\s*0$",
                    "hint": "Use `i` as a pointer to traverse the string `s`. Start at index 0.",
                    "solutionCode": "    res, i = [], 0"
                },
                {
                    "id": 8,
                    "instruction": "Loop through the string.",
                    "placeholderCode": "    while i < len(s):",
                    "validationRegex": "^\\s+while\\s+i\\s*<\\s+len\\(s\\):$",
                    "hint": "Continue decoding until our pointer `i` reaches the end of the string.",
                    "solutionCode": "    while i < len(s):"
                },
                {
                    "id": 9,
                    "instruction": "Find the delimiter position.",
                    "placeholderCode": "        j = i\n        while s[j] != \"#\":\n            j += 1",
                    "validationRegex": "^\\s+j\\s*=\\s*i\\s*while\\s+s\\[j\\]\\s*!=\\s*\"#\":\\s*j\\s*\\+=\\s*1$",
                    "hint": "Move a second pointer `j` forward until it hits the '#'. The text between `i` and `j` is our number (the length).",
                    "solutionCode": "        j = i\n        while s[j] != \"#\":\n            j += 1"
                },
                {
                    "id": 10,
                    "instruction": "Parse the length of the next string.",
                    "placeholderCode": "        length = int(s[i:j])",
                    "validationRegex": "^\\s+length\\s*=\\s*int\\(s\\[i:j\\]\\)$",
                    "hint": "Convert the substring from `i` to `j` into an integer. This tells us how many characters to read next.",
                    "solutionCode": "        length = int(s[i:j])"
                },
                {
                    "id": 11,
                    "instruction": "Extract the string and add to result.",
                    "placeholderCode": "        res.append(s[j + 1 : j + 1 + length])",
                    "validationRegex": "^\\s+res\\.append\\(s\\[j\\s*\\+\\s*1\\s*:\\s*j\\s*\\+\\s*1\\s*\\+\\s*length\\]\\)$",
                    "hint": "Slice the string starting RIGHT AFTER the delimiter (`j+1`) up to the specified `length`. Append it to `res`.",
                    "solutionCode": "        res.append(s[j + 1 : j + 1 + length])"
                },
                {
                    "id": 12,
                    "instruction": "Move the pointer to the next segment.",
                    "placeholderCode": "        i = j + 1 + length",
                    "validationRegex": "^\\s+i\\s*=\\s*j\\s*\\+\\s*1\\s*\\+\\s*length$",
                    "hint": "Update `i` to jump over the string we just read, landing on the start of the next length prefix.",
                    "solutionCode": "        i = j + 1 + length"
                },
                {
                    "id": 13,
                    "instruction": "Return the decoded list.",
                    "placeholderCode": "    return res",
                    "validationRegex": "^\\s+return\\s+res$",
                    "hint": "Return the list of original strings.",
                    "solutionCode": "    return res"
                }
            ]
        }
    }
}