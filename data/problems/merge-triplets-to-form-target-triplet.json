{
    "id": "merge-triplets-to-form-target-triplet",
    "title": "Merge Triplets to Form Target Triplet",
    "description": "A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain. To obtain target, you may apply the following operation on triplets any number of times (possibly zero): Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)]. Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise.",
    "examples": [
        {
            "input": "triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]",
            "output": "true",
            "explanation": "Perform the operation with triplets 2 and 0 (0-indexed) to have triplets[2] = [max(1,2), max(7,5), max(5,3)] = [2,7,5] = target."
        },
        {
            "input": "triplets = [[3,4,5],[4,5,6]], target = [3,2,5]",
            "output": "false"
        }
    ],
    "constraints": [
        "1 <= triplets.length <= 10^5",
        "triplets[i].length == target.length == 3",
        "1 <= ai, bi, ci, x, y, z <= 1000"
    ],
    "difficulty": "Medium",
    "topic": "Greedy",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Greedy Filter",
            "description": "Filter invalid triplets and check if target components exist.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function merge_triplets that takes triplets and target.",
                    "placeholderCode": "def merge_triplets(triplets, target):",
                    "validationRegex": "^def\\s+merge_triplets\\(triplets,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def merge_triplets(triplets, target):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize set to track found target components.",
                    "placeholderCode": "    good = set()",
                    "validationRegex": "^\\s+good\\s*=\\s*set\\(\\)$",
                    "hint": "Use a set to keep track of which indices (0, 1, 2) of the target triplet have been satisfied.",
                    "solutionCode": "    good = set()"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through triplets.",
                    "placeholderCode": "    for t in triplets:\n        if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n            continue",
                    "validationRegex": "^\\s+for\\s+t\\s+in\\s+triplets:\\s*if\\s+t\\[0\\]\\s*>\\s+target\\[0\\]\\s+or\\s+t\\[1\\]\\s*>\\s+target\\[1\\]\\s+or\\s+t\\[2\\]\\s*>\\s+target\\[2\\]:\\s*continue$",
                    "hint": "Ignore any triplet that has any component greater than the corresponding target component, as it can never be part of the solution.\\n\\nExample:\\nTarget=[2, 7, 5].\\nTriplet [3, 4, 5]: 3 > 2. Invalid.\\nTriplet [1, 8, 4]: 8 > 7. Invalid.\\nTriplet [2, 5, 3]: Valid.",
                    "solutionCode": "    for t in triplets:\n        if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n            continue"
                },
                {
                    "id": 4,
                    "instruction": "Check if components match target.",
                    "placeholderCode": "        for i, v in enumerate(t):\n            if v == target[i]:\n                good.add(i)",
                    "validationRegex": "^\\s+for\\s+i,\\s*v\\s+in\\s+enumerate\\(t\\):\\s*if\\s+v\\s*==\\s+target\\[i\\]:\\s*good\\.add\\(i\\)$",
                    "hint": "For valid triplets, check if any component matches the target component. If so, add the index to the set.",
                    "solutionCode": "        for i, v in enumerate(t):\n            if v == target[i]:\n                good.add(i)"
                },
                {
                    "id": 5,
                    "instruction": "Return True if all components found.",
                    "placeholderCode": "    return len(good) == 3",
                    "validationRegex": "^\\s+return\\s+len\\(good\\)\\s*==\\s*3$",
                    "hint": "If we found matches for all 3 positions, return True.",
                    "solutionCode": "    return len(good) == 3"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Greedy Filter",
            "description": "Same as brute force, O(n).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function merge_triplets that takes triplets and target.",
                    "placeholderCode": "def merge_triplets(triplets, target):",
                    "validationRegex": "^def\\s+merge_triplets\\(triplets,\\s*target\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def merge_triplets(triplets, target):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize set to track found target components.",
                    "placeholderCode": "    good = set()",
                    "validationRegex": "^\\s+good\\s*=\\s*set\\(\\)$",
                    "hint": "Use a set to keep track of satisfied target indices.",
                    "solutionCode": "    good = set()"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through triplets.",
                    "placeholderCode": "    for t in triplets:\n        if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n            continue",
                    "validationRegex": "^\\s+for\\s+t\\s+in\\s+triplets:\\s*if\\s+t\\[0\\]\\s*>\\s+target\\[0\\]\\s+or\\s+t\\[1\\]\\s*>\\s+target\\[1\\]\\s+or\\s+t\\[2\\]\\s*>\\s+target\\[2\\]:\\s*continue$",
                    "hint": "Skip invalid triplets.",
                    "solutionCode": "    for t in triplets:\n        if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n            continue"
                },
                {
                    "id": 4,
                    "instruction": "Check if components match target.",
                    "placeholderCode": "        for i, v in enumerate(t):\n            if v == target[i]:\n                good.add(i)",
                    "validationRegex": "^\\s+for\\s+i,\\s*v\\s+in\\s+enumerate\\(t\\):\\s*if\\s+v\\s*==\\s+target\\[i\\]:\\s*good\\.add\\(i\\)$",
                    "hint": "Add matching indices to the set.",
                    "solutionCode": "        for i, v in enumerate(t):\n            if v == target[i]:\n                good.add(i)"
                },
                {
                    "id": 5,
                    "instruction": "Return True if all components found.",
                    "placeholderCode": "    return len(good) == 3",
                    "validationRegex": "^\\s+return\\s+len\\(good\\)\\s*==\\s*3$",
                    "hint": "Return True if the set contains 0, 1, and 2.",
                    "solutionCode": "    return len(good) == 3"
                }
            ]
        }
    }
}