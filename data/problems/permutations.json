{
    "id": "permutations",
    "title": "Permutations",
    "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "examples": [
        {
            "input": "nums = [1,2,3]",
            "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
        },
        {
            "input": "nums = [0,1]",
            "output": "[[0,1],[1,0]]"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 6",
        "-10 <= nums[i] <= 10",
        "All the integers of nums are unique."
    ],
    "difficulty": "Medium",
    "topic": "Backtracking",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Remove element, permute rest, add back.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function permute that takes nums.",
                    "placeholderCode": "def permute(nums):",
                    "validationRegex": "^def\\s+permute\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def permute(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Base case: if empty, return [[]].",
                    "placeholderCode": "    if len(nums) == 0:\n        return [[]]",
                    "validationRegex": "^\\s+if\\s+len\\(nums\\)\\s*==\\s*0:\\s*return\\s*\\[\\[\\]\\]$",
                    "hint": "If the input list is empty, return a list containing an empty list.",
                    "solutionCode": "    if len(nums) == 0:\n        return [[]]"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through nums to pick one element.",
                    "placeholderCode": "    perms = []\n    for i in range(len(nums)):",
                    "validationRegex": "^\\s+perms\\s*=\\s*\\[\\]\\s*for\\s+i\\s+in\\s+range\\(len\\(nums\\)\\):$",
                    "hint": "Loop through the list to select each element as the first element.",
                    "solutionCode": "    perms = []\n    for i in range(len(nums)):"
                },
                {
                    "id": 4,
                    "instruction": "Recursively permute the remaining elements.",
                    "placeholderCode": "        n = nums.pop(0)\n        sub_perms = permute(nums)",
                    "validationRegex": "^\\s+n\\s*=\\s*nums\\.pop\\(0\\)\\s*sub_perms\\s*=\\s*permute\\(nums\\)$",
                    "hint": "Remove the first element (since we are rotating) and recursively permute the rest.\\n\\nExample:\\nNums=[1, 2, 3].\\ni=0: Pop 1. Permute([2, 3]) -> [[2, 3], [3, 2]].\\n  Add 1 -> [[2, 3, 1], [3, 2, 1]].\\ni=1: Pop 2. Permute([1, 3]) -> [[1, 3], [3, 1]].\\n  Add 2 -> [[1, 3, 2], [3, 1, 2]].",
                    "solutionCode": "        n = nums.pop(0)\n        sub_perms = permute(nums)"
                },
                {
                    "id": 5,
                    "instruction": "Append current element to sub-permutations.",
                    "placeholderCode": "        for p in sub_perms:\n            p.append(n)",
                    "validationRegex": "^\\s+for\\s+p\\s+in\\s+sub_perms:\\s*p\\.append\\(n\\)$",
                    "hint": "Add the removed element to the end of each sub-permutation.",
                    "solutionCode": "        for p in sub_perms:\n            p.append(n)"
                },
                {
                    "id": 6,
                    "instruction": "Extend result and restore nums.",
                    "placeholderCode": "        perms.extend(sub_perms)\n        nums.append(n)",
                    "validationRegex": "^\\s+perms\\.extend\\(sub_perms\\)\\s*nums\\.append\\(n\\)$",
                    "hint": "Add the new permutations to the result list and restore the original list order.",
                    "solutionCode": "        perms.extend(sub_perms)\n        nums.append(n)"
                },
                {
                    "id": 7,
                    "instruction": "Return permutations.",
                    "placeholderCode": "    return perms",
                    "validationRegex": "^\\s+return\\s+perms$",
                    "hint": "Return the list of all permutations.",
                    "solutionCode": "    return perms"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Insert each number into all positions of existing permutations.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function permute that takes nums.",
                    "placeholderCode": "def permute(nums):",
                    "validationRegex": "^def\\s+permute\\(nums\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def permute(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize perms with empty list.",
                    "placeholderCode": "    perms = [[]]",
                    "validationRegex": "^\\s+perms\\s*=\\s*\\[\\[\\]\\]$",
                    "hint": "Start with a list containing an empty list.",
                    "solutionCode": "    perms = [[]]"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through each number.",
                    "placeholderCode": "    for n in nums:",
                    "validationRegex": "^\\s+for\\s+n\\s+in\\s+nums:$",
                    "hint": "Loop through every number in the input array.",
                    "solutionCode": "    for n in nums:"
                },
                {
                    "id": 4,
                    "instruction": "Initialize a list for the permutations of the current subset.",
                    "placeholderCode": "        new_perms = []",
                    "validationRegex": "^\\s+new_perms\\s*=\\s*\\[\\]$",
                    "hint": "This will temporarily hold permutations including the current number.",
                    "solutionCode": "        new_perms = []"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through all currently existing permutations.",
                    "placeholderCode": "        for p in perms:",
                    "validationRegex": "^\\s+for\\s+p\\s+in\\s+perms:$",
                    "hint": "We are adding the current number to each one of the permutations we have built so far.",
                    "solutionCode": "        for p in perms:"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through all possible positions to insert the current number.",
                    "placeholderCode": "            for i in range(len(p) + 1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(p\\)\\s*\\+\\s*1\\):$",
                    "hint": "A list of length p has len(p) + 1 potential insertion spots.",
                    "solutionCode": "            for i in range(len(p) + 1):"
                },
                {
                    "id": 7,
                    "instruction": "Create a copy of the current permutation.",
                    "placeholderCode": "                p_copy = p.copy()",
                    "validationRegex": "^\\s+p_copy\\s*=\\s*p\\.copy\\(\\)$",
                    "hint": "We must Copy the list to avoid modifying the original permutation in the results.",
                    "solutionCode": "                p_copy = p.copy()"
                },
                {
                    "id": 8,
                    "instruction": "Insert the number into the copied permutation at the current position.",
                    "placeholderCode": "                p_copy.insert(i, n)",
                    "validationRegex": "^\\s+p_copy\\.insert\\(i,\\s*n\\)$",
                    "hint": "Use the insert method to place the element.",
                    "solutionCode": "                p_copy.insert(i, n)"
                },
                {
                    "id": 9,
                    "instruction": "Add the newly created permutation to the list of new permutations.",
                    "placeholderCode": "                new_perms.append(p_copy)",
                    "validationRegex": "^\\s+new_perms\\.append\\(p_copy\\)$",
                    "hint": "Store each variation in the temporary list.",
                    "solutionCode": "                new_perms.append(p_copy)"
                },
                {
                    "id": 10,
                    "instruction": "Update perms with the new permutations.",
                    "placeholderCode": "        perms = new_perms",
                    "validationRegex": "^\\s+perms\\s*=\\s*new_perms$",
                    "hint": "Update the list of permutations with the newly generated ones.",
                    "solutionCode": "        perms = new_perms"
                },
                {
                    "id": 11,
                    "instruction": "Return permutations.",
                    "placeholderCode": "    return perms",
                    "validationRegex": "^\\s+return\\s+perms$",
                    "hint": "Return the final list of permutations.",
                    "solutionCode": "    return perms"
                }
            ]
        }
    }
}