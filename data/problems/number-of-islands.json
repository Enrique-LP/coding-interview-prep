{
    "id": "number-of-islands",
    "title": "Number of Islands",
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "examples": [
        {
            "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
            "output": "1"
        },
        {
            "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
            "output": "3"
        }
    ],
    "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 300",
        "grid[i][j] is '0' or '1'."
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS",
            "description": "Iterate through grid, start DFS on land to mark visited.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function num_islands that takes grid.",
                    "placeholderCode": "def num_islands(grid):",
                    "validationRegex": "^def\\s+num_islands\\(grid\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def num_islands(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Check for empty grid.",
                    "placeholderCode": "    if not grid:\n        return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+grid:\\s*return\\s+0$",
                    "hint": "Return 0 if the grid is empty.",
                    "solutionCode": "    if not grid:\n        return 0"
                },
                {
                    "id": 3,
                    "instruction": "Initialize count and dimensions.",
                    "placeholderCode": "    count = 0\n    rows, cols = len(grid), len(grid[0])",
                    "validationRegex": "^\\s+count\\s*=\\s*0\\s*rows,\\s*cols\\s*=\\s*len\\(grid\\),\\s*len\\(grid\\[0\\]\\)$",
                    "hint": "Initialize a counter for islands and get grid dimensions.",
                    "solutionCode": "    count = 0\n    rows, cols = len(grid), len(grid[0])"
                },
                {
                    "id": 4,
                    "instruction": "Define DFS helper to mark visited land.",
                    "placeholderCode": "    def dfs(r, c):\n        if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0':\n            return\n        grid[r][c] = '0'\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c\\):\\s*if\\s+r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*>=\\s+rows\\s+or\\s+c\\s*>=\\s+cols\\s+or\\s+grid\\[r\\]\\[c\\]\\s*==\\s*'0':\\s*return\\s*grid\\[r\\]\\[c\\]\\s*=\\s*'0'\\s*dfs\\(r\\s*\\+\\s*1,\\s*c\\)\\s*dfs\\(r\\s*-\\s*1,\\s*c\\)\\s*dfs\\(r,\\s*c\\s*\\+\\s*1\\)\\s*dfs\\(r,\\s*c\\s*-\\s*1\\)$",
                    "hint": "Recursive DFS. If out of bounds or water, return. Mark current cell as visited (e.g., change '1' to '0') and recurse in 4 directions.",
                    "solutionCode": "    def dfs(r, c):\n        if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0':\n            return\n        grid[r][c] = '0'\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through grid and start DFS on '1's.",
                    "placeholderCode": "    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                dfs(r, c)\n                count += 1",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):\\s*for\\s+c\\s+in\\s+range\\(cols\\):\\s*if\\s+grid\\[r\\]\\[c\\]\\s*==\\s*'1':\\s*dfs\\(r,\\s*c\\)\\s*count\\s*\\+=\\s*1$",
                    "hint": "Loop through every cell. If it's land, start DFS to mark the entire island and increment count.",
                    "solutionCode": "    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                dfs(r, c)\n                count += 1"
                },
                {
                    "id": 6,
                    "instruction": "Return count.",
                    "placeholderCode": "    return count",
                    "validationRegex": "^\\s+return\\s+count$",
                    "hint": "Return the total number of islands found.",
                    "solutionCode": "    return count"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "BFS",
            "description": "Use BFS to mark connected land cells.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Import collections and define the function num_islands.",
                    "placeholderCode": "import collections\ndef num_islands(grid):",
                    "validationRegex": "^import\\s+collections\\s+def\\s+num_islands\\(grid\\):$",
                    "hint": "Import the collections module and define the main function.",
                    "solutionCode": "import collections\ndef num_islands(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Check for empty grid.",
                    "placeholderCode": "    if not grid:\n        return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+grid:\\s*return\\s+0$",
                    "hint": "If the input grid is empty, return 0.",
                    "solutionCode": "    if not grid: return 0"
                },
                {
                    "id": 3,
                    "instruction": "Store the number of rows and columns.",
                    "placeholderCode": "    rows, cols = len(grid), len(grid[0])",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(grid\\),\\s*len\\(grid\\[0\\]\\)$",
                    "hint": "Get the grid's vertical and horizontal dimensions.",
                    "solutionCode": "    rows, cols = len(grid), len(grid[0])"
                },
                {
                    "id": 4,
                    "instruction": "Initialize a set to track visited cells.",
                    "placeholderCode": "    visit = set()",
                    "validationRegex": "^\\s+visit\\s*=\\s*set\\(\\)$",
                    "hint": "Using a set prevents revisiting the same cell and avoids modifying the input grid.",
                    "solutionCode": "    visit = set()"
                },
                {
                    "id": 5,
                    "instruction": "Initialize the island counter.",
                    "placeholderCode": "    islands = 0",
                    "validationRegex": "^\\s+islands\\s*=\\s*0$",
                    "hint": "This variable will store the total number of islands found.",
                    "solutionCode": "    islands = 0"
                },
                {
                    "id": 6,
                    "instruction": "Define the BFS helper function signature.",
                    "placeholderCode": "    def bfs(r, c):",
                    "validationRegex": "^\\s+def\\s+bfs\\(r,\\s*c\\):$",
                    "hint": "Define a helper function to perform BFS starting from cell (r, c).",
                    "solutionCode": "    def bfs(r, c):"
                },
                {
                    "id": 7,
                    "instruction": "Initialize the BFS queue.",
                    "placeholderCode": "        q = collections.deque()",
                    "validationRegex": "^\\s+q\\s*=\\s*collections\\.deque\\(\\)$",
                    "hint": "Create a double-ended queue for BFS.",
                    "solutionCode": "        q = collections.deque()"
                },
                {
                    "id": 8,
                    "instruction": "Mark the starting cell as visited.",
                    "placeholderCode": "        visit.add((r, c))",
                    "validationRegex": "^\\s+visit\\.add\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Add the current row and column as a tuple to the visit set.",
                    "solutionCode": "        visit.add((r, c))"
                },
                {
                    "id": 9,
                    "instruction": "Append the starting cell to the queue.",
                    "placeholderCode": "        q.append((r, c))",
                    "validationRegex": "^\\s+q\\.append\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Add the starting coordinates to the queue to begin the search.",
                    "solutionCode": "        q.append((r, c))"
                },
                {
                    "id": 10,
                    "instruction": "Start the while loop to process the queue.",
                    "placeholderCode": "        while q:",
                    "validationRegex": "^\\s+while\\s+q:$",
                    "hint": "Continue the process as long as there are cells in the queue.",
                    "solutionCode": "        while q:"
                },
                {
                    "id": 11,
                    "instruction": "Pop the next cell from the queue.",
                    "placeholderCode": "            row, col = q.popleft()",
                    "validationRegex": "^\\s+row,\\s*col\\s*=\\s*q\\.popleft\\(\\)$",
                    "hint": "Retrieve the coordinates of the cell to expand.",
                    "solutionCode": "            row, col = q.popleft()"
                },
                {
                    "id": 12,
                    "instruction": "Define the possible movement directions.",
                    "placeholderCode": "            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]",
                    "validationRegex": "^\\s+directions\\s*=\\s*\\[\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\],\\s*\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\]\\]$",
                    "hint": "Define up, down, left, and right moves.",
                    "solutionCode": "            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]"
                },
                {
                    "id": 13,
                    "instruction": "Iterate through each direction.",
                    "placeholderCode": "            for dr, dc in directions:",
                    "validationRegex": "^\\s+for\\s+dr,\\s*dc\\s+in\\s+directions:$",
                    "hint": "Loop through each of the 4 defined directions.",
                    "solutionCode": "            for dr, dc in directions:"
                },
                {
                    "id": 14,
                    "instruction": "Calculate the new row index.",
                    "placeholderCode": "                r_new = row + dr",
                    "validationRegex": "^\\s+r_new\\s*=\\s*row\\s*\\+\\s*dr$",
                    "hint": "Compute the next row index by adding the direction delta.",
                    "solutionCode": "                r_new = row + dr"
                },
                {
                    "id": 15,
                    "instruction": "Calculate the new column index.",
                    "placeholderCode": "                c_new = col + dc",
                    "validationRegex": "^\\s+c_new\\s*=\\s*col\\s*\\+\\s*dc$",
                    "hint": "Compute the next column index by adding the direction delta.",
                    "solutionCode": "                c_new = col + dc"
                },
                {
                    "id": 16,
                    "instruction": "Check if r_new is within grid rows.",
                    "placeholderCode": "                if (r_new in range(rows) and",
                    "validationRegex": "^\\s+if\\s*\\(r_new\\s+in\\s+range\\(rows\\)\\s+and$",
                    "hint": "Verify that the new row is between 0 and total rows.",
                    "solutionCode": "                if (r_new in range(rows) and"
                },
                {
                    "id": 17,
                    "instruction": "Check if c_new is within grid columns.",
                    "placeholderCode": "                    c_new in range(cols) and",
                    "validationRegex": "^\\s+c_new\\s+in\\s+range\\(cols\\)\\s+and$",
                    "hint": "Verify that the new column is between 0 and total columns.",
                    "solutionCode": "                    c_new in range(cols) and"
                },
                {
                    "id": 18,
                    "instruction": "Check if the new cell is land.",
                    "placeholderCode": "                    grid[r_new][c_new] == '1' and",
                    "validationRegex": "^\\s+grid\\[r_new\\]\\[c_new\\]\\s*==\\s*'1'\\s+and$",
                    "hint": "Verify if the cell at new coordinates contains '1'.",
                    "solutionCode": "                    grid[r_new][c_new] == '1' and"
                },
                {
                    "id": 19,
                    "instruction": "Check if the cell hasn't been visited.",
                    "placeholderCode": "                    (r_new, c_new) not in visit):",
                    "validationRegex": "^\\s*\\(r_new,\\s*c_new\\)\\s+not\\s+in\\s+visit\\):$",
                    "hint": "Ensure the new coordinate is not already in the visit set.",
                    "solutionCode": "                    (r_new, c_new) not in visit):"
                },
                {
                    "id": 20,
                    "instruction": "Add the new valid cell to the queue.",
                    "placeholderCode": "                    q.append((r_new, c_new))",
                    "validationRegex": "^\\s+q\\.append\\(\\(r_new,\\s*c_new\\)\\)$",
                    "hint": "Expand the island by adding the neighbor to the queue.",
                    "solutionCode": "                    q.append((r_new, c_new))"
                },
                {
                    "id": 21,
                    "instruction": "Mark the new cell as visited.",
                    "placeholderCode": "                    visit.add((r_new, c_new))",
                    "validationRegex": "^\\s+visit\\.add\\(\\(r_new,\\s*c_new\\)\\)$",
                    "hint": "Ensure the neighbor is marked so it isn't processed again.",
                    "solutionCode": "                    visit.add((r_new, c_new))"
                },
                {
                    "id": 22,
                    "instruction": "Iterate through the grid using nested loops.",
                    "placeholderCode": "    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1' and (r, c) not in visit:\n                bfs(r, c)\n                islands += 1",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):\\s*for\\s+c\\s+in\\s+range\\(cols\\):\\s*if\\s+grid\\[r\\]\\[c\\]\\s*==\\s*'1'\\s+and\\s*\\(r,\\s*c\\)\\s+not\\s+in\\s+visit:\\s*bfs\\(r,\\s*c\\)\\s*islands\\s*\\+=\\s*1$",
                    "hint": "Loop through the grid. If a cell is land and not visited, start BFS and increment island count.",
                    "solutionCode": "    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1' and (r, c) not in visit:\n                bfs(r, c)\n                islands += 1"
                },
                {
                    "id": 23,
                    "instruction": "Return the total island count.",
                    "placeholderCode": "    return islands",
                    "validationRegex": "^\\s+return\\s+islands$",
                    "hint": "Return the total number of islands.",
                    "solutionCode": "    return islands"
                }
            ]
        }
    }
}