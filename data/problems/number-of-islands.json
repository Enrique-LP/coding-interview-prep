{
    "id": "number-of-islands",
    "title": "Number of Islands",
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
    "examples": [
        {
            "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
            "output": "1"
        },
        {
            "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
            "output": "3"
        }
    ],
    "constraints": [
        "m == grid.length",
        "n == grid[i].length",
        "1 <= m, n <= 300",
        "grid[i][j] is '0' or '1'."
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS",
            "description": "Iterate through grid, start DFS on land to mark visited.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function num_islands that takes grid.",
                    "placeholderCode": "def num_islands(grid):",
                    "validationRegex": "^def\\s+num_islands\\(grid\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def num_islands(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Check for empty grid.",
                    "placeholderCode": "    if not grid:\n        return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+grid:\\s*return\\s+0$",
                    "hint": "Return 0 if the grid is empty.",
                    "solutionCode": "    if not grid:\n        return 0"
                },
                {
                    "id": 3,
                    "instruction": "Initialize count and dimensions.",
                    "placeholderCode": "    count = 0\n    rows, cols = len(grid), len(grid[0])",
                    "validationRegex": "^\\s+count\\s*=\\s*0\\s*rows,\\s*cols\\s*=\\s*len\\(grid\\),\\s*len\\(grid\\[0\\]\\)$",
                    "hint": "Initialize a counter for islands and get grid dimensions.",
                    "solutionCode": "    count = 0\n    rows, cols = len(grid), len(grid[0])"
                },
                {
                    "id": 4,
                    "instruction": "Define DFS helper to mark visited land.",
                    "placeholderCode": "    def dfs(r, c):\n        if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0':\n            return\n        grid[r][c] = '0'\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c\\):\\s*if\\s+r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*>=\\s+rows\\s+or\\s+c\\s*>=\\s+cols\\s+or\\s+grid\\[r\\]\\[c\\]\\s*==\\s*'0':\\s*return\\s*grid\\[r\\]\\[c\\]\\s*=\\s*'0'\\s*dfs\\(r\\s*\\+\\s*1,\\s*c\\)\\s*dfs\\(r\\s*-\\s*1,\\s*c\\)\\s*dfs\\(r,\\s*c\\s*\\+\\s*1\\)\\s*dfs\\(r,\\s*c\\s*-\\s*1\\)$",
                    "hint": "Recursive DFS. If out of bounds or water, return. Mark current cell as visited and recurse in 4 directions.",
                    "solutionCode": "    def dfs(r, c):\n        if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] == '0':\n            return\n        grid[r][c] = '0'\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through grid and start DFS on '1's.",
                    "placeholderCode": "    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                dfs(r, c)\n                count += 1",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):\\s*for\\s+c\\s+in\\s+range\\(cols\\):\\s*if\\s+grid\\[r\\]\\[c\\]\\s*==\\s*'1':\\s*dfs\\(r,\\s*c\\)\\s*count\\s*\\+=\\s*1$",
                    "hint": "Loop through every cell. If it's land, start DFS to mark the entire island and increment count.",
                    "solutionCode": "    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                dfs(r, c)\n                count += 1"
                },
                {
                    "id": 6,
                    "instruction": "Return count.",
                    "placeholderCode": "    return count",
                    "validationRegex": "^\\s+return\\s+count$",
                    "hint": "Return the total number of islands found.",
                    "solutionCode": "    return count"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "BFS",
            "description": "Use BFS to mark connected land cells.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Import collections and define the function num_islands.",
                    "placeholderCode": "import collections\ndef num_islands(grid):",
                    "validationRegex": "^import\\s+collections\\s+def\\s+num_islands\\(grid\\):$",
                    "hint": "Use `import collections` and `def num_islands(grid):`",
                    "solutionCode": "import collections\ndef num_islands(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Check for empty grid.",
                    "placeholderCode": "    if not grid:\n        return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+grid:\\s*return\\s+0$",
                    "hint": "Handle empty input.",
                    "solutionCode": "    if not grid:\n        return 0"
                },
                {
                    "id": 3,
                    "instruction": "Get grid dimensions.",
                    "placeholderCode": "    rows, cols = len(grid), len(grid[0])",
                    "validationRegex": "^\\s+rows,\\s*cols\\s*=\\s*len\\(grid\\),\\s*len\\(grid\\[0\\]\\)$",
                    "hint": "Store len(grid) and len(grid[0]).",
                    "solutionCode": "    rows, cols = len(grid), len(grid[0])"
                },
                {
                    "id": 4,
                    "instruction": "Initialize visited set.",
                    "placeholderCode": "    visit = set()",
                    "validationRegex": "^\\s+visit\\s*=\\s*set\\(\\)$",
                    "hint": "Track visited coordinates.",
                    "solutionCode": "    visit = set()"
                },
                {
                    "id": 5,
                    "instruction": "Initialize islands counter.",
                    "placeholderCode": "    islands = 0",
                    "validationRegex": "^\\s+islands\\s*=\\s*0$",
                    "hint": "Set starting count to 0.",
                    "solutionCode": "    islands = 0"
                },
                {
                    "id": 6,
                    "instruction": "Define the BFS helper function signature.",
                    "placeholderCode": "    def bfs(r, c):",
                    "validationRegex": "^\\s+def\\s+bfs\\(r,\\s*c\\):$",
                    "hint": "Firma de la función BFS.",
                    "solutionCode": "    def bfs(r, c):"
                },
                {
                    "id": 7,
                    "instruction": "Create the BFS queue.",
                    "placeholderCode": "        q = collections.deque()",
                    "validationRegex": "^\\s+q\\s*=\\s*collections\\.deque\\(\\)$",
                    "hint": "Use collections.deque().",
                    "solutionCode": "        q = collections.deque()"
                },
                {
                    "id": 8,
                    "instruction": "Mark starting cell as visited.",
                    "placeholderCode": "        visit.add((r, c))",
                    "validationRegex": "^\\s+visit\\.add\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Add (r, c) to visit.",
                    "solutionCode": "        visit.add((r, c))"
                },
                {
                    "id": 9,
                    "instruction": "Add starting cell to queue.",
                    "placeholderCode": "        q.append((r, c))",
                    "validationRegex": "^\\s+q\\.append\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Append (r, c) to q.",
                    "solutionCode": "        q.append((r, c))"
                },
                {
                    "id": 10,
                    "instruction": "Loop while queue is not empty.",
                    "placeholderCode": "        while q:",
                    "validationRegex": "^\\s+while\\s+q:$",
                    "hint": "Manten la búsqueda mientras haya celdas.",
                    "solutionCode": "        while q:"
                },
                {
                    "id": 11,
                    "instruction": "Pop cell from queue.",
                    "placeholderCode": "            row, col = q.popleft()",
                    "validationRegex": "^\\s+row,\\s*col\\s*=\\s*q\\.popleft\\(\\)$",
                    "hint": "Get (row, col) from q.popleft().",
                    "solutionCode": "            row, col = q.popleft()"
                },
                {
                    "id": 12,
                    "instruction": "Define directions.",
                    "placeholderCode": "            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]",
                    "validationRegex": "^\\s+directions\\s*=\\s*\\[\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\],\\s*\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\]\\]$",
                    "hint": "Up, down, left, right.",
                    "solutionCode": "            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]"
                },
                {
                    "id": 13,
                    "instruction": "Iterate through directions.",
                    "placeholderCode": "            for dr, dc in directions:",
                    "validationRegex": "^\\s+for\\s+dr,\\s+dc\\s+in\\s+directions:$",
                    "hint": "Recorre cada movimiento.",
                    "solutionCode": "            for dr, dc in directions:"
                },
                {
                    "id": 14,
                    "instruction": "Calculate neighbor row.",
                    "placeholderCode": "                r_n = row + dr",
                    "validationRegex": "^\\s+r_n\\s*=\\s*row\\s*\\+\\s*dr$",
                    "hint": "r_n = row + dr",
                    "solutionCode": "                r_n = row + dr"
                },
                {
                    "id": 15,
                    "instruction": "Calculate neighbor column.",
                    "placeholderCode": "                c_n = col + dc",
                    "validationRegex": "^\\s+c_n\\s*=\\s*col\\s*\\+\\s*dc$",
                    "hint": "c_n = col + dc",
                    "solutionCode": "                c_n = col + dc"
                },
                {
                    "id": 16,
                    "instruction": "Check row bounds.",
                    "placeholderCode": "                if r_n not in range(rows): continue",
                    "validationRegex": "^\\s+if\\s+r_n\\s+not\\s+in\\s+range\\(rows\\):\\s*continue$",
                    "hint": "Skip if out of bounds.",
                    "solutionCode": "                if r_n not in range(rows): continue"
                },
                {
                    "id": 17,
                    "instruction": "Check column bounds.",
                    "placeholderCode": "                if c_n not in range(cols): continue",
                    "validationRegex": "^\\s+if\\s+c_n\\s+not\\s+in\\s+range\\(cols\\):\\s*continue$",
                    "hint": "Skip if out of bounds.",
                    "solutionCode": "                if c_n not in range(cols): continue"
                },
                {
                    "id": 18,
                    "instruction": "Check if cell is land.",
                    "placeholderCode": "                if grid[r_n][c_n] != '1': continue",
                    "validationRegex": "^\\s+if\\s+grid\\[r_n\\]\\[c_n\\]\\s*!=\\s*'1':\\s*continue$",
                    "hint": "Skip if water.",
                    "solutionCode": "                if grid[r_n][c_n] != '1': continue"
                },
                {
                    "id": 19,
                    "instruction": "Check if cell visited.",
                    "placeholderCode": "                if (r_n, c_n) in visit: continue",
                    "validationRegex": "^\\s+if\\s+\\(r_n,\\s*c_n\\)\\s+in\\s+visit:\\s*continue$",
                    "hint": "Skip if seen.",
                    "solutionCode": "                if (r_n, c_n) in visit: continue"
                },
                {
                    "id": 20,
                    "instruction": "Add valid neighbor to queue.",
                    "placeholderCode": "                q.append((r_n, c_n))",
                    "validationRegex": "^\\s+q\\.append\\(\\(r_n,\\s*c_n\\)\\)$",
                    "hint": "Expand queue.",
                    "solutionCode": "                q.append((r_n, c_n))"
                },
                {
                    "id": 21,
                    "instruction": "Mark valid neighbor as visited.",
                    "placeholderCode": "                visit.add((r_n, c_n))",
                    "validationRegex": "^\\s+visit\\.add\\(\\(r_n,\\s*c_n\\)\\)$",
                    "hint": "Mark as seen.",
                    "solutionCode": "                visit.add((r_n, c_n))"
                },
                {
                    "id": 22,
                    "instruction": "Iterate through rows.",
                    "placeholderCode": "    for r in range(rows):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(rows\\):$",
                    "hint": "Escanea filas.",
                    "solutionCode": "    for r in range(rows):"
                },
                {
                    "id": 23,
                    "instruction": "Iterate through columns.",
                    "placeholderCode": "        for c in range(cols):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(cols\\):$",
                    "hint": "Escanea columnas.",
                    "solutionCode": "        for c in range(cols):"
                },
                {
                    "id": 24,
                    "instruction": "Condition for new island.",
                    "placeholderCode": "            if grid[r][c] == '1' and (r, c) not in visit:",
                    "validationRegex": "^\\s+if\\s+grid\\[r\\]\\[c\\]\\s*==\\s*'1'\\s+and\\s+\\(r,\\s*c\\)\\s+not\\s+in\\s+visit:$",
                    "hint": "Check land and visit.",
                    "solutionCode": "            if grid[r][c] == '1' and (r, c) not in visit:"
                },
                {
                    "id": 25,
                    "instruction": "Start BFS.",
                    "placeholderCode": "                bfs(r, c)",
                    "validationRegex": "^\\s+bfs\\(r,\\s*c\\)$",
                    "hint": "Explora la isla.",
                    "solutionCode": "                bfs(r, c)"
                },
                {
                    "id": 26,
                    "instruction": "Increment counter.",
                    "placeholderCode": "                islands += 1",
                    "validationRegex": "^\\s+islands\\s*\\+=\\s*1$",
                    "hint": "Suma 1 isla.",
                    "solutionCode": "                islands += 1"
                },
                {
                    "id": 27,
                    "instruction": "Return count.",
                    "placeholderCode": "    return islands",
                    "validationRegex": "^\\s+return\\s+islands$",
                    "hint": "Final count.",
                    "solutionCode": "    return islands"
                }
            ]
        }
    }
}