{
    "id": "task-scheduler",
    "title": "Task Scheduler",
    "description": "Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks. Return the least number of units of times that the CPU will take to finish all the given tasks.",
    "examples": [
        {
            "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
            "output": "8",
            "explanation": "A -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks."
        },
        {
            "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0",
            "output": "6"
        }
    ],
    "constraints": [
        "1 <= task.length <= 10^4",
        "tasks[i] is upper-case English letter.",
        "The integer n is in the range [0, 100]."
    ],
    "difficulty": "Medium",
    "topic": "Heap / Priority Queue",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Simulate the process using a heap and queue.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function least_interval that takes tasks and n.",
                    "placeholderCode": "def least_interval(tasks, n):",
                    "validationRegex": "^def\\s+least_interval\\(tasks,\\s*n\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def least_interval(tasks, n):"
                },
                {
                    "id": 2,
                    "instruction": "Count frequencies.",
                    "placeholderCode": "    count = collections.Counter(tasks)\n    maxHeap = [-cnt for cnt in count.values()]\n    heapq.heapify(maxHeap)\n    time = 0\n    q = collections.deque() # pairs of [-cnt, idleTime]",
                    "validationRegex": "^\\s+count\\s*=\\s*collections\\.Counter\\(tasks\\)\\s*maxHeap\\s*=\\s*\\[-cnt\\s+for\\s+cnt\\s+in\\s+count\\.values\\(\\)\\]\\s*heapq\\.heapify\\(maxHeap\\)\\s*time\\s*=\\s*0\\s*q\\s*=\\s*collections\\.deque\\(\\)$",
                    "hint": "Use a max heap to store task frequencies and a queue for cooldowns.",
                    "solutionCode": "    count = collections.Counter(tasks)\n    maxHeap = [-cnt for cnt in count.values()]\n    heapq.heapify(maxHeap)\n    time = 0\n    q = collections.deque() # pairs of [-cnt, idleTime]"
                },
                {
                    "id": 3,
                    "instruction": "Process tasks.",
                    "placeholderCode": "    while maxHeap or q:\n        time += 1\n        if maxHeap:\n            cnt = 1 + heapq.heappop(maxHeap)\n            if cnt:\n                q.append([cnt, time + n])\n        if q and q[0][1] == time:\n            heapq.heappush(maxHeap, q.popleft()[0])",
                    "validationRegex": "^\\s+while\\s+maxHeap\\s+or\\s+q:\\s*time\\s*\\+=\\s*1\\s*if\\s+maxHeap:\\s*cnt\\s*=\\s*1\\s*\\+\\s*heapq\\.heappop\\(maxHeap\\)\\s*if\\s+cnt:\\s*q\\.append\\(\\[cnt,\\s*time\\s*\\+\\s*n\\]\\)\\s*if\\s+q\\s+and\\s+q\\[0\\]\\[1\\]\\s*==\\s*time:\\s*heapq\\.heappush\\(maxHeap,\\s*q\\.popleft\\(\\)\\[0\\]\\)$",
                    "hint": "Simulate each time unit, processing tasks and managing the cooldown queue.",
                    "solutionCode": "    while maxHeap or q:\n        time += 1\n        if maxHeap:\n            cnt = 1 + heapq.heappop(maxHeap)\n            if cnt:\n                q.append([cnt, time + n])\n        if q and q[0][1] == time:\n            heapq.heappush(maxHeap, q.popleft()[0])"
                },
                {
                    "id": 4,
                    "instruction": "Return time.",
                    "placeholderCode": "    return time",
                    "validationRegex": "^\\s+return\\s+time$",
                    "hint": "Return the total time elapsed.",
                    "solutionCode": "    return time"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Calculate based on max frequency.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function least_interval that takes tasks and n.",
                    "placeholderCode": "def least_interval(tasks, n):",
                    "validationRegex": "^def\\s+least_interval\\(tasks,\\s*n\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def least_interval(tasks, n):"
                },
                {
                    "id": 2,
                    "instruction": "Count the frequency of each task in the array.",
                    "placeholderCode": "    count = collections.Counter(tasks)",
                    "validationRegex": "^\\s+count\\s*=\\s*collections\\.Counter\\(tasks\\)$",
                    "hint": "Use collections.Counter to get a frequency map of the tasks.",
                    "solutionCode": "    count = collections.Counter(tasks)"
                },
                {
                    "id": 3,
                    "instruction": "Find the maximum frequency among all tasks.",
                    "placeholderCode": "    max_freq = max(count.values())",
                    "validationRegex": "^\\s+max_freq\\s*=\\s*max\\(count\\.values\\(\\)\\)$",
                    "hint": "Look for the highest value in your frequency counter.",
                    "solutionCode": "    max_freq = max(count.values())"
                },
                {
                    "id": 4,
                    "instruction": "Count how many tasks have that maximum frequency.",
                    "placeholderCode": "    max_freq_count = list(count.values()).count(max_freq)",
                    "validationRegex": "^\\s+max_freq_count\\s*=\\s*list\\(count\\.values\\(\\)\\)\\.count\\(max_freq\\)$",
                    "hint": "We need this to know if there are multiple tasks sharing the 'peak' frequency.",
                    "solutionCode": "    max_freq_count = list(count.values()).count(max_freq)"
                },
                {
                    "id": 5,
                    "instruction": "Calculate the number of gaps (parts) between the most frequent tasks.",
                    "placeholderCode": "    part_count = max_freq - 1",
                    "validationRegex": "^\\s+part_count\\s*=\\s*max_freq\\s*-\\s*1$",
                    "hint": "If A is the max freq and appears 3 times, there are 2 gaps between them.",
                    "solutionCode": "    part_count = max_freq - 1"
                },
                {
                    "id": 6,
                    "instruction": "Calculate the available length of each gap after placing other tasks with the same maximum frequency.",
                    "placeholderCode": "    part_length = n - (max_freq_count - 1)",
                    "validationRegex": "^\\s+part_length\\s*=\\s*n\\s*-\\s*\\(max_freq_count\\s*-\\s*1\\)$",
                    "hint": "If 'n' is 2 and we have A and B with max freq, the gap 'A B _' has only 1 slot left.",
                    "solutionCode": "    part_length = n - (max_freq_count - 1)"
                },
                {
                    "id": 7,
                    "instruction": "Calculate the total number of empty slots available in all gaps.",
                    "placeholderCode": "    empty_slots = part_count * part_length",
                    "validationRegex": "^\\s+empty_slots\\s*=\\s*part_count\\s*\\*\\s*part_length$",
                    "hint": "Multiply the number of gaps by the length of each gap.",
                    "solutionCode": "    empty_slots = part_count * part_length"
                },
                {
                    "id": 8,
                    "instruction": "Calculate the number of remaining tasks that can be used to fill these empty slots.",
                    "placeholderCode": "    available_tasks = len(tasks) - max_freq * max_freq_count",
                    "validationRegex": "^\\s+available_tasks\\s*=\\s*len\\(tasks\\)\\s*-\\s*max_freq\\s*\\*\\s*max_freq_count$",
                    "hint": "Subtract all tasks with the maximum frequency from the total count.",
                    "solutionCode": "    available_tasks = len(tasks) - max_freq * max_freq_count"
                },
                {
                    "id": 9,
                    "instruction": "Determine the number of idle units that couldn't be filled by available tasks.",
                    "placeholderCode": "    idles = max(0, empty_slots - available_tasks)",
                    "validationRegex": "^\\s+idles\\s*=\\s*max\\(0,\\s*empty_slots\\s*-\\s*available_tasks\\)$",
                    "hint": "If we have more empty slots than tasks, the difference remains as idle time.",
                    "solutionCode": "    idles = max(0, empty_slots - available_tasks)"
                },
                {
                    "id": 10,
                    "instruction": "Return the total time required, which is the sum of tasks and idles.",
                    "placeholderCode": "    return len(tasks) + idles",
                    "validationRegex": "^\\s+return\\s+len\\(tasks\\)\\s*\\+\\s*idles$",
                    "hint": "The answer is the original task count plus the remaining idle units.",
                    "solutionCode": "    return len(tasks) + idles"
                }
            ]
        }
    }
}