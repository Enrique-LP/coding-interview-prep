{
    "id": "swim-in-rising-water",
    "title": "Swim in Rising Water",
    "description": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j). The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim. Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).",
    "examples": [
        {
            "input": "grid = [[0,2],[1,3]]",
            "output": "3",
            "explanation": "At time 0, you are in grid[0][0].\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid."
        },
        {
            "input": "grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
            "output": "16"
        }
    ],
    "constraints": [
        "n == grid.length",
        "n == grid[i].length",
        "1 <= n <= 50",
        "0 <= grid[i][j] < n^2",
        "Each value grid[i][j] is unique."
    ],
    "difficulty": "Hard",
    "topic": "Advanced Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Use Dijkstra's algorithm to find path with min max elevation.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define swimInWater.",
                    "placeholderCode": "def swimInWater(grid):",
                    "validationRegex": "^def\\s+swimInWater\\(grid\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def swimInWater(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize.",
                    "placeholderCode": "    N = len(grid)\n    visit = set()\n    minH = [[grid[0][0], 0, 0]]\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visit.add((0, 0))",
                    "validationRegex": "^\\s+N\\s*=\\s*len\\(grid\\)\\s*visit\\s*=\\s*set\\(\\)\\s*minH\\s*=\\s*\\[\\[grid\\[0\\]\\[0\\],\\s*0,\\s*0\\]\\]\\s*directions\\s*=\\s*\\[\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\],\\s*\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\]\\]\\s*visit\\.add\\(\\(\\(0,\\s*0\\)\\)\\)$",
                    "hint": "Initialize a min-heap with the starting cell (0,0). The priority is the max elevation encountered so far on the path.",
                    "solutionCode": "    N = len(grid)\n    visit = set()\n    minH = [[grid[0][0], 0, 0]]\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visit.add((0, 0))"
                },
                {
                    "id": 3,
                    "instruction": "Run Dijkstra's.",
                    "placeholderCode": "    while minH:\n        t, r, c = heapq.heappop(minH)\n        if r == N - 1 and c == N - 1:\n            return t\n        for dr, dc in directions:\n            neiR, neiC = r + dr, c + dc\n            if (neiR < 0 or neiC < 0 or \n                neiR == N or neiC == N or\n                (neiR, neiC) in visit):\n                continue\n            visit.add((neiR, neiC))\n            heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])",
                    "validationRegex": "^\\s+while\\s+minH:\\s*t,\\s*r,\\s*c\\s*=\\s*heapq\\.heappop\\(minH\\)\\s*if\\s+r\\s*==\\s*N\\s*-\\s*1\\s+and\\s+c\\s*==\\s*N\\s*-\\s*1:\\s*return\\s+t\\s*for\\s+dr,\\s*dc\\s+in\\s+directions:\\s*neiR,\\s*neiC\\s*=\\s*r\\s*\\+\\s*dr,\\s*c\\s*\\+\\s*dc\\s*if\\s*\\(neiR\\s*<\\s*0\\s+or\\s+neiC\\s*<\\s*0\\s+or\\s+neiR\\s*==\\s*N\\s+or\\s+neiC\\s*==\\s*N\\s+or\\s*\\(neiR,\\s*neiC\\)\\s+in\\s+visit\\):\\s*continue\\s*visit\\.add\\(\\(\\(neiR,\\s*neiC\\)\\)\\)\\s*heapq\\.heappush\\(minH,\\s*\\[max\\(t,\\s*grid\\[neiR\\]\\[neiC\\]\\),\\s*neiR,\\s*neiC\\]\\)$",
                    "hint": "Pop the cell with the smallest max-elevation. If it's the target, return the time. Otherwise, explore neighbors, updating the max elevation for the path.\\n\\nExample:\\nGrid=[[0, 2], [1, 3]]. Start (0,0).\\nMinH=[(0, 0, 0)].\\nPop (0, 0, 0). MaxElev=0. Neighbors: (0,1) val 2, (1,0) val 1.\\nPush (2, 0, 1), (1, 1, 0).\\nPop (1, 1, 0). MaxElev=1. Neighbor: (1,1) val 3.\\nPush (3, 1, 1).\\nPop (2, 0, 1). MaxElev=2. Neighbor: (1,1) val 3.\\nPush (3, 1, 1).\\nPop (3, 1, 1). Target reached. Time=3.",
                    "solutionCode": "    while minH:\n        t, r, c = heapq.heappop(minH)\n        if r == N - 1 and c == N - 1:\n            return t\n        for dr, dc in directions:\n            neiR, neiC = r + dr, c + dc\n            if (neiR < 0 or neiC < 0 or \n                neiR == N or neiC == N or\n                (neiR, neiC) in visit):\n                continue\n            visit.add((neiR, neiC))\n            heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define swimInWater.",
                    "placeholderCode": "def swimInWater(grid):",
                    "validationRegex": "^def\\s+swimInWater\\(grid\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def swimInWater(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Get the size of the grid 'N'.",
                    "placeholderCode": "    N = len(grid)",
                    "validationRegex": "^\\s+N\\s*=\\s*len\\(grid\\)$",
                    "hint": "The grid is an N x N matrix.",
                    "solutionCode": "    N = len(grid)"
                },
                {
                    "id": 3,
                    "instruction": "Initialize a set 'visit' to track explored cells.",
                    "placeholderCode": "    visit = set()",
                    "validationRegex": "^\\s+visit\\s*=\\s*set\\(\\)$",
                    "hint": "Essential for Dijkstra to avoid revisiting cells.",
                    "solutionCode": "    visit = set()"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the min-heap with the starting cell's elevation and coordinates.",
                    "placeholderCode": "    minH = [[grid[0][0], 0, 0]]",
                    "validationRegex": "^\\s+minH\\s*=\\s*\\[\\[grid\\[0\\]\\[0\\],\\s*0,\\s*0\\]\\]$",
                    "hint": "The heap stores [max_elevation_so_far, row, col].",
                    "solutionCode": "    minH = [[grid[0][0], 0, 0]]"
                },
                {
                    "id": 5,
                    "instruction": "Define the 4-directional movement vectors.",
                    "placeholderCode": "    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]",
                    "validationRegex": "^\\s+directions\\s*=\\s*\\[\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\],\\s*\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\]\\]$",
                    "hint": "Represent moving right, left, down, and up.",
                    "solutionCode": "    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]"
                },
                {
                    "id": 6,
                    "instruction": "Mark the starting cell (0, 0) as visited.",
                    "placeholderCode": "    visit.add((0, 0))",
                    "validationRegex": "^\\s+visit\\.add\\(\\((0,\\s*0)\\)\\)$",
                    "hint": "Prevents the algorithm from 'moving' back to the start.",
                    "solutionCode": "    visit.add((0, 0))"
                },
                {
                    "id": 7,
                    "instruction": "Initiate the while loop that runs as long as the min-heap is not empty.",
                    "placeholderCode": "    while minH:",
                    "validationRegex": "^\\s+while\\s+minH:$",
                    "hint": "The loop continues until we find the path to the target.",
                    "solutionCode": "    while minH:"
                },
                {
                    "id": 8,
                    "instruction": "Pop the cell with the lowest maximum elevation encountered so far.",
                    "placeholderCode": "        t, r, c = heapq.heappop(minH)",
                    "validationRegex": "^\\s+t,\\s*r,\\s*c\\s*=\\s*heapq\\.heappop\\(minH\\)$",
                    "hint": "'t' is the time (max elevation), 'r' and 'c' are row and column.",
                    "solutionCode": "        t, r, c = heapq.heappop(minH)"
                },
                {
                    "id": 9,
                    "instruction": "Check if the current cell is the bottom-right corner (N-1, N-1).",
                    "placeholderCode": "        if r == N - 1 and c == N - 1:",
                    "validationRegex": "^\\s+if\\s+r\\s*==\\s*N\\s*-\\s*1\\s+and\\s+c\\s*==\\s*N\\s*-\\s*1:$",
                    "hint": "This is our target destination.",
                    "solutionCode": "        if r == N - 1 and c == N - 1:"
                },
                {
                    "id": 10,
                    "instruction": "If the target is reached, return the recorded time 't'.",
                    "placeholderCode": "            return t",
                    "validationRegex": "^\\s+return\\s+t$",
                    "hint": "Dijkstra's guarantees this is the minimum time required.",
                    "solutionCode": "            return t"
                },
                {
                    "id": 11,
                    "instruction": "Iterate through the four possible movement directions.",
                    "placeholderCode": "        for dr, dc in directions:",
                    "validationRegex": "^\\s+for\\s+dr,\\s*dc\\s+in\\s+directions:$",
                    "hint": "We check neighbors in up, down, left, and right directions.",
                    "solutionCode": "        for dr, dc in directions:"
                },
                {
                    "id": 12,
                    "instruction": "Calculate the coordinates of the neighbor cell.",
                    "placeholderCode": "            neiR, neiC = r + dr, c + dc",
                    "validationRegex": "^\\s+neiR,\\s*neiC\\s*=\\s*r\\s*\\+\\s*dr,\\s*c\\s*\\+\\s*dc$",
                    "hint": "Add the direction offset to the current row and column.",
                    "solutionCode": "            neiR, neiC = r + dr, c + dc"
                },
                {
                    "id": 13,
                    "instruction": "Check if the neighbor cell is outside the grid boundaries.",
                    "placeholderCode": "            if (neiR < 0 or neiC < 0 or neiR == N or neiC == N):",
                    "validationRegex": "^\\s+if\\s*\\(neiR\\s*<\\s*0\\s+or\\s+neiC\\s*<\\s*0\\s+or\\s+neiR\\s*==\\s*N\\s+or\\s+neiC\\s*==\\s*N\\):$",
                    "hint": "Ensure the neighbor's coordinates are within [0, N-1].",
                    "solutionCode": "            if (neiR < 0 or neiC < 0 or neiR == N or neiC == N):"
                },
                {
                    "id": 14,
                    "instruction": "Skip the neighbor if it is out of bounds.",
                    "placeholderCode": "                continue",
                    "validationRegex": "^\\s+continue$",
                    "hint": "The 'continue' keyword moves to the next direction.",
                    "solutionCode": "                continue"
                },
                {
                    "id": 15,
                    "instruction": "Check if the neighbor cell has already been visited.",
                    "placeholderCode": "            if (neiR, neiC) in visit:",
                    "validationRegex": "^\\s+if\\s*\\(neiR,\\s*neiC\\)\\s+in\\s+visit:$",
                    "hint": "We don't need to re-process cells that have already been reached.",
                    "solutionCode": "            if (neiR, neiC) in visit:"
                },
                {
                    "id": 16,
                    "instruction": "Skip the neighbor if it was already visited.",
                    "placeholderCode": "                continue",
                    "validationRegex": "^\\s+continue$",
                    "hint": "Avoid redundant calculations and potential cycles.",
                    "solutionCode": "                continue"
                },
                {
                    "id": 17,
                    "instruction": "Mark the neighbor cell as visited.",
                    "placeholderCode": "            visit.add((neiR, neiC))",
                    "validationRegex": "^\\s+visit\\.add\\(\\((neiR,\\s*neiC)\\)\\)$",
                    "hint": "Ensures this cell won't be pushed to the heap again.",
                    "solutionCode": "            visit.add((neiR, neiC))"
                },
                {
                    "id": 18,
                    "instruction": "Push the updated max elevation and the neighbor coordinates into the min-heap.",
                    "placeholderCode": "            heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])",
                    "validationRegex": "^\\s+heapq\\.heappush\\(minH,\\s*\\[max\\(t,\\s*grid\\[neiR\\]\\[neiC\\]\\),\\s*neiR,\\s*neiC\\]\\)$",
                    "hint": "The new elevation is the maximum of the current 't' and the neighbor's elevation.",
                    "solutionCode": "            heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])"
                }
            ]
        }
    }
}