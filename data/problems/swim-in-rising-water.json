{
    "id": "swim-in-rising-water",
    "title": "Swim in Rising Water",
    "description": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j). The rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim. Return the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).",
    "examples": [
        {
            "input": "grid = [[0,2],[1,3]]",
            "output": "3",
            "explanation": "At time 0, you are in grid[0][0].\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid."
        },
        {
            "input": "grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
            "output": "16"
        }
    ],
    "constraints": [
        "n == grid.length",
        "n == grid[i].length",
        "1 <= n <= 50",
        "0 <= grid[i][j] < n^2",
        "Each value grid[i][j] is unique."
    ],
    "difficulty": "Hard",
    "topic": "Advanced Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Dijkstra's Algorithm",
            "description": "Use Dijkstra's algorithm to find path with min max elevation.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define swimInWater.",
                    "placeholderCode": "def swimInWater(grid):",
                    "validationRegex": "^def\\s+swimInWater\\(grid\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def swimInWater(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize.",
                    "placeholderCode": "    N = len(grid)\n    visit = set()\n    minH = [[grid[0][0], 0, 0]]\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visit.add((0, 0))",
                    "validationRegex": "^\\s+N\\s*=\\s*len\\(grid\\)\\s*visit\\s*=\\s*set\\(\\)\\s*minH\\s*=\\s*\\[\\[grid\\[0\\]\\[0\\],\\s*0,\\s*0\\]\\]\\s*directions\\s*=\\s*\\[\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\],\\s*\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\]\\]\\s*visit\\.add\\(\\(\\(0,\\s*0\\)\\)\\)$",
                    "hint": "Initialize a min-heap with the starting cell (0,0). The priority is the max elevation encountered so far on the path.",
                    "solutionCode": "    N = len(grid)\n    visit = set()\n    minH = [[grid[0][0], 0, 0]]\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visit.add((0, 0))"
                },
                {
                    "id": 3,
                    "instruction": "Run Dijkstra's.",
                    "placeholderCode": "    while minH:\n        t, r, c = heapq.heappop(minH)\n        if r == N - 1 and c == N - 1:\n            return t\n        for dr, dc in directions:\n            neiR, neiC = r + dr, c + dc\n            if (neiR < 0 or neiC < 0 or \n                neiR == N or neiC == N or\n                (neiR, neiC) in visit):\n                continue\n            visit.add((neiR, neiC))\n            heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])",
                    "validationRegex": "^\\s+while\\s+minH:\\s*t,\\s*r,\\s*c\\s*=\\s*heapq\\.heappop\\(minH\\)\\s*if\\s+r\\s*==\\s*N\\s*-\\s*1\\s+and\\s+c\\s*==\\s*N\\s*-\\s*1:\\s*return\\s+t\\s*for\\s+dr,\\s*dc\\s+in\\s+directions:\\s*neiR,\\s*neiC\\s*=\\s*r\\s*\\+\\s*dr,\\s*c\\s*\\+\\s*dc\\s*if\\s*\\(neiR\\s*<\\s*0\\s+or\\s+neiC\\s*<\\s*0\\s+or\\s+neiR\\s*==\\s*N\\s+or\\s+neiC\\s*==\\s*N\\s+or\\s*\\(neiR,\\s*neiC\\)\\s+in\\s+visit\\):\\s*continue\\s*visit\\.add\\(\\(\\(neiR,\\s*neiC\\)\\)\\)\\s*heapq\\.heappush\\(minH,\\s*\\[max\\(t,\\s*grid\\[neiR\\]\\[neiC\\]\\),\\s*neiR,\\s*neiC\\]\\)$",
                    "hint": "Pop the cell with the smallest max-elevation. If it's the target, return the time. Otherwise, explore neighbors, updating the max elevation for the path.\\n\\nExample:\\nGrid=[[0, 2], [1, 3]]. Start (0,0).\\nMinH=[(0, 0, 0)].\\nPop (0, 0, 0). MaxElev=0. Neighbors: (0,1) val 2, (1,0) val 1.\\nPush (2, 0, 1), (1, 1, 0).\\nPop (1, 1, 0). MaxElev=1. Neighbor: (1,1) val 3.\\nPush (3, 1, 1).\\nPop (2, 0, 1). MaxElev=2. Neighbor: (1,1) val 3.\\nPush (3, 1, 1).\\nPop (3, 1, 1). Target reached. Time=3.",
                    "solutionCode": "    while minH:\n        t, r, c = heapq.heappop(minH)\n        if r == N - 1 and c == N - 1:\n            return t\n        for dr, dc in directions:\n            neiR, neiC = r + dr, c + dc\n            if (neiR < 0 or neiC < 0 or \n                neiR == N or neiC == N or\n                (neiR, neiC) in visit):\n                continue\n            visit.add((neiR, neiC))\n            heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Dijkstra's Algorithm",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define swimInWater.",
                    "placeholderCode": "def swimInWater(grid):",
                    "validationRegex": "^def\\s+swimInWater\\(grid\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def swimInWater(grid):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize.",
                    "placeholderCode": "    N = len(grid)\n    visit = set()\n    minH = [[grid[0][0], 0, 0]]\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visit.add((0, 0))",
                    "validationRegex": "^\\s+N\\s*=\\s*len\\(grid\\)\\s*visit\\s*=\\s*set\\(\\)\\s*minH\\s*=\\s*\\[\\[grid\\[0\\]\\[0\\],\\s*0,\\s*0\\]\\]\\s*directions\\s*=\\s*\\[\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\],\\s*\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\]\\]\\s*visit\\.add\\(\\(\\(0,\\s*0\\)\\)\\)$",
                    "hint": "Initialize a min-heap with the starting cell (0,0). The priority is the max elevation encountered so far on the path.",
                    "solutionCode": "    N = len(grid)\n    visit = set()\n    minH = [[grid[0][0], 0, 0]]\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visit.add((0, 0))"
                },
                {
                    "id": 3,
                    "instruction": "Run Dijkstra's.",
                    "placeholderCode": "    while minH:\n        t, r, c = heapq.heappop(minH)\n        if r == N - 1 and c == N - 1:\n            return t\n        for dr, dc in directions:\n            neiR, neiC = r + dr, c + dc\n            if (neiR < 0 or neiC < 0 or \n                neiR == N or neiC == N or\n                (neiR, neiC) in visit):\n                continue\n            visit.add((neiR, neiC))\n            heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])",
                    "validationRegex": "^\\s+while\\s+minH:\\s*t,\\s*r,\\s*c\\s*=\\s*heapq\\.heappop\\(minH\\)\\s*if\\s+r\\s*==\\s*N\\s*-\\s*1\\s+and\\s+c\\s*==\\s*N\\s*-\\s*1:\\s*return\\s+t\\s*for\\s+dr,\\s*dc\\s+in\\s+directions:\\s*neiR,\\s*neiC\\s*=\\s*r\\s*\\+\\s*dr,\\s*c\\s*\\+\\s*dc\\s*if\\s*\\(neiR\\s*<\\s*0\\s+or\\s+neiC\\s*<\\s*0\\s+or\\s+neiR\\s*==\\s*N\\s+or\\s+neiC\\s*==\\s*N\\s+or\\s*\\(neiR,\\s*neiC\\)\\s+in\\s+visit\\):\\s*continue\\s*visit\\.add\\(\\(\\(neiR,\\s*neiC\\)\\)\\)\\s*heapq\\.heappush\\(minH,\\s*\\[max\\(t,\\s*grid\\[neiR\\]\\[neiC\\]\\),\\s*neiR,\\s*neiC\\]\\)$",
                    "hint": "Pop the cell with the smallest max-elevation. If it's the target, return the time. Otherwise, explore neighbors, updating the max elevation for the path.\\n\\nExample:\\nGrid=[[0, 2], [1, 3]]. Start (0,0).\\nMinH=[(0, 0, 0)].\\nPop (0, 0, 0). MaxElev=0. Neighbors: (0,1) val 2, (1,0) val 1.\\nPush (2, 0, 1), (1, 1, 0).\\nPop (1, 1, 0). MaxElev=1. Neighbor: (1,1) val 3.\\nPush (3, 1, 1).\\nPop (2, 0, 1). MaxElev=2. Neighbor: (1,1) val 3.\\nPush (3, 1, 1).\\nPop (3, 1, 1). Target reached. Time=3.",
                    "solutionCode": "    while minH:\n        t, r, c = heapq.heappop(minH)\n        if r == N - 1 and c == N - 1:\n            return t\n        for dr, dc in directions:\n            neiR, neiC = r + dr, c + dc\n            if (neiR < 0 or neiC < 0 or \n                neiR == N or neiC == N or\n                (neiR, neiC) in visit):\n                continue\n            visit.add((neiR, neiC))\n            heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])"
                }
            ]
        }
    }
}