{
    "id": "valid-sudoku",
    "title": "Valid Sudoku",
    "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated.",
    "examples": [
        {
            "input": "board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
            "output": "true"
        },
        {
            "input": "board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
            "output": "false",
            "explanation": "Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid."
        }
    ],
    "constraints": [
        "board.length == 9",
        "board[i].length == 9",
        "board[i][j] is a digit 1-9 or '.'."
    ],
    "difficulty": "Medium",
    "topic": "Arrays & Hashing",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "HashSet",
            "description": "Use sets to track seen numbers in rows, cols, and boxes.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function is_valid_sudoku that takes board.",
                    "placeholderCode": "def is_valid_sudoku(board):",
                    "validationRegex": "^def\\s+is_valid_sudoku\\(board\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def is_valid_sudoku(board):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize sets.",
                    "placeholderCode": "    cols = collections.defaultdict(set)\n    rows = collections.defaultdict(set)\n    squares = collections.defaultdict(set)",
                    "validationRegex": "^\\s+cols\\s*=\\s*collections\\.defaultdict\\(set\\)\\s*rows\\s*=\\s*collections\\.defaultdict\\(set\\)\\s*squares\\s*=\\s*collections\\.defaultdict\\(set\\)$",
                    "hint": "Use `collections.defaultdict(set)` for rows, cols, and squares.",
                    "solutionCode": "    cols = collections.defaultdict(set)\n    rows = collections.defaultdict(set)\n    squares = collections.defaultdict(set)"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through board.",
                    "placeholderCode": "    for r in range(9):\n        for c in range(9):\n            if board[r][c] == \".\":\n                continue\n            if (board[r][c] in rows[r] or\n                board[r][c] in cols[c] or\n                board[r][c] in squares[(r // 3, c // 3)]):\n                return False\n            cols[c].add(board[r][c])\n            rows[r].add(board[r][c])\n            squares[(r // 3, c // 3)].add(board[r][c])",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(9\\):\\s*for\\s+c\\s+in\\s+range\\(9\\):\\s*if\\s+board\\[r\\]\\[c\\]\\s*==\\s*\".\":\\s*continue\\s*if\\s*\\(board\\[r\\]\\[c\\]\\s+in\\s+rows\\[r\\]\\s+or\\s*board\\[r\\]\\[c\\]\\s+in\\s+cols\\[c\\]\\s+or\\s*board\\[r\\]\\[c\\]\\s+in\\s+squares\\[\\(r\\s*//\\s*3,\\s*c\\s*//\\s*3\\)\\]\\):\\s*return\\s+False\\s*cols\\[c\\]\\.add\\(board\\[r\\]\\[c\\]\\)\\s*rows\\[r\\]\\.add\\(board\\[r\\]\\[c\\]\\)\\s*squares\\[\\(r\\s*//\\s*3,\\s*c\\s*//\\s*3\\)\\]\\.add\\(board\\[r\\]\\[c\\]\\)$",
                    "hint": "Check if current number is already in respective row, col, or square set. Use `(r // 3, c // 3)` for square key.",
                    "solutionCode": "    for r in range(9):\n        for c in range(9):\n            if board[r][c] == \".\":\n                continue\n            if (board[r][c] in rows[r] or\n                board[r][c] in cols[c] or\n                board[r][c] in squares[(r // 3, c // 3)]):\n                return False\n            cols[c].add(board[r][c])\n            rows[r].add(board[r][c])\n            squares[(r // 3, c // 3)].add(board[r][c])"
                },
                {
                    "id": 4,
                    "instruction": "Return True.",
                    "placeholderCode": "    return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "Return `True` if no conflicts found.",
                    "solutionCode": "    return True"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "HashSet",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function is_valid_sudoku that takes board.",
                    "placeholderCode": "def is_valid_sudoku(board):",
                    "validationRegex": "^def\\s+is_valid_sudoku\\(board\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def is_valid_sudoku(board):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the dictionary for tracking columns.",
                    "placeholderCode": "    cols = collections.defaultdict(set)",
                    "validationRegex": "^\\s+cols\\s*=\\s*collections\\.defaultdict\\(set\\)$",
                    "hint": "Use `collections.defaultdict(set)` to store seen numbers for each column index.",
                    "solutionCode": "    cols = collections.defaultdict(set)"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the dictionary for tracking rows.",
                    "placeholderCode": "    rows = collections.defaultdict(set)",
                    "validationRegex": "^\\s+rows\\s*=\\s*collections\\.defaultdict\\(set\\)$",
                    "hint": "Similarly, create a defaultdict of sets to track numbers seen in each row.",
                    "solutionCode": "    rows = collections.defaultdict(set)"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the dictionary for tracking 3x3 squares.",
                    "placeholderCode": "    squares = collections.defaultdict(set)",
                    "validationRegex": "^\\s+squares\\s*=\\s*collections\\.defaultdict\\(set\\)$",
                    "hint": "Create one more defaultdict for the 3x3 sub-boxes. We will use `(r // 3, c // 3)` tuples as keys.",
                    "solutionCode": "    squares = collections.defaultdict(set)"
                },
                {
                    "id": 5,
                    "instruction": "Iterate through the rows of the board.",
                    "placeholderCode": "    for r in range(9):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(9\\):$",
                    "hint": "Start loops to visit every cell in the 9x9 grid.",
                    "solutionCode": "    for r in range(9):"
                },
                {
                    "id": 6,
                    "instruction": "Iterate through the columns of the board.",
                    "placeholderCode": "        for c in range(9):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(9\\):$",
                    "hint": "Nested loop to access `board[r][c]`.",
                    "solutionCode": "        for c in range(9):"
                },
                {
                    "id": 7,
                    "instruction": "Skip empty cells.",
                    "placeholderCode": "            if board[r][c] == \".\":\n                continue",
                    "validationRegex": "^\\s+if\\s+board\\[r\\]\\[c\\]\\s*==\\s*\".\":\\s*continue$",
                    "hint": "If the cell is a dot `.` it's empty, so we ignore it.",
                    "solutionCode": "            if board[r][c] == \".\":\n                continue"
                },
                {
                    "id": 8,
                    "instruction": "Calculate the 3x3 sub-grid key.",
                    "placeholderCode": "            grid_key = (r // 3, c // 3)",
                    "validationRegex": "^\\s+grid_key\\s*=\\s*\\(r\\s*//\\s*3,\\s*c\\s*//\\s*3\\)$",
                    "hint": "Determine which 3x3 block we are in. Row 0-2 -> 0, Row 3-5 -> 1. We create a tuple key like `(0, 1)`.",
                    "solutionCode": "            grid_key = (r // 3, c // 3)"
                },
                {
                    "id": 9,
                    "instruction": "Check for conflicts in rows, columns, or squares.",
                    "placeholderCode": "            if (board[r][c] in rows[r] or\n                board[r][c] in cols[c] or\n                board[r][c] in squares[grid_key]):\n                return False",
                    "validationRegex": "^\\s+if\\s*\\(board\\[r\\]\\[c\\]\\s+in\\s+rows\\[r\\]\\s+or\\s*board\\[r\\]\\[c\\]\\s+in\\s+cols\\[c\\]\\s+or\\s*board\\[r\\]\\[c\\]\\s+in\\s+squares\\[grid_key\\]\\):\\s*return\\s+False$",
                    "hint": "If the current number is ALREADY in our `rows`, `cols`, or `squares` sets, it's a duplicate! Sudoku invalid.",
                    "solutionCode": "            if (board[r][c] in rows[r] or\n                board[r][c] in cols[c] or\n                board[r][c] in squares[grid_key]):\n                return False"
                },
                {
                    "id": 10,
                    "instruction": "Add the number to the column tracking set.",
                    "placeholderCode": "            cols[c].add(board[r][c])",
                    "validationRegex": "^\\s+cols\\[c\\]\\.add\\(board\\[r\\]\\[c\\]\\)$",
                    "hint": "Mark this number as 'seen' in the current column.",
                    "solutionCode": "            cols[c].add(board[r][c])"
                },
                {
                    "id": 11,
                    "instruction": "Add the number to the row tracking set.",
                    "placeholderCode": "            rows[r].add(board[r][c])",
                    "validationRegex": "^\\s+rows\\[r\\]\\.add\\(board\\[r\\]\\[c\\]\\)$",
                    "hint": "Mark this number as 'seen' in the current row.",
                    "solutionCode": "            rows[r].add(board[r][c])"
                },
                {
                    "id": 12,
                    "instruction": "Add the number to the square tracking set.",
                    "placeholderCode": "            squares[grid_key].add(board[r][c])",
                    "validationRegex": "^\\s+squares\\[grid_key\\]\\.add\\(board\\[r\\]\\[c\\]\\)$",
                    "hint": "Mark this number as 'seen' in the current 3x3 block.",
                    "solutionCode": "            squares[grid_key].add(board[r][c])"
                },
                {
                    "id": 13,
                    "instruction": "Return True.",
                    "placeholderCode": "    return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "If we finish both loops without returning False, the board is valid.",
                    "solutionCode": "    return True"
                }
            ]
        }
    }
}