{
    "id": "subsets-ii",
    "title": "Subsets II",
    "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.",
    "examples": [
        {
            "input": "nums = [1,2,2]",
            "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]"
        },
        {
            "input": "nums = [0]",
            "output": "[[],[0]]"
        }
    ],
    "constraints": [
        "1 <= nums.length <= 10",
        "-10 <= nums[i] <= 10"
    ],
    "difficulty": "Medium",
    "topic": "Backtracking",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Generate all subsets and use a set to filter duplicates.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function subsets_with_dup that takes nums.",
                    "placeholderCode": "def subsets_with_dup(nums):",
                    "validationRegex": "^def\\\\s+subsets_with_dup\\\\(nums\\\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def subsets_with_dup(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Sort the input array to group duplicate elements.",
                    "placeholderCode": "    nums.sort()",
                    "validationRegex": "^\\\\s+nums\\\\.sort\\\\(\\\\)$",
                    "hint": "Sorting ensures that duplicates are adjacent, making them easier to handle.",
                    "solutionCode": "    nums.sort()"
                },
                {
                    "id": 3,
                    "instruction": "Initialize a set to store unique subsets as tuples.",
                    "placeholderCode": "    res = set()",
                    "validationRegex": "^\\\\s+res\\\\s*=\\\\s*set\\\\(\\\\)$",
                    "hint": "We use a set because it automatically handles duplicate entries.",
                    "solutionCode": "    res = set()"
                },
                {
                    "id": 4,
                    "instruction": "Define the recursive dfs function signature.",
                    "placeholderCode": "    def dfs(i, subset):",
                    "validationRegex": "^\\\\s+def\\\\s+dfs\\\\(i,\\\\s*subset\\\\):$",
                    "hint": "The function explores each branch of the decision tree.",
                    "solutionCode": "    def dfs(i, subset):"
                },
                {
                    "id": 5,
                    "instruction": "Add a base case to check if all elements have been processed.",
                    "placeholderCode": "        if i == len(nums):",
                    "validationRegex": "^\\\\s+if\\\\s+i\\\\s*==\\\\s+len\\\\(nums\\\\):$",
                    "hint": "Check if index i has reached the length of the input list.",
                    "solutionCode": "        if i == len(nums):"
                },
                {
                    "id": 6,
                    "instruction": "Add a tuple version of the current subset to the result set.",
                    "placeholderCode": "            res.add(tuple(subset))",
                    "validationRegex": "^\\\\s+res\\\\.add\\\\(tuple\\\\(subset\\\\)\\\\)$",
                    "hint": "Tuples are hashable and can be stored in a set to identify duplicates.",
                    "solutionCode": "            res.add(tuple(subset))"
                },
                {
                    "id": 7,
                    "instruction": "Return from the function after adding the subset.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\\\s+return$",
                    "hint": "Exit the current recursive call.",
                    "solutionCode": "            return"
                },
                {
                    "id": 8,
                    "instruction": "Include nums[i], recurse, then backtrack.",
                    "placeholderCode": "        subset.append(nums[i])\n        dfs(i + 1, subset)\n        subset.pop()",
                    "validationRegex": "^\\\\s+subset\\\\.append\\\\(nums\\\\[i\\\\]\\\\)\\\\s+dfs\\\\(i\\\\s*\\\\+\\\\s*1,\\\\s*subset\\\\)\\\\s+subset\\\\.pop\\\\(\\\\)$",
                    "hint": "Include current number, recurse, then backtrack.",
                    "solutionCode": "        subset.append(nums[i])\n        dfs(i + 1, subset)\n        subset.pop()"
                },
                {
                    "id": 9,
                    "instruction": "Recurse for the exclusion case.",
                    "placeholderCode": "        dfs(i + 1, subset)",
                    "validationRegex": "^\\\\s+dfs\\\\(i\\\\s*\\\\+\\\\s*1,\\\\s*subset\\\\)$",
                    "hint": "Move to the next element without including the current one.",
                    "solutionCode": "        dfs(i + 1, subset)"
                },
                {
                    "id": 10,
                    "instruction": "Call dfs and return list of lists.",
                    "placeholderCode": "    dfs(0, [])\n    return [list(s) for s in res]",
                    "validationRegex": "^\\\\s+dfs\\\\(0,\\\\s*\\\\[\\\\]\\\\)\\\\s*return\\\\s+\\\\[list\\\\(s\\\\)\\\\s+for\\\\s+s\\\\s+in\\\\s+res\\\\]$",
                    "hint": "Start DFS and convert set of tuples back to list of lists.",
                    "solutionCode": "    dfs(0, [])\n    return [list(s) for s in res]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Skip duplicates during recursion.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function subsets_with_dup that takes nums.",
                    "placeholderCode": "def subsets_with_dup(nums):",
                    "validationRegex": "^def\\\\s+subsets_with_dup\\\\(nums\\\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def subsets_with_dup(nums):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result list for storing subsets.",
                    "placeholderCode": "    res = []",
                    "validationRegex": "^\\\\s+res\\\\s*=\\s*\\\\[\\\\]$",
                    "hint": "This list will store all unique subsets found.",
                    "solutionCode": "    res = []"
                },
                {
                    "id": 3,
                    "instruction": "Sort the input array to handle duplicate numbers.",
                    "placeholderCode": "    nums.sort()",
                    "validationRegex": "^\\\\s+nums\\\\.sort\\\\(\\\\)$",
                    "hint": "Sorting makes duplicates appear next to each other, allowing us to skip them.",
                    "solutionCode": "    nums.sort()"
                },
                {
                    "id": 4,
                    "instruction": "Define the recursive dfs function signature.",
                    "placeholderCode": "    def dfs(i, subset):",
                    "validationRegex": "^\\\\s+def\\\\s+dfs\\\\(i,\\\\s*subset\\\\):$",
                    "hint": "This function takes the current index and the building subset.",
                    "solutionCode": "    def dfs(i, subset):"
                },
                {
                    "id": 5,
                    "instruction": "Add a base case to check if all elements have been processed.",
                    "placeholderCode": "        if i == len(nums):",
                    "validationRegex": "^\\\\s+if\\\\s+i\\\\s*==\\\\s+len\\\\(nums\\\\):$",
                    "hint": "When the index reaches the length of nums, a complete subset is formed.",
                    "solutionCode": "        if i == len(nums):"
                },
                {
                    "id": 6,
                    "instruction": "Inside the base case, append a copy of the current subset to the result list.",
                    "placeholderCode": "            res.append(subset.copy())",
                    "validationRegex": "^\\\\s+res\\\\.append\\\\(subset\\\\.copy\\\\(\\\\)\\\\)$",
                    "hint": "Copying is necessary because the subset is mutated later.",
                    "solutionCode": "            res.append(subset.copy())"
                },
                {
                    "id": 7,
                    "instruction": "Return from the function.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\\\s+return$",
                    "hint": "Stop the recursion for this branch.",
                    "solutionCode": "            return"
                },
                {
                    "id": 8,
                    "instruction": "Include nums[i], recurse, then backtrack.",
                    "placeholderCode": "        subset.append(nums[i])\n        dfs(i + 1, subset)\n        subset.pop()",
                    "validationRegex": "^\\\\s+subset\\\\.append\\\\(nums\\\\[i\\\\]\\\\)\\\\s+dfs\\\\(i\\\\s*\\\\+\\\\s*1,\\\\s*subset\\\\)\\\\s*subset\\\\.pop\\\\(\\\\)$",
                    "hint": "Include current number, recurse, then backtrack.",
                    "solutionCode": "        subset.append(nums[i])\n        dfs(i + 1, subset)\n        subset.pop()"
                },
                {
                    "id": 9,
                    "instruction": "Skip duplicates and exclude nums[i].",
                    "placeholderCode": "        while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n            i += 1\n        dfs(i + 1, subset)",
                    "validationRegex": "^\\\\s+while\\\\s+i\\\\s*\\\\+\\\\s*1\\\\s*<\\\\s+len\\\\(nums\\\\)\\\\s+and\\\\s+nums\\\\[i\\\\]\\\\s*==\\\\s+nums\\\\[i\\\\s*\\\\+\\\\s*1\\\\]:\\\\s*i\\\\s*\\\\+=\\\\s*1\\\\s+dfs\\\\(i\\\\s*\\\\+\\\\s*1,\\\\s*subset\\\\)$",
                    "hint": "Skip adjacent duplicates to avoid duplicate subsets, then recurse.",
                    "solutionCode": "        while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n            i += 1\n        dfs(i + 1, subset)"
                },
                {
                    "id": 10,
                    "instruction": "Call dfs and return result.",
                    "placeholderCode": "    dfs(0, [])\n    return res",
                    "validationRegex": "^\\\\s+dfs\\\\(0,\\\\s*\\\\[\\\\]\\\\)\\\\s*return\\\\s+res$",
                    "hint": "Start DFS from index 0.",
                    "solutionCode": "    dfs(0, [])\n    return res"
                }
            ]
        }
    }
}