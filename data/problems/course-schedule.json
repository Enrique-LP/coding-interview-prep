{
    "id": "course-schedule",
    "title": "Course Schedule",
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. Return true if you can finish all courses. Otherwise, return false.",
    "examples": [
        {
            "input": "numCourses = 2, prerequisites = [[1,0]]",
            "output": "true"
        },
        {
            "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
            "output": "false"
        }
    ],
    "constraints": [
        "1 <= numCourses <= 2000",
        "0 <= prerequisites.length <= 5000",
        "prerequisites[i].length == 2",
        "0 <= ai, bi < numCourses",
        "All the pairs prerequisites[i] are unique."
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Detect cycle in directed graph using DFS.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function can_finish that takes numCourses and prerequisites.",
                    "placeholderCode": "def can_finish(numCourses, prerequisites):",
                    "validationRegex": "^def\\s+can_finish\\(numCourses,\\s*prerequisites\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def can_finish(numCourses, prerequisites):"
                },
                {
                    "id": 2,
                    "instruction": "Build adjacency list.",
                    "placeholderCode": "    preMap = {i: [] for i in range(numCourses)}\n    for crs, pre in prerequisites:\n        preMap[crs].append(pre)",
                    "validationRegex": "^\\s+preMap\\s*=\\s*\\{i:\\s*\\[\\]\\s+for\\s+i\\s+in\\s+range\\(numCourses\\)\\}\\s*for\\s+crs,\\s*pre\\s+in\\s+prerequisites:\\s*preMap\\[crs\\]\\.append\\(pre\\)$",
                    "hint": "Create a dictionary mapping each course to its prerequisites.",
                    "solutionCode": "    preMap = {i: [] for i in range(numCourses)}\n    for crs, pre in prerequisites:\n        preMap[crs].append(pre)"
                },
                {
                    "id": 3,
                    "instruction": "Initialize visit set for current path.",
                    "placeholderCode": "    visitSet = set()",
                    "validationRegex": "^\\s+visitSet\\s*=\\s*set\\(\\)$",
                    "hint": "Use a set to keep track of visited nodes in the current DFS path to detect cycles.",
                    "solutionCode": "    visitSet = set()"
                },
                {
                    "id": 4,
                    "instruction": "Define DFS helper.",
                    "placeholderCode": "    def dfs(crs):\n        if crs in visitSet:\n            return False\n        if preMap[crs] == []:\n            return True\n        visitSet.add(crs)\n        for pre in preMap[crs]:\n            if not dfs(pre): return False\n        visitSet.remove(crs)\n        preMap[crs] = []\n        return True",
                    "validationRegex": "^\\s+def\\s+dfs\\(crs\\):\\s*if\\s+crs\\s+in\\s+visitSet:\\s*return\\s+False\\s*if\\s+preMap\\[crs\\]\\s*==\\s*\\[\\]:\\s*return\\s+True\\s*visitSet\\.add\\(crs\\)\\s*for\\s+pre\\s+in\\s+preMap\\[crs\\]:\\s*if\\s+not\\s+dfs\\(pre\\):\\s*return\\s+False\\s*visitSet\\.remove\\(crs\\)\\s*preMap\\[crs\\]\\s*=\\s*\\[\\]\\s*return\\s+True$",
                    "hint": "Recursive DFS. If node in current path, cycle detected (return False). If no prereqs, return True. Add to path, recurse, remove from path.",
                    "solutionCode": "    def dfs(crs):\n        if crs in visitSet:\n            return False\n        if preMap[crs] == []:\n            return True\n        visitSet.add(crs)\n        for pre in preMap[crs]:\n            if not dfs(pre): return False\n        visitSet.remove(crs)\n        preMap[crs] = []\n        return True"
                },
                {
                    "id": 5,
                    "instruction": "Run DFS on all courses.",
                    "placeholderCode": "    for crs in range(numCourses):\n        if not dfs(crs): return False",
                    "validationRegex": "^\\s+for\\s+crs\\s+in\\s+range\\(numCourses\\):\\s*if\\s+not\\s+dfs\\(crs\\):\\s*return\\s+False$",
                    "hint": "Iterate through all courses and run DFS. If any returns False, return False.",
                    "solutionCode": "    for crs in range(numCourses):\n        if not dfs(crs): return False"
                },
                {
                    "id": 6,
                    "instruction": "Return True if no cycle detected.",
                    "placeholderCode": "    return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "If loop completes without finding a cycle, return True.",
                    "solutionCode": "    return True"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Same as brute force, O(V+E).",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function can_finish that takes numCourses and prerequisites.",
                    "placeholderCode": "def can_finish(numCourses, prerequisites):",
                    "validationRegex": "^def\\s+can_finish\\(numCourses,\\s*prerequisites\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def can_finish(numCourses, prerequisites):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the adjacency list with an empty list for each course.",
                    "placeholderCode": "    preMap = {i: [] for i in range(numCourses)}",
                    "validationRegex": "^\\s+preMap\\s*=\\s*\\{i:\\s*\\[\\]\\s+for\\s+i\\s+in\\s+range\\(numCourses\\)\\}$",
                    "hint": "Create a dictionary mapping each course to its prerequisites.",
                    "solutionCode": "    preMap = {i: [] for i in range(numCourses)}"
                },
                {
                    "id": 3,
                    "instruction": "Iterate through each pair of (course, prerequisite) in the input list.",
                    "placeholderCode": "    for crs, pre in prerequisites:",
                    "validationRegex": "^\\s+for\\s+crs,\\s*pre\\s+in\\s+prerequisites:$",
                    "hint": "Use a for loop to process each requirement.",
                    "solutionCode": "    for crs, pre in prerequisites:"
                },
                {
                    "id": 4,
                    "instruction": "Add the prerequisite to the corresponding course's list in the map.",
                    "placeholderCode": "        preMap[crs].append(pre)",
                    "validationRegex": "^\\s+preMap\\[crs\\]\\.append\\(pre\\)$",
                    "hint": "Build the neighbor relationship in the graph.",
                    "solutionCode": "        preMap[crs].append(pre)"
                },
                {
                    "id": 5,
                    "instruction": "Initialize visit set for current path.",
                    "placeholderCode": "    visitSet = set()",
                    "validationRegex": "^\\s+visitSet\\s*=\\s*set\\(\\)$",
                    "hint": "Use a set to keep track of visited nodes in the current DFS path to detect cycles.",
                    "solutionCode": "    visitSet = set()"
                },
                {
                    "id": 6,
                    "instruction": "Define a DFS helper function to detect cycles.",
                    "placeholderCode": "    def dfs(crs):",
                    "validationRegex": "^\\s+def\\s+dfs\\(crs\\):$",
                    "hint": "Start the recursive function definition.",
                    "solutionCode": "    def dfs(crs):"
                },
                {
                    "id": 7,
                    "instruction": "Check if the course is already in the current visit path.",
                    "placeholderCode": "        if crs in visitSet:",
                    "validationRegex": "^\\s+if\\s+crs\\s+in\\s+visitSet:$",
                    "hint": "A cycle is detected if we revisit a node in the same recursion path.",
                    "solutionCode": "        if crs in visitSet:"
                },
                {
                    "id": 8,
                    "instruction": "Return False if a cycle is detected.",
                    "placeholderCode": "            return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "Stop the recursion because the schedule is impossible.",
                    "solutionCode": "            return False"
                },
                {
                    "id": 9,
                    "instruction": "Check if the course has no prerequisites or has been processed.",
                    "placeholderCode": "        if preMap[crs] == []:",
                    "validationRegex": "^\\s+if\\s+preMap\\[crs\\]\\s*==\\s*\\[\\]:$",
                    "hint": "This acts as our base case and memoization check.",
                    "solutionCode": "        if preMap[crs] == []:"
                },
                {
                    "id": 10,
                    "instruction": "Return True if the course is safely completable.",
                    "placeholderCode": "            return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "No prerequisites mean this course can be taken.",
                    "solutionCode": "            return True"
                },
                {
                    "id": 11,
                    "instruction": "Add the course to the current visit set.",
                    "placeholderCode": "        visitSet.add(crs)",
                    "validationRegex": "^\\s+visitSet\\.add\\(crs\\)$",
                    "hint": "Mark the node as part of the current path.",
                    "solutionCode": "        visitSet.add(crs)"
                },
                {
                    "id": 12,
                    "instruction": "Iterate through each prerequisite of the current course.",
                    "placeholderCode": "        for pre in preMap[crs]:",
                    "validationRegex": "^\\s+for\\s+pre\\s+in\\s+preMap\\[crs\\]:$",
                    "hint": "Use a for loop to check all dependencies.",
                    "solutionCode": "        for pre in preMap[crs]:"
                },
                {
                    "id": 13,
                    "instruction": "Recursively check if the prerequisite can be completed.",
                    "placeholderCode": "            if not dfs(pre):",
                    "validationRegex": "^\\s+if\\s+not\\s+dfs\\(pre\\):$",
                    "hint": "Call the DFS function for the dependency.",
                    "solutionCode": "            if not dfs(pre):"
                },
                {
                    "id": 14,
                    "instruction": "Return False if any dependency contains a cycle.",
                    "placeholderCode": "                return False",
                    "validationRegex": "^\\s+return\\s+False$",
                    "hint": "Propagate the cycle detection upwards.",
                    "solutionCode": "                return False"
                },
                {
                    "id": 15,
                    "instruction": "Remove the course from the visit set after processing.",
                    "placeholderCode": "        visitSet.remove(crs)",
                    "validationRegex": "^\\s+visitSet\\.remove\\(crs\\)$",
                    "hint": "Backtrack by clearing the course from the current path.",
                    "solutionCode": "        visitSet.remove(crs)"
                },
                {
                    "id": 16,
                    "instruction": "Clear prerequisites (memoization) and return True.",
                    "placeholderCode": "        preMap[crs] = []\n        return True",
                    "validationRegex": "^\\s+preMap\\[crs\\]\\s*=\\s*\\[\\]\\s*return\\s+True$",
                    "hint": "Empty the prerequisite list so we don't process this course again.",
                    "solutionCode": "        preMap[crs] = []\n        return True"
                },
                {
                    "id": 17,
                    "instruction": "Run DFS on all courses.",
                    "placeholderCode": "    for crs in range(numCourses):\n        if not dfs(crs): return False",
                    "validationRegex": "^\\s+for\\s+crs\\s+in\\s+range\\(numCourses\\):\\s*if\\s+not\\s+dfs\\(crs\\):\\s*return\\s+False$",
                    "hint": "Iterate through all courses and run DFS. If any returns False, return False.",
                    "solutionCode": "    for crs in range(numCourses):\n        if not dfs(crs): return False"
                },
                {
                    "id": 18,
                    "instruction": "Return True if no cycle detected.",
                    "placeholderCode": "    return True",
                    "validationRegex": "^\\s+return\\s+True$",
                    "hint": "If loop completes without finding a cycle, return True.",
                    "solutionCode": "    return True"
                }
            ]
        }
    }
}