{
    "id": "walls-and-gates",
    "title": "Walls and Gates",
    "description": "You are given an m x n grid rooms initialized with these three possible values:\n-1 A wall or an obstacle.\n0 A gate.\nINF Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.",
    "examples": [
        {
            "input": "rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]",
            "output": "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]"
        },
        {
            "input": "rooms = [[-1]]",
            "output": "[[-1]]"
        }
    ],
    "constraints": [
        "m == rooms.length",
        "n == rooms[i].length",
        "1 <= m, n <= 250",
        "rooms[i][j] is -1, 0, or 2^31 - 1."
    ],
    "difficulty": "Medium",
    "topic": "Graphs",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "BFS from Gates",
            "description": "Run BFS starting from all gates simultaneously.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function walls_and_gates that takes rooms.",
                    "placeholderCode": "def walls_and_gates(rooms):",
                    "validationRegex": "^def\\s+walls_and_gates\\(rooms\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def walls_and_gates(rooms):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize queue with all gates.",
                    "placeholderCode": "    ROWS, COLS = len(rooms), len(rooms[0])\n    q = collections.deque()\n    visit = set()\n    for r in range(ROWS):\n        for c in range(COLS):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visit.add((r, c))",
                    "validationRegex": "^\\s+ROWS,\\s*COLS\\s*=\\s*len\\(rooms\\),\\s*len\\(rooms\\[0\\]\\)\\s*q\\s*=\\s*collections\\.deque\\(\\)\\s*visit\\s*=\\s*set\\(\\)\\s*for\\s+r\\s+in\\s+range\\(ROWS\\):\\s*for\\s+c\\s+in\\s+range\\(COLS\\):\\s*if\\s+rooms\\[r\\]\\[c\\]\\s*==\\s*0:\\s*q\\.append\\(\\(r,\\s*c\\)\\)\\s*visit\\.add\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Find all gates (0) and add them to the queue. Mark them as visited.",
                    "solutionCode": "    ROWS, COLS = len(rooms), len(rooms[0])\n    q = collections.deque()\n    visit = set()\n    for r in range(ROWS):\n        for c in range(COLS):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visit.add((r, c))"
                },
                {
                    "id": 3,
                    "instruction": "Run BFS.",
                    "placeholderCode": "    dist = 0\n    while q:\n        for i in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:\n                row, col = r + dr, c + dc\n                if (row < 0 or col < 0 or row == ROWS or col == COLS or\n                    (row, col) in visit or rooms[row][col] == -1):\n                    continue\n                visit.add((row, col))\n                q.append((row, col))\n        dist += 1",
                    "validationRegex": "^\\s+dist\\s*=\\s*0\\s*while\\s+q:\\s*for\\s+i\\s+in\\s+range\\(len\\(q\\)\\):\\s*r,\\s*c\\s*=\\s*q\\.popleft\\(\\)\\s*rooms\\[r\\]\\[c\\]\\s*=\\s*dist\\s*directions\\s*=\\s*\\[\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\],\\s*\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\]\\]\\s*for\\s+dr,\\s*dc\\s+in\\s+directions:\\s*row,\\s*col\\s*=\\s*r\\s*\\+\\s*dr,\\s*c\\s*\\+\\s*dc\\s*if\\s*\\(row\\s*<\\s*0\\s+or\\s+col\\s*<\\s*0\\s+or\\s+row\\s*==\\s*ROWS\\s+or\\s+col\\s*==\\s*COLS\\s+or\\s*\\(row,\\s*col\\)\\s+in\\s+visit\\s+or\\s+rooms\\[row\\]\\[col\\]\\s*==\\s*-1\\):\\s*continue\\s*visit\\.add\\(\\(row,\\s*col\\)\\)\\s*q\\.append\\(\\(row,\\s*col\\)\\)\\s*dist\\s*\\+=\\s*1$",
                    "hint": "Process level by level. Update distance. Explore neighbors. If valid and not visited/wall, add to queue.\\n\\nExample:\\nGate at (0,0). INF at (0,1).\\nQ=[(0,0)]. Dist=0.\\nPop (0,0). Neighbor (0,1) is INF. Update (0,1)=1. Add (0,1) to Q.\\nDist increases to 1.",
                    "solutionCode": "    dist = 0\n    while q:\n        for i in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:\n                row, col = r + dr, c + dc\n                if (row < 0 or col < 0 or row == ROWS or col == COLS or\n                    (row, col) in visit or rooms[row][col] == -1):\n                    continue\n                visit.add((row, col))\n                q.append((row, col))\n        dist += 1"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "BFS from Gates",
            "description": "Same as brute force.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function walls_and_gates that takes rooms.",
                    "placeholderCode": "def walls_and_gates(rooms):",
                    "validationRegex": "^def\\s+walls_and_gates\\(rooms\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def walls_and_gates(rooms):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize queue with all gates.",
                    "placeholderCode": "    ROWS, COLS = len(rooms), len(rooms[0])\n    q = collections.deque()\n    visit = set()\n    for r in range(ROWS):\n        for c in range(COLS):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visit.add((r, c))",
                    "validationRegex": "^\\s+ROWS,\\s*COLS\\s*=\\s*len\\(rooms\\),\\s*len\\(rooms\\[0\\]\\)\\s*q\\s*=\\s*collections\\.deque\\(\\)\\s*visit\\s*=\\s*set\\(\\)\\s*for\\s+r\\s+in\\s+range\\(ROWS\\):\\s*for\\s+c\\s+in\\s+range\\(COLS\\):\\s*if\\s+rooms\\[r\\]\\[c\\]\\s*==\\s*0:\\s*q\\.append\\(\\(r,\\s*c\\)\\)\\s*visit\\.add\\(\\(r,\\s*c\\)\\)$",
                    "hint": "Find all gates (0) and add them to the queue. Mark them as visited.",
                    "solutionCode": "    ROWS, COLS = len(rooms), len(rooms[0])\n    q = collections.deque()\n    visit = set()\n    for r in range(ROWS):\n        for c in range(COLS):\n            if rooms[r][c] == 0:\n                q.append((r, c))\n                visit.add((r, c))"
                },
                {
                    "id": 3,
                    "instruction": "Run BFS.",
                    "placeholderCode": "    dist = 0\n    while q:\n        for i in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:\n                row, col = r + dr, c + dc\n                if (row < 0 or col < 0 or row == ROWS or col == COLS or\n                    (row, col) in visit or rooms[row][col] == -1):\n                    continue\n                visit.add((row, col))\n                q.append((row, col))\n        dist += 1",
                    "validationRegex": "^\\s+dist\\s*=\\s*0\\s*while\\s+q:\\s*for\\s+i\\s+in\\s+range\\(len\\(q\\)\\):\\s*r,\\s*c\\s*=\\s*q\\.popleft\\(\\)\\s*rooms\\[r\\]\\[c\\]\\s*=\\s*dist\\s*directions\\s*=\\s*\\[\\[1,\\s*0\\],\\s*\\[-1,\\s*0\\],\\s*\\[0,\\s*1\\],\\s*\\[0,\\s*-1\\]\\]\\s*for\\s+dr,\\s*dc\\s+in\\s+directions:\\s*row,\\s*col\\s*=\\s*r\\s*\\+\\s*dr,\\s*c\\s*\\+\\s*dc\\s*if\\s*\\(row\\s*<\\s*0\\s+or\\s+col\\s*<\\s*0\\s+or\\s+row\\s*==\\s*ROWS\\s+or\\s+col\\s*==\\s*COLS\\s+or\\s*\\(row,\\s*col\\)\\s+in\\s+visit\\s+or\\s+rooms\\[row\\]\\[col\\]\\s*==\\s*-1\\):\\s*continue\\s*visit\\.add\\(\\(row,\\s*col\\)\\)\\s*q\\.append\\(\\(row,\\s*col\\)\\)\\s*dist\\s*\\+=\\s*1$",
                    "hint": "Process level by level. Update distance. Explore neighbors. If valid and not visited/wall, add to queue.\\n\\nExample:\\nGate at (0,0). INF at (0,1).\\nQ=[(0,0)]. Dist=0.\\nPop (0,0). Neighbor (0,1) is INF. Update (0,1)=1. Add (0,1) to Q.\\nDist increases to 1.",
                    "solutionCode": "    dist = 0\n    while q:\n        for i in range(len(q)):\n            r, c = q.popleft()\n            rooms[r][c] = dist\n            directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n            for dr, dc in directions:\n                row, col = r + dr, c + dc\n                if (row < 0 or col < 0 or row == ROWS or col == COLS or\n                    (row, col) in visit or rooms[row][col] == -1):\n                    continue\n                visit.add((row, col))\n                q.append((row, col))\n        dist += 1"
                }
            ]
        }
    }
}