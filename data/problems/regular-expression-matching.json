{
    "id": "regular-expression-matching",
    "title": "Regular Expression Matching",
    "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where: '.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial).",
    "examples": [
        {
            "input": "s = \"aa\", p = \"a\"",
            "output": "false",
            "explanation": "\"a\" does not match the entire string \"aa\"."
        },
        {
            "input": "s = \"aa\", p = \"a*\"",
            "output": "true",
            "explanation": "'*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\"."
        },
        {
            "input": "s = \"ab\", p = \".*\"",
            "output": "true",
            "explanation": "\".*\" means \"zero or more (*) of any character (.)\"."
        }
    ],
    "constraints": [
        "1 <= s.length <= 20",
        "1 <= p.length <= 30",
        "s contains only lowercase English letters.",
        "p contains only lowercase English letters, '.', and '*'.",
        "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
    ],
    "difficulty": "Hard",
    "topic": "2-D Dynamic Programming",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Recursively check for matches using memoization to handle the overlapping subproblems efficiently.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function is_match that takes strings s and p.",
                    "placeholderCode": "def is_match(s, p):",
                    "validationRegex": "^def\\s+is_match\\(s,\\s*p\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def is_match(s, p):"
                },
                {
                    "id": 2,
                    "instruction": "Define a recursive helper function with a memoization dictionary to store the results of subproblems.",
                    "placeholderCode": "    memo = {}\n    def dfs(i, j):\n        if (i, j) in memo: return memo[(i, j)]\n        if j == len(p): return i == len(s)",
                    "validationRegex": "^\\s+memo\\s*=\\s*\\{\\}\\s*def\\s+dfs\\(i,\\s*j\\):\\s*if\\s*\\(i,\\s*j\\)\\s+in\\s+memo:\\s*return\\s+memo\\[\\(i,\\s*j\\)\\]\\s*if\\s+j\\s*==\\s*len\\(p\\):\\s*return\\s+i\\s*==\\s*len\\(s\\)$",
                    "hint": "Check memo and base case (pattern exhausted).",
                    "solutionCode": "    memo = {}\n    def dfs(i, j):\n        if (i, j) in memo: return memo[(i, j)]\n        if j == len(p): return i == len(s)"
                },
                {
                    "id": 3,
                    "instruction": "Determine if the current characters from string s and pattern p match.",
                    "placeholderCode": "        first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')",
                    "validationRegex": "^\\s+first_match\\s*=\\s*i\\s*<\\s+len\\(s\\)\\s+and\\s*\\(p\\[j\\]\\s*==\\s+s\\[i\\]\\s+or\\s+p\\[j\\]\\s*==\\s*'.'\\)$",
                    "hint": "A match occurs if chars are equal or pattern char is '.'.",
                    "solutionCode": "        first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')"
                },
                {
                    "id": 4,
                    "instruction": "Handle the case where the next character in the pattern is a '*' wildcard, allowing for zero or more occurrences.",
                    "placeholderCode": "        if j + 1 < len(p) and p[j + 1] == '*':\n            ans = dfs(i, j + 2) or (first_match and dfs(i + 1, j))\n        else:\n            ans = first_match and dfs(i + 1, j + 1)",
                    "validationRegex": "^\\s+if\\s+j\\s*\\+\\s*1\\s*<\\s+len\\(p\\)\\s+and\\s+p\\[j\\s*\\+\\s*1\\]\\s*==\\s*'*':\\s*ans\\s*=\\s*dfs\\(i,\\s*j\\s*\\+\\s*2\\)\\s+or\\s*\\(first_match\\s+and\\s+dfs\\(i\\s*\\+\\s*1,\\s*j\\)\\)\\s*else:\\s*ans\\s*=\\s*first_match\\s+and\\s+dfs\\(i\\s*\\+\\s*1,\\s*j\\s*\\+\\s*1\\)$",
                    "hint": "If next char is '*', either skip '*' (j+2) or use '*' (match s[i] and recurse i+1). Else, match char and recurse i+1, j+1.",
                    "solutionCode": "        if j + 1 < len(p) and p[j + 1] == '*':\n            ans = dfs(i, j + 2) or (first_match and dfs(i + 1, j))\n        else:\n            ans = first_match and dfs(i + 1, j + 1)"
                },
                {
                    "id": 5,
                    "instruction": "Store the result in the memoization dictionary and return it.",
                    "placeholderCode": "        memo[(i, j)] = ans\n        return ans",
                    "validationRegex": "^\\s+memo\\[\\(i,\\s*j\\)\\]\\s*=\\s*ans\\s*return\\s+ans$",
                    "hint": "Memoize for efficiency.",
                    "solutionCode": "        memo[(i, j)] = ans\n        return ans"
                },
                {
                    "id": 6,
                    "instruction": "Initiate the recursive process by calling the helper function from starting indices (0, 0).",
                    "placeholderCode": "    return dfs(0, 0)",
                    "validationRegex": "^\\s+return\\s+dfs\\(0,\\s*0\\)$",
                    "hint": "Start the matching process.",
                    "solutionCode": "    return dfs(0, 0)"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Use 2D bottom-up dynamic programming to solve the problem in O(m*n) time and space complexity.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function is_match that takes strings s and p.",
                    "placeholderCode": "def is_match(s, p):",
                    "validationRegex": "^def\\s+is_match\\(s,\\s*p\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def is_match(s, p):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize the DP grid with 'False' for dimensions (len(s)+1) by (len(p)+1).",
                    "placeholderCode": "    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]",
                    "validationRegex": "^\\s+dp\\s*=\\s*\\[\\[False\\]\\s*\\*\\s*\\(len\\(p\\)\\s*\\+\\s*1\\)\\s+for\\s+_\\s+in\\s+range\\(len\\(s\\)\\s*\\+\\s*1\\)\\]$",
                    "hint": "Initialize DP grid. dp[i][j] means s[i:] matches p[j:].",
                    "solutionCode": "    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]"
                },
                {
                    "id": 3,
                    "instruction": "Set the base case: an empty string matches an empty pattern.",
                    "placeholderCode": "    dp[len(s)][len(p)] = True",
                    "validationRegex": "^\\s+dp\\[len\\(s\\)\\]\\[len\\(p\\)\\]\\s*=\\s*True$",
                    "hint": "Base case: empty matches empty.",
                    "solutionCode": "    dp[len(s)][len(p)] = True"
                },
                {
                    "id": 4,
                    "instruction": "Initiate the outer loop to iterate backwards through string 's', including the index for an empty string.",
                    "placeholderCode": "    for i in range(len(s), -1, -1):",
                    "validationRegex": "^\\s+for\\s+i\\s+in\\s+range\\(len\\(s\\),\\s*-1,\\s*-1\\):$",
                    "hint": "We start from the end of the string to build the matching results bottom-up.",
                    "solutionCode": "    for i in range(len(s), -1, -1):"
                },
                {
                    "id": 5,
                    "instruction": "Initiate the inner loop to iterate backwards through pattern 'p'.",
                    "placeholderCode": "        for j in range(len(p) - 1, -1, -1):",
                    "validationRegex": "^\\s+for\\s+j\\s+in\\s+range\\(len\\(p\\)\\s*-\\s*1,\\s*-1,\\s*-1\\):$",
                    "hint": "The pattern index starts from the last character.",
                    "solutionCode": "        for j in range(len(p) - 1, -1, -1):"
                },
                {
                    "id": 6,
                    "instruction": "Check if the current character in 's' matches the current character in 'p' or if 'p' has the '.' wildcard.",
                    "placeholderCode": "            first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')",
                    "validationRegex": "^\\s+first_match\\s*=\\s*i\\s*<\\s+len\\(s\\)\\s+and\\s*\\(p\\[j\\]\\s*==\\s+s\\[i\\]\\s+or\\s+p\\[j\\]\\s*==\\s*'.'\\)$",
                    "hint": "Match if chars are equal or pattern char is '.'. Ensure i is within bounds.",
                    "solutionCode": "            first_match = i < len(s) and (p[j] == s[i] or p[j] == '.')"
                },
                {
                    "id": 7,
                    "instruction": "If the next character in the pattern is a '*' wildcard, handle the zero-or-more match case.",
                    "placeholderCode": "            if j + 1 < len(p) and p[j + 1] == '*':",
                    "validationRegex": "^\\s+if\\s+j\\s*\\+\\s*1\\s*<\\s+len\\(p\\)\\s+and\\s+p\\[j\\s*\\+\\s*1\\]\\s*==\\s*'*':$",
                    "hint": "The '*' affects how we evaluate the current and next characters.",
                    "solutionCode": "            if j + 1 < len(p) and p[j + 1] == '*':"
                },
                {
                    "id": 8,
                    "instruction": "Assign the result by either skipping the '*' (j + 2) or using it if there was a 'first_match' (i + 1).",
                    "placeholderCode": "                dp[i][j] = dp[i][j + 2] or (first_match and dp[i + 1][j])",
                    "validationRegex": "^\\s+dp\\[i\\]\\[j\\]\\s*=\\s*dp\\[i\\]\\[j\\s*\\+\\s*2\\]\\s+or\\s*\\(first_match\\s+and\\s+dp\\[i\\s*\\+\\s*1\\]\\[j\\]\\)$",
                    "hint": "Skip the '*' (match 0) or consume one char in 's' if first_match is true.",
                    "solutionCode": "                dp[i][j] = dp[i][j + 2] or (first_match and dp[i + 1][j])"
                },
                {
                    "id": 9,
                    "instruction": "If the next character in the pattern is not a '*', handle the simple match case.",
                    "placeholderCode": "            else:",
                    "validationRegex": "^\\s+else:$",
                    "hint": "Standard character matching.",
                    "solutionCode": "            else:"
                },
                {
                    "id": 10,
                    "instruction": "Assign the result based on whether the current characters match and the subsequent substrings match.",
                    "placeholderCode": "                dp[i][j] = first_match and dp[i + 1][j + 1]",
                    "validationRegex": "^\\s+dp\\[i\\]\\[j\\]\\s*=\\s*first_match\\s+and\\s+dp\\[i\\s*\\+\\s*1\\]\\[j\\s*\\+\\s*1\\]$",
                    "hint": "Requires first_match to be true and the rest of the strings to match.",
                    "solutionCode": "                dp[i][j] = first_match and dp[i + 1][j + 1]"
                },
                {
                    "id": 11,
                    "instruction": "Return the final result from the top-left of the DP table.",
                    "placeholderCode": "    return dp[0][0]",
                    "validationRegex": "^\\s+return\\s+dp\\[0\\]\\[0\\]$",
                    "hint": "The answer is stored in dp[0][0].",
                    "solutionCode": "    return dp[0][0]"
                }
            ]
        }
    }
}