{
    "id": "word-search-ii",
    "title": "Word Search II",
    "description": "Given an m x n board of characters and a list of strings words, return all words on the board.",
    "examples": [
        {
            "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
            "output": "[\"eat\",\"oath\"]"
        },
        {
            "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
            "output": "[]"
        }
    ],
    "constraints": [
        "m == board.length",
        "n == board[i].length",
        "1 <= m, n <= 12",
        "board[i][j] is a lowercase English letter.",
        "1 <= words.length <= 3 * 10^4",
        "1 <= words[i].length <= 10",
        "words[i] consists of lowercase English letters.",
        "All the strings of words are unique."
    ],
    "difficulty": "Hard",
    "topic": "Tries",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS for each word",
            "description": "Run DFS for each word on the board.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_words that takes board and words.",
                    "placeholderCode": "def find_words(board, words):",
                    "validationRegex": "^def\\s+find_words\\(board,\\s*words\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_words(board, words):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate words and board.",
                    "placeholderCode": "    res = []\n    for word in words:\n        # Check if word exists on board (omitted for brevity)\n        pass",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*for\\s+word\\s+in\\s+words:\\s*pass$",
                    "hint": "Iterate through each word and check if it exists on the board using DFS.",
                    "solutionCode": "    res = []\n    for word in words:\n        # Check if word exists on board (omitted for brevity)\n        pass"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Trie + DFS",
            "description": "Build Trie from words, then DFS on board.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the 'TrieNode' class.",
                    "placeholderCode": "class TrieNode:",
                    "validationRegex": "^class\\s+TrieNode:$",
                    "hint": "Standard class definition for a Trie junction.",
                    "solutionCode": "class TrieNode:"
                },
                {
                    "id": 2,
                    "instruction": "Define the 'TrieNode' constructor.",
                    "placeholderCode": "    def __init__(self):",
                    "validationRegex": "^\\s+def\\s+__init__\\(self\\):$",
                    "hint": "Initialize the internal state of each node.",
                    "solutionCode": "    def __init__(self):"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the children dictionary.",
                    "placeholderCode": "        self.children = {}",
                    "validationRegex": "^\\s+self\\.children\\s*=\\s*{}$",
                    "hint": "This will store the mappings from characters to children nodes.",
                    "solutionCode": "        self.children = {}"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the 'isWord' flag to False.",
                    "placeholderCode": "        self.isWord = False",
                    "validationRegex": "^\\s+self\\.isWord\\s*=\\s*False$",
                    "hint": "Used to identify if a node marks the end of a valid word.",
                    "solutionCode": "        self.isWord = False"
                },
                {
                    "id": 5,
                    "instruction": "Define the 'addWord' method.",
                    "placeholderCode": "    def addWord(self, word):",
                    "validationRegex": "^\\s+def\\s+addWord\\(self,\\s*word\\):$",
                    "hint": "Method to insert a word into the Trie.",
                    "solutionCode": "    def addWord(self, word):"
                },
                {
                    "id": 6,
                    "instruction": "Initialize a pointer 'cur' to the current node.",
                    "placeholderCode": "        cur = self",
                    "validationRegex": "^\\s+cur\\s*=\\s*self$",
                    "hint": "Start the insertion process from the node itself.",
                    "solutionCode": "        cur = self"
                },
                {
                    "id": 7,
                    "instruction": "Iterate through each character 'c' in the word.",
                    "placeholderCode": "        for c in word:",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+word:$",
                    "hint": "Process the word one character at a time.",
                    "solutionCode": "        for c in word:"
                },
                {
                    "id": 8,
                    "instruction": "Check if 'c' is not in current children.",
                    "placeholderCode": "            if c not in cur.children:",
                    "validationRegex": "^\\s+if\\s+c\\s+not\\s+in\\s+cur\\.children:$",
                    "hint": "Verify if the character branch already exists.",
                    "solutionCode": "            if c not in cur.children:"
                },
                {
                    "id": 9,
                    "instruction": "Create a new 'TrieNode' if the character doesn't exist.",
                    "placeholderCode": "                cur.children[c] = TrieNode()",
                    "validationRegex": "^\\s+cur\\.children\\[c\\]\\s*=\\s*TrieNode\\(\\)$",
                    "hint": "Extend the Trie path with a new node.",
                    "solutionCode": "                cur.children[c] = TrieNode()"
                },
                {
                    "id": 10,
                    "instruction": "Move the pointer 'cur' to the child node.",
                    "placeholderCode": "            cur = cur.children[c]",
                    "validationRegex": "^\\s+cur\\s*=\\s*cur\\.children\\[c\\]$",
                    "hint": "Advance forward in the Trie structure.",
                    "solutionCode": "            cur = cur.children[c]"
                },
                {
                    "id": 11,
                    "instruction": "Set 'isWord' to True at the final node.",
                    "placeholderCode": "        cur.isWord = True",
                    "validationRegex": "^\\s+cur\\.isWord\\s*=\\s*True$",
                    "hint": "Mark the completion of a stored word.",
                    "solutionCode": "        cur.isWord = True"
                },
                {
                    "id": 12,
                    "instruction": "Define the 'find_words' function.",
                    "placeholderCode": "def find_words(board, words):",
                    "validationRegex": "^def\\s+find_words\\(board,\\s*words\\):$",
                    "hint": "This is the main function to solve the problem.",
                    "solutionCode": "def find_words(board, words):"
                },
                {
                    "id": 13,
                    "instruction": "Initialize the root 'TrieNode'.",
                    "placeholderCode": "    root = TrieNode()",
                    "validationRegex": "^\\s+root\\s*=\\s*TrieNode\\(\\)$",
                    "hint": "Every trie starts with a base root node.",
                    "solutionCode": "    root = TrieNode()"
                },
                {
                    "id": 14,
                    "instruction": "Iterate through each word 'w' in the input words list.",
                    "placeholderCode": "    for w in words:",
                    "validationRegex": "^\\s+for\\s+w\\s+in\\s+words:$",
                    "hint": "Preparation phase: we need to insert all target words into our trie.",
                    "solutionCode": "    for w in words:"
                },
                {
                    "id": 15,
                    "instruction": "Add the current word 'w' to the Trie starting from the root.",
                    "placeholderCode": "        root.addWord(w)",
                    "validationRegex": "^\\s+root\\.addWord\\(w\\)$",
                    "hint": "Utilize the 'addWord' helper we defined in the node class.",
                    "solutionCode": "        root.addWord(w)"
                },
                {
                    "id": 16,
                    "instruction": "Get the dimensions of the board (ROWS and COLS).",
                    "placeholderCode": "    ROWS, COLS = len(board), len(board[0])",
                    "validationRegex": "^\\s+ROWS,\\s*COLS\\s*=\\s*len\\(board\\),\\s*len\\(board\\[0\\]\\)$",
                    "hint": "Calculate limits for our board traversal.",
                    "solutionCode": "    ROWS, COLS = len(board), len(board[0])"
                },
                {
                    "id": 17,
                    "instruction": "Initialize an empty set for the result and another for visited cells.",
                    "placeholderCode": "    res, visit = set(), set()",
                    "validationRegex": "^\\s+res,\\s*visit\\s*=\\s*set\\(\\),\\s*set\\(\\)$",
                    "hint": "Sets allow for O(1) lookups and ensure unique results.",
                    "solutionCode": "    res, visit = set(), set()"
                },
                {
                    "id": 18,
                    "instruction": "Define the nested 'dfs' function header.",
                    "placeholderCode": "    def dfs(r, c, node, word):",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*node,\\s*word\\):$",
                    "hint": "The function tracks coordinates, the Trie path, and the word built so far.",
                    "solutionCode": "    def dfs(r, c, node, word):"
                },
                {
                    "id": 19,
                    "instruction": "Check boundary conditions for the current row and column.",
                    "placeholderCode": "        if (r < 0 or c < 0 or r == ROWS or c == COLS or",
                    "validationRegex": "^\\s+if\\s*\\(r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*ROWS\\s+or\\s+c\\s*==\\s*COLS\\s+or$",
                    "hint": "Ensure the current cell is within board limits.",
                    "solutionCode": "        if (r < 0 or c < 0 or r == ROWS or c == COLS or"
                },
                {
                    "id": 20,
                    "instruction": "Check if the cell is visited or the character is not in the Trie node's children.",
                    "placeholderCode": "            (r, c) in visit or board[r][c] not in node.children):",
                    "validationRegex": "^\\s+\\(r,\\s*c\\)\\s+in\\s+visit\\s+or\\s+board\\[r\\]\\[c\\]\\s+not\\s+in\\s+node\\.children\\):$",
                    "hint": "Avoid infinite loops or searching invalid character paths.",
                    "solutionCode": "            (r, c) in visit or board[r][c] not in node.children):"
                },
                {
                    "id": 21,
                    "instruction": "Return early if any of the invalid conditions are met.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "Base case: stopping the recursion for this branch.",
                    "solutionCode": "            return"
                },
                {
                    "id": 22,
                    "instruction": "Mark the current board cell as visited.",
                    "placeholderCode": "        visit.add((r, c))",
                    "validationRegex": "^\\s+visit\\.add\\(\\(\\(r,\\s*c\\)\\)\\)$",
                    "hint": "Record this cell so we don't reuse it in the same word.",
                    "solutionCode": "        visit.add((r, c))"
                },
                {
                    "id": 23,
                    "instruction": "Advance the 'node' pointer to the character's child node.",
                    "placeholderCode": "        node = node.children[board[r][c]]",
                    "validationRegex": "^\\s+node\\s*=\\s*node\\.children\\[board\\[r\\]\\[c\\]\\]$",
                    "hint": "Synchronize the board character with the Trie depth.",
                    "solutionCode": "        node = node.children[board[r][c]]"
                },
                {
                    "id": 24,
                    "instruction": "Append the current board character to the 'word' string.",
                    "placeholderCode": "        word += board[r][c]",
                    "validationRegex": "^\\s+word\\s*\\+=\\s*board\\[r\\]\\[c\\]$",
                    "hint": "Building the string candidate to check against our target list.",
                    "solutionCode": "        word += board[r][c]"
                },
                {
                    "id": 25,
                    "instruction": "Check if the current node completes a stored word.",
                    "placeholderCode": "        if node.isWord:",
                    "validationRegex": "^\\s+if\\s+node\\.isWord:$",
                    "hint": "Using the 'isWord' flag defined in our TrieNode.",
                    "solutionCode": "        if node.isWord:"
                },
                {
                    "id": 26,
                    "instruction": "If a word is found, add it to the result set.",
                    "placeholderCode": "            res.add(word)",
                    "validationRegex": "^\\s+res\\.add\\(word\\)$",
                    "hint": "Found a target word on the board!",
                    "solutionCode": "            res.add(word)"
                },
                {
                    "id": 27,
                    "instruction": "Recursively explore the cell below.",
                    "placeholderCode": "        dfs(r + 1, c, node, word)",
                    "validationRegex": "^\\s+dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*node,\\s*word\\)$",
                    "hint": "Move along the Y axis downwards.",
                    "solutionCode": "        dfs(r + 1, c, node, word)"
                },
                {
                    "id": 28,
                    "instruction": "Recursively explore the cell above.",
                    "placeholderCode": "        dfs(r - 1, c, node, word)",
                    "validationRegex": "^\\s+dfs\\(r\\s*-\\s*1,\\s*c,\\s*node,\\s*word\\)$",
                    "hint": "Move along the Y axis upwards.",
                    "solutionCode": "        dfs(r - 1, c, node, word)"
                },
                {
                    "id": 29,
                    "instruction": "Recursively explore the cell to the right.",
                    "placeholderCode": "        dfs(r, c + 1, node, word)",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*node,\\s*word\\)$",
                    "hint": "Move along the X axis to the right.",
                    "solutionCode": "        dfs(r, c + 1, node, word)"
                },
                {
                    "id": 30,
                    "instruction": "Recursively explore the cell to the left.",
                    "placeholderCode": "        dfs(r, c - 1, node, word)",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c\\s*-\\s*1,\\s*node,\\s*word\\)$",
                    "hint": "Move along the X axis to the left.",
                    "solutionCode": "        dfs(r, c - 1, node, word)"
                },
                {
                    "id": 31,
                    "instruction": "Remove the current cell from visit set (Backtrack).",
                    "placeholderCode": "        visit.remove((r, c))",
                    "validationRegex": "^\\s+visit\\.remove\\(\\(\\(r,\\s*c\\)\\)\\)$",
                    "hint": "Cleanup step to allow this cell to be used in other word candidates.",
                    "solutionCode": "        visit.remove((r, c))"
                },
                {
                    "id": 32,
                    "instruction": "Iterate through every row index 'r' on the board.",
                    "placeholderCode": "    for r in range(ROWS):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(ROWS\\):$",
                    "hint": "Scanning the board row by row.",
                    "solutionCode": "    for r in range(ROWS):"
                },
                {
                    "id": 33,
                    "instruction": "Iterate through every column index 'c' in the row.",
                    "placeholderCode": "        for c in range(COLS):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(COLS\\):$",
                    "hint": "Scanning each cell within the current row.",
                    "solutionCode": "        for c in range(COLS):"
                },
                {
                    "id": 34,
                    "instruction": "Initiate the DFS traversal for the current cell starting from the Trie root.",
                    "placeholderCode": "            dfs(r, c, root, \"\")",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c,\\s*root,\\s*\"\"\\)$",
                    "hint": "Every board cell is a potential starting point for a word.",
                    "solutionCode": "            dfs(r, c, root, \"\")"
                },
                {
                    "id": 35,
                    "instruction": "Return the final results converted from a set to a list.",
                    "placeholderCode": "    return list(res)",
                    "validationRegex": "^\\s+return\\s+list\\(res\\)$",
                    "hint": "Deliver the final list of discovered words.",
                    "solutionCode": "    return list(res)"
                }
            ]
        }
    }
}