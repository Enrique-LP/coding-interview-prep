{
    "id": "word-search-ii",
    "title": "Word Search II",
    "description": "Given an m x n board of characters and a list of strings words, return all words on the board.",
    "examples": [
        {
            "input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
            "output": "[\"eat\",\"oath\"]"
        },
        {
            "input": "board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]",
            "output": "[]"
        }
    ],
    "constraints": [
        "m == board.length",
        "n == board[i].length",
        "1 <= m, n <= 12",
        "board[i][j] is a lowercase English letter.",
        "1 <= words.length <= 3 * 10^4",
        "1 <= words[i].length <= 10",
        "words[i] consists of lowercase English letters.",
        "All the strings of words are unique."
    ],
    "difficulty": "Hard",
    "topic": "Tries",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "DFS for each word",
            "description": "Run DFS for each word on the board.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function find_words that takes board and words.",
                    "placeholderCode": "def find_words(board, words):",
                    "validationRegex": "^def\\s+find_words\\(board,\\s*words\\):$",
                    "hint": "Use `def` to define the function.",
                    "solutionCode": "def find_words(board, words):"
                },
                {
                    "id": 2,
                    "instruction": "Iterate words and board.",
                    "placeholderCode": "    res = []\n    for word in words:\n        # Check if word exists on board (omitted for brevity)\n        pass",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[\\]\\s*for\\s+word\\s+in\\s+words:\\s*pass$",
                    "hint": "Iterate through each word and check if it exists on the board using DFS.",
                    "solutionCode": "    res = []\n    for word in words:\n        # Check if word exists on board (omitted for brevity)\n        pass"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Trie + DFS",
            "description": "Build Trie from words, then DFS on board.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the 'TrieNode' class.",
                    "placeholderCode": "class TrieNode:",
                    "validationRegex": "^class\\s+TrieNode:$",
                    "hint": "Standard class definition for a Trie junction.",
                    "solutionCode": "class TrieNode:"
                },
                {
                    "id": 2,
                    "instruction": "Define the 'TrieNode' constructor.",
                    "placeholderCode": "    def __init__(self):",
                    "validationRegex": "^\\s+def\\s+__init__\\(self\\):$",
                    "hint": "Prepare the node's internal properties.",
                    "solutionCode": "    def __init__(self):"
                },
                {
                    "id": 3,
                    "instruction": "Initialize the children dictionary.",
                    "placeholderCode": "        self.children = {}",
                    "validationRegex": "^\\s+self\\.children\\s*=\\s*{}$",
                    "hint": "Use a dictionary to map characters to child nodes.",
                    "solutionCode": "        self.children = {}"
                },
                {
                    "id": 4,
                    "instruction": "Initialize the 'isWord' flag to False.",
                    "placeholderCode": "        self.isWord = False",
                    "validationRegex": "^\\s+self\\.isWord\\s*=\\s*False$",
                    "hint": "Flag used to mark the terminal character of a word.",
                    "solutionCode": "        self.isWord = False"
                },
                {
                    "id": 5,
                    "instruction": "Define the 'addWord' method.",
                    "placeholderCode": "    def addWord(self, word):",
                    "validationRegex": "^\\s+def\\s+addWord\\(self,\\s*word\\):$",
                    "hint": "Method signature to insert a word into the Trie.",
                    "solutionCode": "    def addWord(self, word):"
                },
                {
                    "id": 6,
                    "instruction": "Initialize a pointer 'cur' to the current node.",
                    "placeholderCode": "        cur = self",
                    "validationRegex": "^\\s+cur\\s*=\\s*self$",
                    "hint": "Start traversing from the current node object.",
                    "solutionCode": "        cur = self"
                },
                {
                    "id": 7,
                    "instruction": "Iterate through each character 'c' in the word.",
                    "placeholderCode": "        for c in word:",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+word:$",
                    "hint": "Standard loop for Trie insertion.",
                    "solutionCode": "        for c in word:"
                },
                {
                    "id": 8,
                    "instruction": "Check if 'c' is not in current children.",
                    "placeholderCode": "            if c not in cur.children:",
                    "validationRegex": "^\\s+if\\s+c\\s+not\\s+in\\s+cur\\.children:$",
                    "hint": "Determine if we need to create a new branch.",
                    "solutionCode": "            if c not in cur.children:"
                },
                {
                    "id": 9,
                    "instruction": "Create a new 'TrieNode' if the character doesn't exist.",
                    "placeholderCode": "                cur.children[c] = TrieNode()",
                    "validationRegex": "^\\s+cur\\.children\\[c\\]\\s*=\\s*TrieNode\\(\\)$",
                    "hint": "Assign a new node to the character key.",
                    "solutionCode": "                cur.children[c] = TrieNode()"
                },
                {
                    "id": 10,
                    "instruction": "Move the pointer 'cur' to the child node.",
                    "placeholderCode": "            cur = cur.children[c]",
                    "validationRegex": "^\\s+cur\\s*=\\s*cur\\.children\\[c\\]$",
                    "hint": "Advance the pointer forward to the next depth level.",
                    "solutionCode": "            cur = cur.children[c]"
                },
                {
                    "id": 11,
                    "instruction": "Set 'isWord' to True at the final node.",
                    "placeholderCode": "        cur.isWord = True",
                    "validationRegex": "^\\s+cur\\.isWord\\s*=\\s*True$",
                    "hint": "Mark the node as the end of the word after the loop ends.",
                    "solutionCode": "        cur.isWord = True"
                },
                {
                    "id": 12,
                    "instruction": "Define the 'find_words' function.",
                    "placeholderCode": "def find_words(board, words):",
                    "validationRegex": "^def\\s+find_words\\(board,\\s*words\\):$",
                    "hint": "Global function definition for solving the board.",
                    "solutionCode": "def find_words(board, words):"
                },
                {
                    "id": 13,
                    "instruction": "Initialize the root 'TrieNode'.",
                    "placeholderCode": "    root = TrieNode()",
                    "validationRegex": "^\\s+root\\s*=\\s*TrieNode\\(\\)$",
                    "hint": "Every word list needs a root entry point.",
                    "solutionCode": "    root = TrieNode()"
                },
                {
                    "id": 14,
                    "instruction": "Iterate through each word 'w' in the input words list.",
                    "placeholderCode": "    for w in words:",
                    "validationRegex": "^\\s+for\\s+w\\s+in\\s+words:$",
                    "hint": "Build the prefix tree word by word.",
                    "solutionCode": "    for w in words:"
                },
                {
                    "id": 15,
                    "instruction": "Add the current word 'w' to the Trie starting from the root.",
                    "placeholderCode": "        root.addWord(w)",
                    "validationRegex": "^\\s+root\\.addWord\\(w\\)$",
                    "hint": "Call the instance method on the root node.",
                    "solutionCode": "        root.addWord(w)"
                },
                {
                    "id": 16,
                    "instruction": "Get the dimensions of the board (ROWS and COLS).",
                    "placeholderCode": "    ROWS, COLS = len(board), len(board[0])",
                    "validationRegex": "^\\s+ROWS,\\s*COLS\\s*=\\s*len\\(board\\),\\s*len\\(board\\[0\\]\\)$",
                    "hint": "Store board size to avoid repeated length calls.",
                    "solutionCode": "    ROWS, COLS = len(board), len(board[0])"
                },
                {
                    "id": 17,
                    "instruction": "Initialize an empty set for the result and another for visited cells.",
                    "placeholderCode": "    res, visit = set(), set()",
                    "validationRegex": "^\\s+res,\\s*visit\\s*=\\s*set\\(\\),\\s*set\\(\\)$",
                    "hint": "Prepare storage for discovered words and traversed coordinates.",
                    "solutionCode": "    res, visit = set(), set()"
                },
                {
                    "id": 18,
                    "instruction": "Define the nested 'dfs' function header.",
                    "placeholderCode": "    def dfs(r, c, node, word):",
                    "validationRegex": "^\\s+def\\s+dfs\\(r,\\s*c,\\s*node,\\s*word\\):$",
                    "hint": "CRITICAL: The DFS must be defined INSIDE 'find_words' and indented accordingly.",
                    "solutionCode": "    def dfs(r, c, node, word):"
                },
                {
                    "id": 19,
                    "instruction": "Check if the current coordinates 'r' or 'c' are out of the board boundaries.",
                    "placeholderCode": "        if r < 0 or c < 0 or r == ROWS or c == COLS:",
                    "validationRegex": "^\\s+if\\s+r\\s*<\\s*0\\s+or\\s+c\\s*<\\s*0\\s+or\\s+r\\s*==\\s*ROWS\\s+or\\s+c\\s*==\\s*COLS:$",
                    "hint": "Boundary check: indices must be within [0, ROWS-1] and [0, COLS-1].",
                    "solutionCode": "        if r < 0 or c < 0 or r == ROWS or c == COLS:"
                },
                {
                    "id": 20,
                    "instruction": "Return if the current cell is out of bounds.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "Base case: exit recursion if indices are invalid.",
                    "solutionCode": "            return"
                },
                {
                    "id": 21,
                    "instruction": "Check if the cell has been visited or the board character is not in the Trie children.",
                    "placeholderCode": "        if (r, c) in visit or board[r][c] not in node.children:",
                    "validationRegex": "^\\s+if\\s+\\(\\s*r,\\s*c\\s*\\)\\s+in\\s+visit\\s+or\\s+board\\[r\\]\\[c\\]\\s+not\\s+in\\s+node\\.children:$",
                    "hint": "Check for cycles or prefix existence in the Trie. Note: (r, c) syntax is sensitive.",
                    "solutionCode": "        if (r, c) in visit or board[r][c] not in node.children:"
                },
                {
                    "id": 22,
                    "instruction": "Return if the character path is invalid or already used.",
                    "placeholderCode": "            return",
                    "validationRegex": "^\\s+return$",
                    "hint": "Exit recursion if the character doesn't lead to a target word.",
                    "solutionCode": "            return"
                },
                {
                    "id": 23,
                    "instruction": "Mark the current board cell as visited.",
                    "placeholderCode": "        visit.add((r, c))",
                    "validationRegex": "^\\s+visit\\.add\\(\\s*\\(\\s*r,\\s*c\\s*\\)\\s*\\)$",
                    "hint": "Add the current coordinate tuple to the 'visit' set.",
                    "solutionCode": "        visit.add((r, c))"
                },
                {
                    "id": 24,
                    "instruction": "Advance the 'node' pointer to the character's child node.",
                    "placeholderCode": "        node = node.children[board[r][c]]",
                    "validationRegex": "^\\s+node\\s*=\\s*node\\.children\\[board\\[r\\]\\[c\\]\\]$",
                    "hint": "Descend into the Trie using the current board character.",
                    "solutionCode": "        node = node.children[board[r][c]]"
                },
                {
                    "id": 25,
                    "instruction": "Append the current board character to the 'word' string.",
                    "placeholderCode": "        word += board[r][c]",
                    "validationRegex": "^\\s+word\\s*\\+=\\s*board\\[r\\]\\[c\\]$",
                    "hint": "Concat the character to our running prefix string.",
                    "solutionCode": "        word += board[r][c]"
                },
                {
                    "id": 26,
                    "instruction": "Check if the current node completes a stored word.",
                    "placeholderCode": "        if node.isWord:",
                    "validationRegex": "^\\s+if\\s+node\\.isWord:$",
                    "hint": "Verify if the current Trie path represents a full word from the input list.",
                    "solutionCode": "        if node.isWord:"
                },
                {
                    "id": 27,
                    "instruction": "If a word is found, add it to the result set.",
                    "placeholderCode": "            res.add(word)",
                    "validationRegex": "^\\s+res\\.add\\(word\\)$",
                    "hint": "Collect the discovered word in the 'res' set.",
                    "solutionCode": "            res.add(word)"
                },
                {
                    "id": 28,
                    "instruction": "Recursively explore the cell below.",
                    "placeholderCode": "        dfs(r + 1, c, node, word)",
                    "validationRegex": "^\\s+dfs\\(r\\s*\\+\\s*1,\\s*c,\\s*node,\\s*word\\)$",
                    "hint": "Continue the DFS downward (r + 1).",
                    "solutionCode": "        dfs(r + 1, c, node, word)"
                },
                {
                    "id": 29,
                    "instruction": "Recursively explore the cell above.",
                    "placeholderCode": "        dfs(r - 1, c, node, word)",
                    "validationRegex": "^\\s+dfs\\(r\\s*-\\s*1,\\s*c,\\s*node,\\s*word\\)$",
                    "hint": "Continue the DFS upward (r - 1).",
                    "solutionCode": "        dfs(r - 1, c, node, word)"
                },
                {
                    "id": 30,
                    "instruction": "Recursively explore the cell to the right.",
                    "placeholderCode": "        dfs(r, c + 1, node, word)",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c\\s*\\+\\s*1,\\s*node,\\s*word\\)$",
                    "hint": "Continue the DFS to the right (c + 1).",
                    "solutionCode": "        dfs(r, c + 1, node, word)"
                },
                {
                    "id": 31,
                    "instruction": "Recursively explore the cell to the left.",
                    "placeholderCode": "        dfs(r, c - 1, node, word)",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c\\s*-\\s*1,\\s*node,\\s*word\\)$",
                    "hint": "Continue the DFS to the left (c - 1).",
                    "solutionCode": "        dfs(r, c - 1, node, word)"
                },
                {
                    "id": 32,
                    "instruction": "Remove the current cell from visit set (Backtrack).",
                    "placeholderCode": "        visit.remove((r, c))",
                    "validationRegex": "^\\s+visit\\.remove\\(\\s*\\(\\s*r,\\s*c\\s*\\)\\s*\\)$",
                    "hint": "Crucial: remove the coordinates from 'visit' to allow other paths to use this cell.",
                    "solutionCode": "        visit.remove((r, c))"
                },
                {
                    "id": 33,
                    "instruction": "Iterate through every row index 'r' on the board.",
                    "placeholderCode": "    for r in range(ROWS):",
                    "validationRegex": "^\\s+for\\s+r\\s+in\\s+range\\(ROWS\\):$",
                    "hint": "Outer loop to start DFS from every cell on the board.",
                    "solutionCode": "    for r in range(ROWS):"
                },
                {
                    "id": 34,
                    "instruction": "Iterate through every column index 'c' in the row.",
                    "placeholderCode": "        for c in range(COLS):",
                    "validationRegex": "^\\s+for\\s+c\\s+in\\s+range\\(COLS\\):$",
                    "hint": "Inner loop to start DFS from every cell on the board.",
                    "solutionCode": "        for c in range(COLS):"
                },
                {
                    "id": 35,
                    "instruction": "Initiate the DFS traversal for the current cell starting from the Trie root.",
                    "placeholderCode": "            dfs(r, c, root, \"\")",
                    "validationRegex": "^\\s+dfs\\(r,\\s*c,\\s*root,\\s*\"\"\\)$",
                    "hint": "Trigger the initial DFS call from the root and empty string.",
                    "solutionCode": "            dfs(r, c, root, \"\")"
                },
                {
                    "id": 36,
                    "instruction": "Return the final results converted from a set to a list.",
                    "placeholderCode": "    return list(res)",
                    "validationRegex": "^\\s+return\\s+list\\(res\\)$",
                    "hint": "Format final set of results into a list for the caller.",
                    "solutionCode": "    return list(res)"
                }
            ]
        }
    }
}