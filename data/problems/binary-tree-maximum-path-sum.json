{
    "id": "binary-tree-maximum-path-sum",
    "title": "Binary Tree Maximum Path Sum",
    "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root. The path sum of a path is the sum of the node's values in the path. Given the root of a binary tree, return the maximum path sum of any non-empty path.",
    "examples": [
        {
            "input": "root = [1,2,3]",
            "output": 6,
            "explanation": "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6."
        },
        {
            "input": "root = [-10,9,20,null,null,15,7]",
            "output": 42,
            "explanation": "The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."
        }
    ],
    "constraints": [
        "The number of nodes in the tree is in the range [1, 3 * 10^4].",
        "-1000 <= Node.val <= 1000"
    ],
    "difficulty": "Hard",
    "topic": "Trees",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Recursive DFS",
            "description": "Post-order traversal to calculate the maximum contribution of each subtree while updating a global maximum path sum.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the 'max_path_sum' function with 'root' as parameter.",
                    "placeholderCode": "def max_path_sum(root):",
                    "validationRegex": "^def\\s+max_path_sum\\(root\\):$",
                    "hint": "Start the main function definition.",
                    "solutionCode": "def max_path_sum(root):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize a mutable list 'res' with the root's value to store our global maximum.",
                    "placeholderCode": "    res = [root.val]",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[root\\.val\\]$",
                    "hint": "Using a list allows us to modify the global maximum inside our nested helper function.",
                    "solutionCode": "    res = [root.val]"
                },
                {
                    "id": 3,
                    "instruction": "Define the 'dfs' helper function that takes the current node.",
                    "placeholderCode": "    def dfs(curr):",
                    "validationRegex": "^\\s+def\\s+dfs\\(curr\\):$",
                    "hint": "This function will calculate the max path starting from the current node going downwards.",
                    "solutionCode": "    def dfs(curr):"
                },
                {
                    "id": 4,
                    "instruction": "Handle the base case: return 0 if the current node is null.",
                    "placeholderCode": "        if not curr: return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+curr:\\s*return\\s*0$",
                    "hint": "An empty node adds 0 to the path sum.",
                    "solutionCode": "        if not curr: return 0"
                },
                {
                    "id": 5,
                    "instruction": "Recursively find the maximum path sum from the left child.",
                    "placeholderCode": "        leftMax = dfs(curr.left)",
                    "validationRegex": "^\\s+leftMax\\s*=\\s*dfs\\(curr\\.left\\)$",
                    "hint": "Travel down to the left subtree.",
                    "solutionCode": "        leftMax = dfs(curr.left)"
                },
                {
                    "id": 6,
                    "instruction": "Recursively find the maximum path sum from the right child.",
                    "placeholderCode": "        rightMax = dfs(curr.right)",
                    "validationRegex": "^\\s+rightMax\\s*=\\s*dfs\\(curr\\.right\\)$",
                    "hint": "Travel down to the right subtree.",
                    "solutionCode": "        rightMax = dfs(curr.right)"
                },
                {
                    "id": 7,
                    "instruction": "Ignore negative path sums from the left child by taking the max with 0.",
                    "placeholderCode": "        leftMax = max(leftMax, 0)",
                    "validationRegex": "^\\s+leftMax\\s*=\\s*max\\(leftMax,\\s*0\\)$",
                    "hint": "If a subtree has a negative total, it's better not to include it in our path.",
                    "solutionCode": "        leftMax = max(leftMax, 0)"
                },
                {
                    "id": 8,
                    "instruction": "Ignore negative path sums from the right child by taking the max with 0.",
                    "placeholderCode": "        rightMax = max(rightMax, 0)",
                    "validationRegex": "^\\s+rightMax\\s*=\\s*max\\(rightMax,\\s*0\\)$",
                    "hint": "Similarly, discard negative contributions from the right.",
                    "solutionCode": "        rightMax = max(rightMax, 0)"
                },
                {
                    "id": 9,
                    "instruction": "Update the global maximum by considering the current node as the 'peak' of a path.",
                    "placeholderCode": "        res[0] = max(res[0], curr.val + leftMax + rightMax)",
                    "validationRegex": "^\\s+res\\[0\\]\\s*=\\s*max\\(res\\[0\\],\\s*curr\\.val\\s*\\+\\s*leftMax\\s*\\+\\s*rightMax\\)$",
                    "hint": "A path can 'bridge' through the current node, combining left and right subtrees.",
                    "solutionCode": "        res[0] = max(res[0], curr.val + leftMax + rightMax)"
                },
                {
                    "id": 10,
                    "instruction": "Return the maximum single path reaching this node to the parent caller.",
                    "placeholderCode": "        return curr.val + max(leftMax, rightMax)",
                    "validationRegex": "^\\s+return\\s+curr\\.val\\s*\\+\\s*max\\(leftMax,\\s*rightMax\\)$",
                    "hint": "A parent can only extend a path through one of its children (not both).",
                    "solutionCode": "        return curr.val + max(leftMax, rightMax)"
                },
                {
                    "id": 11,
                    "instruction": "Kick off the DFS traversal starting from the root.",
                    "placeholderCode": "    dfs(root)",
                    "validationRegex": "^\\s+dfs\\(root\\)$",
                    "hint": "Call your helper function to process the entire tree.",
                    "solutionCode": "    dfs(root)"
                },
                {
                    "id": 12,
                    "instruction": "Return the first element of the 'res' list as the final result.",
                    "placeholderCode": "    return res[0]",
                    "validationRegex": "^\\s+return\\s+res\\[0\\]$",
                    "hint": "The answer is stored in our mutable list at index 0.",
                    "solutionCode": "    return res[0]"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "One-Pass DFS (Path Contribution)",
            "description": "Highly efficient DFS that calculates both the maximum contribution of a node to its parent and updates the worldwide maximum sum at each step.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Start the 'max_path_sum' function definition.",
                    "placeholderCode": "def max_path_sum(root):",
                    "validationRegex": "^def\\s+max_path_sum\\(root\\):$",
                    "hint": "Input is the root of the binary tree.",
                    "solutionCode": "def max_path_sum(root):"
                },
                {
                    "id": 2,
                    "instruction": "Create a list 'res' starting with root value to maintain the maximum path sum found.",
                    "placeholderCode": "    res = [root.val]",
                    "validationRegex": "^\\s+res\\s*=\\s*\\[root\\.val\\]$",
                    "hint": "Using a list wrapper allows the nested function to update this variable.",
                    "solutionCode": "    res = [root.val]"
                },
                {
                    "id": 3,
                    "instruction": "Define a helper 'dfs' to traverse the tree and calculate path sums.",
                    "placeholderCode": "    def dfs(curr):",
                    "validationRegex": "^\\s+def\\s+dfs\\(curr\\):$",
                    "hint": "This helper will return the maximum 'one-sided' path sum.",
                    "solutionCode": "    def dfs(curr):"
                },
                {
                    "id": 4,
                    "instruction": "Return 0 if the current node is None.",
                    "placeholderCode": "        if not curr: return 0",
                    "validationRegex": "^\\s+if\\s+not\\s+curr:\\s*return\\s*0$",
                    "hint": "Base case for the recursive traversal.",
                    "solutionCode": "        if not curr: return 0"
                },
                {
                    "id": 5,
                    "instruction": "Calculate the maximum path sum from the left subtree.",
                    "placeholderCode": "        leftMax = dfs(curr.left)",
                    "validationRegex": "^\\s+leftMax\\s*=\\s*dfs\\(curr\\.left\\)$",
                    "hint": "Recursively visit the left child.",
                    "solutionCode": "        leftMax = dfs(curr.left)"
                },
                {
                    "id": 6,
                    "instruction": "Calculate the maximum path sum from the right subtree.",
                    "placeholderCode": "        rightMax = dfs(curr.right)",
                    "validationRegex": "^\\s+rightMax\\s*=\\s*dfs\\(curr\\.right\\)$",
                    "hint": "Recursively visit the right child.",
                    "solutionCode": "        rightMax = dfs(curr.right)"
                },
                {
                    "id": 7,
                    "instruction": "Ensure the left contribution is non-negative.",
                    "placeholderCode": "        leftMax = max(leftMax, 0)",
                    "validationRegex": "^\\s+leftMax\\s*=\\s*max\\(leftMax,\\s*0\\)$",
                    "hint": "If the path sum is negative, it's better not to include it.",
                    "solutionCode": "        leftMax = max(leftMax, 0)"
                },
                {
                    "id": 8,
                    "instruction": "Ensure the right contribution is non-negative.",
                    "placeholderCode": "        rightMax = max(rightMax, 0)",
                    "validationRegex": "^\\s+rightMax\\s*=\\s*max\\(rightMax,\\s*0\\)$",
                    "hint": "Only add positive contributions from the right branch.",
                    "solutionCode": "        rightMax = max(rightMax, 0)"
                },
                {
                    "id": 9,
                    "instruction": "Compute the path sum passing through the current node and update the global max.",
                    "placeholderCode": "        res[0] = max(res[0], curr.val + leftMax + rightMax)",
                    "validationRegex": "^\\s+res\\[0\\]\\s*=\\s*max\\(res\\[0\\],\\s*curr\\.val\\s*\\+\\s*leftMax\\s*\\+\\s*rightMax\\)$",
                    "hint": "Check if a path through this node is larger than our current global maximum.",
                    "solutionCode": "        res[0] = max(res[0], curr.val + leftMax + rightMax)"
                },
                {
                    "id": 10,
                    "instruction": "Return the current node's value plus the best contribution from either side.",
                    "placeholderCode": "        return curr.val + max(leftMax, rightMax)",
                    "validationRegex": "^\\s+return\\s+curr\\.val\\s*\\+\\s*max\\(leftMax,\\s*rightMax\\)$",
                    "hint": "Return the maximum path that can be extended by the parent node.",
                    "solutionCode": "        return curr.val + max(leftMax, rightMax)"
                },
                {
                    "id": 11,
                    "instruction": "Initiate the recursive search.",
                    "placeholderCode": "    dfs(root)",
                    "validationRegex": "^\\s+dfs\\(root\\)$",
                    "hint": "Start processing the tree from the root node.",
                    "solutionCode": "    dfs(root)"
                },
                {
                    "id": 12,
                    "instruction": "Return the final maximum path sum found during the traversal.",
                    "placeholderCode": "    return res[0]",
                    "validationRegex": "^\\s+return\\s+res\\[0\\]$",
                    "hint": "Retrieve the final result stored in the mutable list.",
                    "solutionCode": "    return res[0]"
                }
            ]
        }
    }
}