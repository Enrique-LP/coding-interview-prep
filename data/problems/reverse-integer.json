{
    "id": "reverse-integer",
    "title": "Reverse Integer",
    "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.",
    "examples": [
        {
            "input": "x = 123",
            "output": "321"
        },
        {
            "input": "x = -123",
            "output": "-321"
        },
        {
            "input": "x = 120",
            "output": "21"
        }
    ],
    "constraints": [
        "-2^31 <= x <= 2^31 - 1"
    ],
    "difficulty": "Medium",
    "topic": "Bit Manipulation",
    "strategies": {
        "brute-force": {
            "id": "brute-force",
            "name": "Brute Force",
            "description": "Convert to string, reverse, handle sign.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function reverse that takes x.",
                    "placeholderCode": "def reverse(x):",
                    "validationRegex": "^def\\s+reverse\\(x\\):$",
                    "hint": "Use the `def` keyword to define the function.",
                    "solutionCode": "def reverse(x):"
                },
                {
                    "id": 2,
                    "instruction": "Handle sign and reverse.",
                    "placeholderCode": "    sign = -1 if x < 0 else 1\n    res = int(str(abs(x))[::-1]) * sign",
                    "validationRegex": "^\\s+sign\\s*=\\s*-1\\s+if\\s+x\\s*<\\s*0\\s+else\\s+1\\s*res\\s*=\\s*int\\(str\\(abs\\(x\\)\\)\\[::-1\\]\\)\\s*\\*\\s*sign$",
                    "hint": "Store the sign. Convert absolute value of `x` to string, reverse it, convert back to int, and re-apply sign.",
                    "solutionCode": "    sign = -1 if x < 0 else 1\n    res = int(str(abs(x))[::-1]) * sign"
                },
                {
                    "id": 3,
                    "instruction": "Check overflow.",
                    "placeholderCode": "    if res < -2**31 or res > 2**31 - 1: return 0\n    return res",
                    "validationRegex": "^\\s+if\\s+res\\s*<\\s*-2\\*\\*31\\s+or\\s+res\\s*>\\s*2\\*\\*31\\s*-\\s*1:\\s*return\\s+0\\s*return\\s+res$",
                    "hint": "Return 0 if `res` is outside the range [-2^31, 2^31 - 1]. Otherwise return `res`.",
                    "solutionCode": "    if res < -2**31 or res > 2**31 - 1: return 0\n    return res"
                }
            ]
        },
        "optimal": {
            "id": "optimal",
            "name": "Optimal",
            "description": "Pop and push digits.",
            "steps": [
                {
                    "id": 1,
                    "instruction": "Define the function reverse that takes x.",
                    "placeholderCode": "def reverse(x):",
                    "validationRegex": "^def\\s+reverse\\(x\\):$",
                    "hint": "Use the `def` keyword to define the function.",
                    "solutionCode": "def reverse(x):"
                },
                {
                    "id": 2,
                    "instruction": "Initialize result variable.",
                    "placeholderCode": "    res = 0",
                    "validationRegex": "^\\s+res\\s*=\\s*0$",
                    "hint": "Initialize `res` to 0 to store the reversed number.",
                    "solutionCode": "    res = 0"
                },
                {
                    "id": 3,
                    "instruction": "Determine the sign of x.",
                    "placeholderCode": "    sign = -1 if x < 0 else 1",
                    "validationRegex": "^\\s+sign\\s*=\\s*-1\\s+if\\s+x\\s*<\\s*0\\s+else\\s+1$",
                    "hint": "Store the sign: -1 if `x` is negative, else 1.",
                    "solutionCode": "    sign = -1 if x < 0 else 1"
                },
                {
                    "id": 4,
                    "instruction": "Work with absolute value of x.",
                    "placeholderCode": "    x = abs(x)",
                    "validationRegex": "^\\s+x\\s*=\\s*abs\\(x\\)$",
                    "hint": "Update `x` to be its absolute value for easier digit processing.",
                    "solutionCode": "    x = abs(x)"
                },
                {
                    "id": 5,
                    "instruction": "Loop while x is not zero.",
                    "placeholderCode": "    while x:",
                    "validationRegex": "^\\s+while\\s+x:$",
                    "hint": "Process digits until `x` becomes 0.",
                    "solutionCode": "    while x:"
                },
                {
                    "id": 6,
                    "instruction": "Get the last digit.",
                    "placeholderCode": "        digit = x % 10",
                    "validationRegex": "^\\s+digit\\s*=\\s*x\\s*%\\s*10$",
                    "hint": "Use modulo 10 (`% 10`) to extract the last digit.",
                    "solutionCode": "        digit = x % 10"
                },
                {
                    "id": 7,
                    "instruction": "Remove the last digit from x.",
                    "placeholderCode": "        x //= 10",
                    "validationRegex": "^\\s+x\\s*//=\\s*10$",
                    "hint": "Use integer division (`//= 10`) to remove the last digit.",
                    "solutionCode": "        x //= 10"
                },
                {
                    "id": 8,
                    "instruction": "Check for overflow.",
                    "placeholderCode": "        if res > (2**31 - 1) // 10: return 0",
                    "validationRegex": "^\\s+if\\s+res\\s*>\\s*\\(2\\*\\*31\\s*-\\s*1\\)\\s*//\\s*10:\\s*return\\s+0$",
                    "hint": "Check if multiplying `res` by 10 would exceed the 32-bit signed integer limit (`2**31 - 1`). If so, return 0.",
                    "solutionCode": "        if res > (2**31 - 1) // 10: return 0"
                },
                {
                    "id": 9,
                    "instruction": "Add digit to result.",
                    "placeholderCode": "        res = res * 10 + digit",
                    "validationRegex": "^\\s+res\\s*=\\s*res\\s*\\*\\s*10\\s*\\+\\s*digit$",
                    "hint": "Shift `res` to the left (multiply by 10) and add the new `digit`.",
                    "solutionCode": "        res = res * 10 + digit"
                },
                {
                    "id": 10,
                    "instruction": "Return result with sign.",
                    "placeholderCode": "    return res * sign",
                    "validationRegex": "^\\s+return\\s+res\\s*\\*\\s*sign$",
                    "hint": "Multiply by sign to restore original polarity.",
                    "solutionCode": "    return res * sign"
                }
            ]
        }
    }
}